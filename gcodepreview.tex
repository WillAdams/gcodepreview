% !TeX program = lualatex

% gcodepreview.tex
% Author: William F. Adams (willadams at aol dot com)
% Copyright 2021--25 William F. Adams
%
% This work may be distributed and/or modified under the
% conditions of the GNU LESSER GENERAL PUBLIC LICENSE
% Version 2.1, February 1999
%
% This work consists of the files listed in the README file.
%
% 
% 
\documentclass{ltxdoc}
%https://tex.stackexchange.com/questions/722886/how-to-write-out-multiple-text-files-from-multiple-instances-of-latex-environmen
\usepackage{literati}
\usepackage[paper=legalpaper, left=1.75in, right=0.75in, top=1in, bottom=1in]{geometry}

\usepackage[usenames,dvipsnames]{xcolor} 

\usepackage{markdown}

\usepackage[debug, acronym]{glossaries}

% Generate the glossary
\makeglossaries

%TODO Add Glossary entries for all commands
%\newglossaryentry{settool}
%{
%    name=settool, 
%    description={settool(102)}
%}

%TODO Add numpydocstrings: Note that \verb|numpydoc|-style docstrings will be added to help define the functionality of each defined module in Python. \url{https://numpydoc.readthedocs.io/en/latest/}.

\newcommand{\includeimage}[1]{\bigskip\noindent\includegraphics[width=\linewidth]{images/#1}\bigskip}

%\documentclass{article}
\ifx\UseOption\undefined
%\def\UseOption{opta}
\def\UseOption{manual}
\def\UseOption{program}
\fi
\usepackage{optional}
%\begin{document}
%\begin{itemize}
%\opt{opta}{\item First item}
%\opt{optb}{\item Second item}
%\end{itemize}
%\end{document}

\usepackage{iftex,luamplib}

%\usepackage{luamplib}
%\usepackage{graphicx}
\mplibtextextlabel{enable}

\usepackage{etoc}

\begin{document}
%
%\begin{mplibcode}
%    beginfig(1);
%        a := 2cm;
%        draw fullcircle scaled a ; 
%    endfig ;
%\end{mplibcode}
%

%\DoNotIndex{\bullet}

%## Version History (see pygcpversion below)

%\changes{v0.93}{2025/11/30}{Initial implementation of 3D printing.}
\def\fileversion{v0.93} \def\filedate{2025/11/30}

%\changes{v0.92}{2025/11/11}{Remove multiple DXFs and unimplemented features, add hooks for 3D printing.}
%\def\fileversion{v0.92} \def\filedate{2025/11/11}

%\changes{v0.91}{2025/10/31}{Finish converting to native OpenPythonSCAD trigonometric functions.}
%\def\fileversion{v0.91} \def\filedate{2025/10/31}

%\changes{v0.9}{2025/07/4}{Re-write to use Python lists to hold 3D shapes so as to avoid the need for nested unions}
%\def\fileversion{v0.9} \def\filedate{2025/07/4}

%\changes{v0.802}{2025/02/14}{Add support for tapered ball-nose and flat-bottomed V tools}
%\def\fileversion{v0.802} \def\filedate{2025/02/14}

%\changes{v0.801}{2025/01/29}{Add support for bowl bits}
%\def\fileversion{v0.801} \def\filedate{2025/01/29}

%\changes{v0.8}{2025/01/29}{Re-write in Python and OpenSCAD}
%\def\fileversion{v0.8} \def\filedate{2025/01/29}

%\changes{v0.71}{2024/11/11}{Restore G2/G3 arcs, roundover tooling}
%\def\fileversion{v0.71} \def\filedate{2024/11/29}

%\changes{v0.7}{2024/11/11}{Python re-write}
%\def\fileversion{v0.7} \def\filedate{2024/11/11}

%\changes{v0.61}{2024/09/08}{modules and tests}
%\def\fileversion{v0.61} \def\filedate{2024/09/08}

%\changes{v0.6}{2024/08/30}{modules and setupstock}
%\def\fileversion{v0.6} \def\filedate{2024/08/30}

%\changes{v0.5}{2024/08/10}{DXFs and images}
%\def\fileversion{v0.5} \def\filedate{2024/08/10}

%\changes{v0.4}{2024/07/28}{Literary re-write}
%\def\fileversion{v0.4} \def\filedate{2024/07/28}

%\changes{v0.3}{2024/07/01}{Curves and roundover tooling}
%\def\fileversion{v0.3} \def\filedate{2024/07/01}

%\changes{v0.2}{2024/04/12}{Initial conversion to DTX}
%\def\dtxfile{gcodepreview.dtx}

\title{The gcodepreview PythonSCAD library\thanks{This
        file (\texttt{\jobname}) has version number \fileversion, last revised
        \filedate.}}

\author{%
Author: William F. Adams\\
\texttt{willadams at aol dot com}
}
\date{\filedate}
\maketitle
\begin{abstract}
\noindent The gcodepreview library allows using PythonSCAD (Python in OpenSCAD) to move a tool in lines and arcs and output \textsc{dxf} and G-code files so as to work as a \textsc{cad}/\allowbreak \textsc{cam} program for \textsc{cnc}.
\end{abstract}
\enlargethispage{3\baselineskip}

\setcounter{tocdepth}{3}

\tableofcontents

\clearpage

\setcounter{tocdepth}{5}

\tableofcontents

\clearpage
\section{readme.md}

\begin{readme}
# gcodepreview

OpenPythonSCAD library for moving a tool in lines and arcs so as to model how a part would be cut or extruded using G-Code, so as to allow use as a compleat CAD/CAM solution for subtractive or additive 3-axis CNC (4th-axis support may come in a future version) by writing out G-code in addition to 3D modeling (in certain cases toolpaths which would not normally be feasible in typical tools), and to write out DXF files which may be imported into a traditional CAM program to create toolpaths. 

![OpenSCAD gcodepreview Unit Tests](https://raw.githubusercontent.com/WillAdams/gcodepreview/main/gcodepreviewtemplate.png?raw=true)

Uses Python in OpenSCAD: https://pythonscad.org/[^pythonscad]

[^pythonscad]: Previously this was http://www.guenther-sohler.net/openscad/ 

A BlockSCAD file for the initial version of the 
main modules is available at:

https://www.blockscad3d.com/community/projects/1244473

The project is discussed at:

https://willadams.gitbook.io/design-into-3d/programming

Since it is now programmed using Literate Programming (initially a .dtx, now a .tex file) there is a PDF: https://github.com/WillAdams/gcodepreview/blob/main/gcodepreview.pdf which includes all of the source code with commentary.

The files for this library are:

 - gcodepreview.py (gcpy) --- the Python class/functions and variables
 - gcodepreview.scad (gcpscad) --- OpenSCAD modules and parameters

And there several sample/template files which may be used as the starting point for a given project:

 - gcodepreviewtemplate.txt (gcptmpl) --- .txt file collecting all commands with brief comments which may be used as a quick reference or copy-pasting from
 - gcodepreviewtemplate.py (gcptmplpy) --- .py example file 
 - gcodepreviewtemplate.scad (gcptmplscad) --- .scad example file
 - gcpdxf.py (gcpdxfpy) --- .py example file which only makes dxf file(s) and which will run in "normal" Python in addition to PythonSCAD
 - gcpgc.py (gcpgc) --- .py example which loads a G-code file and generates a 3D preview showing how the G-code will cut

Note that additional templates are in: https://github.com/WillAdams/gcodepreview/tree/main/templates

If using from PythonSCAD, place the files in C:\Users\\\~\Documents\OpenSCAD\libraries or, load them from Github using the command:

    nimport("https://raw.githubusercontent.com/WillAdams/gcodepreview/refs/heads/main/gcodepreview.py")

If using gcodepreview.scad call as:

    use <gcodepreview.py>
    include <gcodepreview.scad>

Note that it is necessary to use the first file (this allows loading the Python commands and then include the last file (which allows using OpenSCAD variables to selectively implement the Python commands via their being wrapped in OpenSCAD modules) and define variables which match the project and then use commands such as:

    opengcodefile(Gcode_filename);
    opendxffile(DXF_filename);
    
    gcp = gcodepreview("cut", true, true);

    setupstock(219, 150, 8.35, "Top", "Center");
    
    movetosafeZ();
    
    toolchange(102, 17000);
    
    cutline(219/2, 150/2, -8.35);

    stockandtoolpaths();
    
    closegcodefile();
    closedxffile();

which makes a G-code file:

![OpenSCAD template G-code file](https://raw.githubusercontent.com/WillAdams/gcodepreview/main/gcodepreview_template.png?raw=true)

but one which could only be sent to a machine so as to cut only the softest and most yielding of materials since it makes a single full-depth pass, and which has a matching DXF which may be imported into a CAM tool --- but which it is not directly possible to assign a toolpath in readily available CAM tools (since it varies in depth from beginning-to-end which is not included in the DXF since few tools make use of that information). 

Importing this DXF and actually cutting it is discussed at:

https://forum.makerforums.info/t/rewriting-gcodepreview-with-python/88617/14

Alternately, gcodepreview.py may be placed in a Python library location and used directly from Python to generate DXFs as shown in gcpdxf.py (generating a 3D preview requires OpenPythonSCAD and generating G-code without a preview is not supported).

In the current version, tool numbers may match those of tooling sold by Carbide 3D (ob. discl., I work for them) and other vendors, or, a vendor-neutral system may be worked up and used as desired. 

Comments are included in the G-code to match those expected by CutViewer, allowing a direct preview without the need to maintain a tool library (for such tooling as that program supports).

Supporting OpenSCAD usage makes possible such examples as: openscad_gcodepreview_cutjoinery.tres.scad which is made from an OpenSCAD Graph Editor file:

![OpenSCAD Graph Editor Cut Joinery File](https://raw.githubusercontent.com/WillAdams/gcodepreview/main/OSGE_cutjoinery.png?raw=true)

| Version       | Notes         |
| ------------- | ------------- |
| 0.1           | Version  supports setting up stock, origin, rapid positioning, making cuts, and writing out matching G-code, and creating a DXF with polylines.                                 |
|               |  - separate dxf files are written out for each tool where tool is ball/square/V and small/large (10/31/23)                                                                      |
|               |  - re-writing as a Literate Program using the LaTeX package docmfp (begun 4/12/24)                                                                                              |
|               |  - support for additional tooling shapes such as dovetail and keyhole tools                                                                                                     |
| 0.2           | Adds support for arcs, specialty toolpaths such as Keyhole which may be used for dovetail as well as keyhole cutters                                                            |
| 0.3           | Support for curves along the 3rd dimension, roundover tooling                                                                                                                   |
| 0.4           | Rewrite using literati documentclass, suppression of SVG code, dxfrectangle                                                                                                     |
| 0.5           | More shapes, consolidate rectangles, arcs, and circles in gcodepreview.scad                                                                                                     |
| 0.6           | Notes on modules, change file for setupstock                                                                                                                                    |
| 0.61          | Validate all code so that it runs without errors from sample (NEW: Note that this version is archived as gcodepreview-openscad_0_6.tex and the matching PDF is available as well|
| 0.7           | Re-write completely in Python                                                                                                                                                   |
| 0.8           | Re-re-write completely in Python and OpenSCAD, iteratively testing                                                                                                              |
| 0.801         | Add support for bowl bits with flat bottom                                                                                                                                      |
| 0.802         | Add support for tapered ball-nose and  V tools with flat bottom                                                                                                                 |
| 0.803         | Implement initial color support and joinery modules (dovetail and full blind box joint modules)                                                                                 |
| 0.9           | Re-write to use Python lists for 3D shapes for toolpaths and rapids.                                                                                                            |
| 0.91          | Finish converting to native OpenPythonSCAD trigonometric functions.                                                                                                             |
| 0.92          | Remove multiple DXFs and unimplemented features, add hooks for 3D printing.                                                                                                     |
| 0.93          | Initial support for 3D printing.                                                                                                                                                |

Possible future improvements:

 - support for 4th-axis
 - support for post-processors
 - support for two-sided machining (import an STL or other file to use for stock, or possibly preserve the state after one cut and then rotate the cut stock/part)
 - support for additional tooling shapes (lollipop cutters)
 - create a single line font for use where text is wanted
 - Support for METAPOST and Bézier curves (latter required for fonts if not to be limited to lines and arcs) and surfaces

Note for G-code generation that it is up to the user to implement Depth per Pass so as to not take a single full-depth pass as noted above. Working from a DXF of course allows one to off-load such considerations to a specialized CAM tool.

To-do:

 - implement skin()
 - determine why one quadrant of arc command doesn't work in OpenSCAD
 - clock-wise arcs
 - add toolpath for cutting countersinks using ball-nose tool from inside working out
 - verify OpenSCAD wrapper and add any missing commands for Python
 - verify support for shaft on tooling
 - create additional template and sample files
 - fully implement/verify describing/saving/loading tools using CutViewer comments

Deprecated features:

 - exporting SVGs --- coordinate system differences between OpenSCAD/DXFs and SVGs would require managing the inversion of the coordinate system (using METAPOST, which shares the same orientation and which can write out SVGs may be used for future versions)
 - using linear/rotate_extrude --- 2D geometry is rotated to match the arc of the movement, which is appropriate to a 5-axis machine, but not workable for a 3-axis. Adding an option to support the use of such commands for horizontal movement is within the realm of possibility.
 - multiple DXF files
 - RapCAD support

\end{readme}

%[^rapcad]
%
%[^rapcad]: Previous versions had used RapCAD, so as to take advantage of the writeln command, which has since been re-written in Python.

%[^libraries]: C:\Users\\\~\Documents\RapCAD\libraries is deprecated since RapCAD is no longer needed since Python is now used for writing out files.

% - pygcodepreview.scad (pyscad) --- the Python functions wrapped in OpenSCAD (deprecated)
% - cut2Dshapes.scad (cut2D) --- code for cutting 2D shapes 

%\textsf{\markdownInput{readme.md}}

\clearpage

\section{Usage and Templates}

The gcodepreview library allows the modeling of \textsc{2d} geometry and \textsc{3d} shapes using Python or by calling Python from within Open(Python)SCAD, enabling the creation of \textsc{2d} \textsc{dxf}s, G-code (which cuts a \textsc{2d} or \textsc{3d} part), or \textsc{3d}~models as a preview of how the file will cut. These abilities may be accessed in ``plain'' Python (to make \textsc{dxf}s), or Python or OpenSCAD in PythonSCAD (to make \textsc{dxf}s, and/or G-code with \textsc{3d}~modeling) for a preview. Providing them in a programmatic context allows making parts or design elements of parts (\emph{e.g.}, joinery) which would be tedious or difficult (or verging on impossible) to draw by hand in a traditional CAD or vector drawing application. A further consideration is that this is ``Design for Manufacture'' taken to its ultimate extreme, and that a part so designed is inherently manufacturable (so long as the dimensions and radii allows for reasonable tool (and toolpath) geometries).

The various commands are shown all together in templates so as to provide examples of usage, and to ensure that the various files are used/included as necessary, all variables are set up with the correct names (note that the sparse template in \verb|readme.md| eschews variables), and that if enabled, files are opened before being written to, and that each is closed at the end in the correct order. Note that while the template files seem overly verbose, they specifically incorporate variables for each tool shape, possibly in two different sizes, and a feed rate parameter or ratio for each, which may be used (by setting a tool \#) or ignored (by leaving the variable for a given tool at zero (0)). 

It should be that the readme at the project page which serves as an overview, and this section (which serves as a collection of templates and a tutorial) are all the documentation which most users will need (and arguably is still too much). The balance of the document after this section shows all the code and implementation details, and will where appropriate show examples of usage which will be collected in a plain text template file which is concatenated to provide a usable example of each command with (brief) commentary (potentially serving as a how-to guide as well as documenting the code in a minimalistic fashion) as well as Indices (which serve as a front-end for reference).

\includeimage{panorama.pdf}

Some comments on the templates:

\begin{itemize}
\item minimal --- each is intended as a framework for a minimal working example (\textsc{mwe}) --- it should be possible to comment out unused/unneeded portions and so arrive at code which tests any aspect of this project and which may be used as a starting point for a new part/project
\item compleat --- a quite wide variety of tools are listed (and probably more will be added in the future), but pre-defining them and having these ``hooks'' seems the easiest mechanism to handle the requirements of subtractive machining. 
%                   (non-object-oriented) 
%                   Arguably, the architecture needs to be re-worked so that tool \#s are
%                   optional.
\item shortcuts --- as the various examples show, while in real life it is necessary to 
                    make many passes with a tool, an expedient efficiency is to forgo the 
                    \verb|loop| operation and just use a \verb|hull()| operation and avoid the requirement of implementing 
                    Depth per Pass (but note that this will lose the previewing of scalloped tool 
                    marks in places where they might appear otherwise)
\end{itemize}

One fundamental aspect of this tool is the question of \emph{Layers of Abstraction} (as put forward by Dr. Donald Knuth as the crux of computer science) and \emph{Problem Decomposition} (Prof. John Ousterhout's answer to that question). To a great degree, the basic implementation of this tool will use G-code as a reference implementation, simultaneously using the abstraction from the mechanical task of machining which it affords as a decomposed version of that task, and creating what is in essence, both a front-end, and a tool, and an \textsc{api} for working with G-code programmatically. This then requires an architecture which allows \textsc{3d} modeling (OpenSCAD), and writing out files (Python).

Further features will be added to the templates as they are created, and the main image updated to reflect the capabilities of the system.

%Creating a template from memory, the file should be something like:
%
%List of all tools
%chipload for each tool
%Depth per Pass for each tool
%scaling factor for chipload to arrive at feeds and speeds
%Booleans for generateDXF/Gcode, 3D Preview, assembly or parts or drop-down list of parts, &c.
%
%setupstock --- should this open gcode/dxf files as well?
%
%toolchange to first tool
%
%Rapid to location of first cut
%cutline/cutarc --- iterate as needed
%Rapid to safe height
%
%Program END --- should close gcode/DXF files and include rapid to safe height and rapid to back

\subsection{gcpdxf.py}

The most basic usage, with the fewest dependencies is to use ``plain'' Python to create \verb|dxf| files. Note that this example includes an optional command \verb|nimport(<URL>)| which if enabled/uncommented (and the following line commented out), will allow one to use OpenPythonSCAD to import the library from Github, sidestepping the need to download and install the library into an installation of OpenPythonSCAD locally. Usage in  ``normal'' Python will require manually installing the \verb|gcodepreview.py| file where Python can find it. A further consideration is where the file will be placed if the full path is not enumerated, the Desktop is the default destination for Microsoft Windows.

\lstset{firstnumber=1}%\thegcpdxf}
\begin{writecode}{w}{gcpdxf.py}{python}
from openscad import *
	# nimport("https://raw.githubusercontent.com/WillAdams/gcodepreview/refs/heads/main/gcodepreview.py")
from gcodepreview import *

gcp = gcodepreview("no_preview", # "cut" or "print"
                   False, # generategcode
                   True   # generatedxf
                   )

# [Stock] */
stockXwidth = 100
# [Stock] */
stockYheight = 50

# [Export] */
Base_filename = "gcpdxf"


# [CAM] */
large_square_tool_num = 102
# [CAM] */
small_square_tool_num = 0
# [CAM] */
large_ball_tool_num = 0
# [CAM] */
small_ball_tool_num = 0
# [CAM] */
large_V_tool_num = 0
# [CAM] */
small_V_tool_num = 0
# [CAM] */
DT_tool_num = 374
# [CAM] */
KH_tool_num = 0
# [CAM] */
Roundover_tool_num = 0
# [CAM] */
MISC_tool_num = 0

# [Design] */
inset = 3
# [Design] */
radius = 6
# [Design] */
cornerstyle = "Fillet"  # "Chamfer", "Flipped Fillet"

gcp.opendxffile(Base_filename)

gcp.dxfrectangle(large_square_tool_num, 0, 0, stockXwidth, stockYheight)

gcp.setdxfcolor("Red")

gcp.dxfarc(large_square_tool_num, inset, inset, radius,  0, 90)
gcp.dxfarc(large_square_tool_num, stockXwidth - inset, inset, radius, 90, 180)
gcp.dxfarc(large_square_tool_num, stockXwidth - inset, stockYheight - inset, radius, 180, 270)
gcp.dxfarc(large_square_tool_num, inset, stockYheight - inset, radius, 270, 360)

gcp.dxfline(large_square_tool_num, inset, inset + radius, inset, stockYheight - (inset + radius))
gcp.dxfline(large_square_tool_num, inset + radius, inset, stockXwidth - (inset + radius), inset)
gcp.dxfline(large_square_tool_num, stockXwidth - inset, inset + radius, stockXwidth - inset, stockYheight - (inset + radius))
gcp.dxfline(large_square_tool_num, inset + radius, stockYheight-inset, stockXwidth - (inset + radius), stockYheight - inset)

gcp.setdxfcolor("Blue")

gcp.dxfrectangle(large_square_tool_num, radius +inset, radius, stockXwidth/2 - (radius * 4), stockYheight - (radius * 2), cornerstyle, radius)
gcp.dxfrectangle(large_square_tool_num, stockXwidth/2 + (radius * 2) + inset, radius, stockXwidth/2 - (radius * 4), stockYheight - (radius * 2), cornerstyle, radius)

gcp.setdxfcolor("Black")

gcp.beginpolyline(large_square_tool_num)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius*1.5,stockYheight/4-radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius,stockYheight/4-radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius,stockYheight*0.75+radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius*1.5,stockYheight*0.75+radius/2)
gcp.closepolyline(large_square_tool_num)

gcp.dxfarc(large_square_tool_num, stockXwidth*0.75+radius*1.5, stockYheight*0.75, radius/2,  0, 90)

gcp.beginpolyline(large_square_tool_num)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius*2,stockYheight*0.75)
gcp.addvertex(large_square_tool_num, stockXwidth*0.75+radius*2,stockYheight/4)
gcp.closepolyline(large_square_tool_num)

gcp.dxfarc(large_square_tool_num, stockXwidth*0.75+radius*1.5, stockYheight/4, radius/2,  270, 360)

gcp.setdxfcolor("White")

gcp.beginpolyline(large_square_tool_num)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius*1.5,stockYheight/4-radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius,stockYheight/4-radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius,stockYheight*0.75+radius/2)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius*1.5,stockYheight*0.75+radius/2)
gcp.closepolyline(large_square_tool_num)

gcp.dxfarc(large_square_tool_num, stockXwidth*0.25-radius*1.5, stockYheight*0.75, radius/2,  90, 180)

gcp.beginpolyline(large_square_tool_num)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius*2,stockYheight*0.75)
gcp.addvertex(large_square_tool_num, stockXwidth*0.25-radius*2,stockYheight/4)
gcp.closepolyline(large_square_tool_num)

gcp.dxfarc(large_square_tool_num, stockXwidth*0.25-radius*1.5, stockYheight/4, radius/2,  180, 270)

gcp.setdxfcolor("Yellow")
gcp.dxfcircle(large_square_tool_num, stockXwidth/4+1+radius/2, stockYheight/4, radius/2)

gcp.setdxfcolor("Green")
gcp.dxfcircle(large_square_tool_num, stockXwidth*0.75-(1+radius/2), stockYheight*0.75, radius/2)

gcp.setdxfcolor("Cyan")
gcp.dxfcircle(large_square_tool_num, stockXwidth/4+1+radius/2, stockYheight*0.75, radius/2)

gcp.setdxfcolor("Magenta")
gcp.dxfcircle(large_square_tool_num, stockXwidth*0.75-(1+radius/2), stockYheight/4, radius/2)

gcp.setdxfcolor("Dark Gray")

gcp.dxfcircle(large_square_tool_num, stockXwidth/2, stockYheight/2, radius * 2)

gcp.setdxfcolor("Light Gray")

gcp.dxfKH(374, stockXwidth/2, stockYheight/5*3, 0, -7, 270, 11.5875)

gcp.closedxffile()

\end{writecode}
\addtocounter{gcpdxfpy}{124}

\noindent which creates a \verb|.dxf| file which may be imported into any \textsc{cad} program:

\bigskip

\includeimage{gcpdxf.png}

\bigskip


\noindent with the appearance (once converted into a \verb|.svg| and then re-saved as a \verb|.pdf| and edited so as to show the white elements):

\bigskip

\includeimage{gcpdxf.pdf}

\bigskip

\noindent and which may be imported into pretty much any \textsc{cad} or \textsc{cam} application, e.g., Carbide Create:

\bigskip

\includeimage{gcpdxf_carbidecreate_v9.png}

\bigskip

As shown/implied by the above code, the following commands/shapes are implemented:

\begin{itemize}
\item \verb|dxfrectangle| (specify lower-left corner location and width (X)/height(Y))
\subitem\verb|dxfrectangleround| (specified as ``Fillet'' and radius for the round option)
\subitem\verb|dxfrectanglechamfer| (specified as ``Chamfer'' and radius for the round option)
\subitem\verb|dxfrectangleflippedfillet| (specified as ``Flipped Fillet'' and radius for the option)
\item \verb|dxfcircle| (specifying their center and radius)
\item \verb|dxfline| (specifying begin/end points)
\item \verb|dxfarc| (specifying arc center, radius, and beginning/ending angles)
\item \verb|dxfKH| (specifying origin, depth, angle, distance)
 \end{itemize}

%\noindent It may be that more shapes/commands will be implemented (supporting the full range of corner options for Carbide Create seems a likely thing). Rewriting \verb|dxfrectangle| to accept optional arguments for corner treatment/dimension seems obvious after-the-fact.

\subsection{gcpcutdxf.py}

A notable limitation of the above is that there is no interactivity --- the \verb|.dxf| file is generated, then must be opened and the result of the run checked (if there is a \textsc{dxf} viewer/editor which will live-reload the file based on it being updated that would be obviated). Reworking the commands for a simplified version of the above design so as to show a \textsc{3d} model in OpenPythonSCAD is a straight-forward task:

\lstset{firstnumber=1}%\thegcpcutdxf}
\begin{writecode}{w}{gcpcutdxf.py}{python}
from openscad import *
# nimport("https://raw.githubusercontent.com/WillAdams/gcodepreview/refs/heads/main/gcodepreview.py")
from gcodepreview import *

fa = 2
fs = 0.125

gcp = gcodepreview("cut", # "print" or "no_preview"
                   False, # generategcode
                   True   # generatedxf
                   )

# [Stock] */
stockXwidth = 100
# [Stock] */
stockYheight = 50
# [Stock] */
stockZthickness = 3.175
# [Stock] */
zeroheight = "Top"  # [Top, Bottom]
# [Stock] */
stockzero = "Lower-Left"  # [Lower-Left, Center-Left, Top-Left, Center]
# [Stock] */
retractheight = 3.175

# [Export] */
Base_filename = "gcpdxf"


# [CAM] */
large_square_tool_num = 112
# [CAM] */
small_square_tool_num = 0
# [CAM] */
large_ball_tool_num = 111
# [CAM] */
small_ball_tool_num = 0
# [CAM] */
large_V_tool_num = 0
# [CAM] */
small_V_tool_num = 0
# [CAM] */
DT_tool_num = 374
# [CAM] */
KH_tool_num = 0
# [CAM] */
Roundover_tool_num = 0
# [CAM] */
MISC_tool_num = 0

# [Design] */
inset = 3
# [Design] */
radius = 6
# [Design] */
cornerstyle = "Fillet"  # "Chamfer", "Flipped Fillet"

gcp.opendxffile(Base_filename)

gcp.setupstock(stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero, retractheight)

gcp.toolchange(large_square_tool_num)

gcp.setdxfcolor("Red")

gcp.cutrectangledxf(large_square_tool_num, 0, 0, 0, stockXwidth, stockYheight, stockZthickness)

gcp.toolchange(large_ball_tool_num)

gcp.setdxfcolor("Gray")

gcp.rapid(inset + radius, inset, 0, "laser")

gcp.cutlinedxf(inset + radius, inset, -stockZthickness/2)
gcp.cutquarterCCNEdxf(inset, inset + radius, -stockZthickness/2, radius)

gcp.cutlinedxf(inset, stockYheight - (inset + radius), -stockZthickness/2)

gcp.cutquarterCCSEdxf(inset + radius, stockYheight - inset, -stockZthickness/2, radius)

gcp.cutlinedxf(stockXwidth - (inset + radius), stockYheight - inset, -stockZthickness/2)

gcp.cutquarterCCSWdxf(stockXwidth - inset, stockYheight - (inset + radius), -stockZthickness/2, radius)

gcp.cutlinedxf(stockXwidth - (inset), (inset + radius), -stockZthickness/2)

gcp.cutquarterCCNWdxf(stockXwidth - (inset + radius), inset, -stockZthickness/2, radius)

gcp.cutlinedxf((inset + radius), inset, -stockZthickness/2)

gcp.setdxfcolor("Blue")

gcp.rapid(radius + inset + radius, radius, 0, "laser")

gcp.cutrectanglerounddxf(large_square_tool_num, radius +inset, radius, 0, stockXwidth/2 - (radius * 4), stockYheight - (radius * 2), -stockZthickness/4, radius)

gcp.rapid(stockXwidth/2 + (radius * 2) + inset + radius, radius, 0, "laser")

gcp.cutrectanglerounddxf(large_square_tool_num, stockXwidth/2 + (radius * 2) + inset, radius, 0, stockXwidth/2 - (radius * 4), stockYheight - (radius * 2), -stockZthickness/4, radius)

gcp.setdxfcolor("Red")

gcp.rapid(stockXwidth/2 + radius, stockYheight/2, 0, "laser")

gcp.toolchange(large_square_tool_num)

gcp.cutcircleCC(stockXwidth/2, stockYheight/2, 0, -stockZthickness, radius)

gcp.cutcircleCC(stockXwidth/2, stockYheight/2, -stockZthickness, -stockZthickness, radius*1.5)

gcp.closedxffile()

gcp.stockandtoolpaths()

\end{writecode}
%\addtocounter{gcpcutdxfpy}{113}

\noindent which creates the design:

\includeimage{gcpcutdxf.png}

\noindent and which allows an interactive usage in working up a design such as for lasercutting, and which incorporates an option to the \verb|rapid(x,y,z)| command which simulates turning a laser off, repositioning, then powering up the laser to resume cutting at the new position.

%Note that the lines referencing multiple files (\verb|open/closedxffiles|) may be uncommented if the project wants separate \verb|dxf| files for different tools, however the ability to color-code has essentially obviated the need for that.

\subsection{gcodepreviewtemplate.py}
           
Note that since the v0.7 re-write, it is possible to directly use the underlying Python code. Using Python to generate \textsc{3d} previews of how \textsc{dxf}s or G-code will cut requires the use of PythonSCAD.

%TODO REVIEW ALL TOOLS IN TEMPLATE

\lstset{firstnumber=1}%\thegcptmplpy}
\begin{writecode}{w}{gcodepreviewtemplate.py}{python}
#!/usr/bin/env python

import sys

try:
    if 'gcodepreview' in sys.modules:
        del sys.modules['gcodepreview']
except AttributeError:
    pass

from gcodepreview import *

fa = 2
fs = 0.125

# [Export] */
Base_filename = "aexport"
# [Export] */
generatedxf = True
# [Export] */
generategcode = True

# [Stock] */
stockXwidth = 220
# [Stock] */
stockYheight = 150
# [Stock] */
stockZthickness = 8.35
# [Stock] */
zeroheight = "Top"  # [Top, Bottom]
# [Stock] */
stockzero = "Center"  # [Lower-Left, Center-Left, Top-Left, Center]
# [Stock] */
retractheight = 9

# [CAM] */
toolradius = 1.5875
# [CAM] */
large_square_tool_num = 201  # [0:0, 112:112, 102:102, 201:201]
# [CAM] */
small_square_tool_num = 102  # [0:0, 122:122, 112:112, 102:102]
# [CAM] */
large_ball_tool_num = 202  # [0:0, 111:111, 101:101, 202:202]
# [CAM] */
small_ball_tool_num = 101  # [0:0, 121:121, 111:111, 101:101]
# [CAM] */
large_V_tool_num = 301  # [0:0, 301:301, 690:690]
# [CAM] */
small_V_tool_num = 390  # [0:0, 390:390, 301:301]
# [CAM] */
DT_tool_num = 814  # [0:0, 814:814, 808079:808079]
# [CAM] */
KH_tool_num = 374  # [0:0, 374:374, 375:375, 376:376, 378:378]
# [CAM] */
Roundover_tool_num = 56142  # [56142:56142, 56125:56125, 1570:1570]
# [CAM] */
MISC_tool_num = 0  # [501:501, 502:502, 45982:45982]
#501 https://shop.carbide3d.com/collections/cutters/products/501-engraving-bit
#502 https://shop.carbide3d.com/collections/cutters/products/502-engraving-bit
#204 tapered ball nose 0.0625", 0.2500", 1.50", 3.6°
#304 tapered ball nose 0.1250", 0.2500", 1.50", 2.4°
#648 threadmill_shaft(2.4, 0.75, 18)
#45982 Carbide Tipped Bowl & Tray 1/4 Radius x 3/4 Dia x 5/8 x 1/4 Inch Shank
#13921 https://www.amazon.com/Yonico-Groove-Bottom-Router-Degree/dp/B0CPJPTMPP

# [Feeds and Speeds] */
plunge = 100
# [Feeds and Speeds] */
feed = 400
# [Feeds and Speeds] */
speed = 16000
# [Feeds and Speeds] */
small_square_ratio = 0.75  # [0.25:2]
# [Feeds and Speeds] */
large_ball_ratio = 1.0  # [0.25:2]
# [Feeds and Speeds] */
small_ball_ratio = 0.75  # [0.25:2]
# [Feeds and Speeds] */
large_V_ratio = 0.875  # [0.25:2]
# [Feeds and Speeds] */
small_V_ratio = 0.625  # [0.25:2]
# [Feeds and Speeds] */
DT_ratio = 0.75  # [0.25:2]
# [Feeds and Speeds] */
KH_ratio = 0.75  # [0.25:2]
# [Feeds and Speeds] */
RO_ratio = 0.5  # [0.25:2]
# [Feeds and Speeds] */
MISC_ratio = 0.5  # [0.25:2]

# Note that the various ratios are simply declared as a possible hook
# which might be useful and how are handled is left as an exercise 
# for the reader and that they are not applied below.
# One naive option might be to multiply by the feed rate 
# and divide by speeds.

gcp = gcodepreview("cut", # "print" or "no_preview"
                   generategcode,
                   generatedxf,
                   )

gcp.opengcodefile(Base_filename)
gcp.opendxffile(Base_filename)

gcp.setupstock(stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero, retractheight)

gcp.movetosafeZ()

gcp.toolchange(102, 10000 * small_square_ratio)

gcp.rapidZ(0)

gcp.cutlinedxfgc(stockXwidth/2, stockYheight/2, -stockZthickness)

gcp.rapidZ(retractheight)
gcp.toolchange(201, 10000)
gcp.rapidXY(0, stockYheight/16)
gcp.rapidZ(0)
gcp.cutlinedxfgc(stockXwidth/16*7, stockYheight/2, -stockZthickness)

gcp.rapidZ(retractheight)
gcp.toolchange(202, 10000)
gcp.rapidXY(0, stockYheight/8)
gcp.rapidZ(0)
gcp.cutlinedxfgc(stockXwidth/16*6, stockYheight/2, -stockZthickness)

gcp.rapidZ(retractheight)
gcp.toolchange(101, 10000)
gcp.rapidXY(0, stockYheight/16*3)
gcp.rapidZ(0)
gcp.cutlinedxfgc(stockXwidth/16*5, stockYheight/2, -stockZthickness)

gcp.setzpos(retractheight)
gcp.toolchange(390, 10000)
gcp.rapidXY(0, stockYheight/16*4)
gcp.rapidZ(0)
gcp.cutlinedxfgc(stockXwidth/16*4, stockYheight/2, -stockZthickness)
gcp.rapidZ(retractheight)

gcp.toolchange(301, 10000)
gcp.rapidXY(0, stockYheight/16*6)
gcp.rapidZ(0)
gcp.cutlinedxfgc(stockXwidth/16*2, stockYheight/2, -stockZthickness)

rapids = gcp.rapid(gcp.xpos(), gcp.ypos(), retractheight)
gcp.toolchange(102, 10000)

gcp.rapid(-stockXwidth/4+stockYheight/16, +stockYheight/4, 0)

#gcp.cutarcCC(0, 90, gcp.xpos()-stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4)
#gcp.cutarcCC(90, 180, gcp.xpos(), gcp.ypos()-stockYheight/16, stockYheight/16, -stockZthickness/4)
#gcp.cutarcCC(180, 270, gcp.xpos()+stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4)
#gcp.cutarcCC(270, 360, gcp.xpos(), gcp.ypos()+stockYheight/16, stockYheight/16, -stockZthickness/4)
gcp.cutquarterCCNEdxf(gcp.xpos() - stockYheight/8, gcp.ypos() + stockYheight/8, -stockZthickness/4, stockYheight/8)
gcp.cutquarterCCNWdxf(gcp.xpos() - stockYheight/8, gcp.ypos() - stockYheight/8, -stockZthickness/2, stockYheight/8)
gcp.cutquarterCCSWdxf(gcp.xpos() + stockYheight/8, gcp.ypos() - stockYheight/8, -stockZthickness * 0.75, stockYheight/8)
gcp.cutquarterCCSEdxf(gcp.xpos() + stockYheight/8, gcp.ypos() + stockYheight/8, -stockZthickness, stockYheight/8)

gcp.movetosafeZ()
gcp.rapidXY(stockXwidth/4-stockYheight/16, -stockYheight/4)
gcp.rapidZ(0)


#gcp.cutarcCW(180, 90, gcp.xpos()+stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4)
#gcp.cutarcCW(90, 0, gcp.xpos(), gcp.ypos()-stockYheight/16, stockYheight/16, -stockZthickness/4)
#gcp.cutarcCW(360, 270, gcp.xpos()-stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4)
#gcp.cutarcCW(270, 180, gcp.xpos(), gcp.ypos()+stockYheight/16, stockYheight/16, -stockZthickness/4)

#gcp.movetosafeZ()
#gcp.toolchange(201, 10000)
#gcp.rapidXY(stockXwidth/2, -stockYheight/2)
#gcp.rapidZ(0)

#gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos(), -stockZthickness)
#test = gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos(), -stockZthickness)

#gcp.movetosafeZ()
#gcp.rapidXY(stockXwidth/2-6.34, -stockYheight/2)
#gcp.rapidZ(0)

#gcp.cutarcCW(180, 90, stockXwidth/2, -stockYheight/2, 6.34, -stockZthickness)


gcp.movetosafeZ()
gcp.toolchange(814, 10000)
gcp.rapidXY(0, -(stockYheight/2+12.7))
gcp.rapidZ(0)

gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos(), -stockZthickness)
gcp.cutlinedxfgc(gcp.xpos(), -12.7, -stockZthickness)

gcp.rapidXY(0, -(stockYheight/2+12.7))
gcp.movetosafeZ()
gcp.toolchange(374, 10000)
gcp.rapidXY(stockXwidth/4-stockXwidth/16, -(stockYheight/4+stockYheight/16))
gcp.rapidZ(0)

gcp.rapidZ(retractheight)
gcp.toolchange(374, 10000)
gcp.rapidXY(-stockXwidth/4-stockXwidth/16, -(stockYheight/4+stockYheight/16))
gcp.rapidZ(0)

gcp.cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2)
gcp.cutlinedxfgc(gcp.xpos()+stockYheight/9, gcp.ypos(), gcp.zpos())

gcp.cutline(gcp.xpos()-stockYheight/9, gcp.ypos(), gcp.zpos())
gcp.cutline(gcp.xpos(), gcp.ypos(), 0)

#key = gcp.cutkeyholegcdxf(KH_tool_num, 0, stockZthickness*0.75, "E", stockYheight/9)
#key = gcp.cutKHgcdxf(374, 0, stockZthickness*0.75, 90, stockYheight/9)
#toolpaths = toolpaths.union(key)

gcp.rapidZ(retractheight)
gcp.rapidXY(-stockXwidth/4+stockXwidth/16, -(stockYheight/4+stockYheight/16))
gcp.rapidZ(0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2)
gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos()+stockYheight/9, gcp.zpos())

gcp.cutline(gcp.xpos(), gcp.ypos()-stockYheight/9, gcp.zpos())
gcp.cutline(gcp.xpos(), gcp.ypos(), 0)

gcp.rapidZ(retractheight)
gcp.rapidXY(-stockXwidth/4+stockXwidth/16, -(stockYheight/4-stockYheight/8))
gcp.rapidZ(0)

gcp.cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2)
gcp.cutlinedxfgc(gcp.xpos()-stockYheight/9, gcp.ypos(), gcp.zpos())

gcp.cutline(gcp.xpos()+stockYheight/9, gcp.ypos(), gcp.zpos())
gcp.cutline(gcp.xpos(), gcp.ypos(), 0)

gcp.rapidZ(retractheight)
gcp.rapidXY(-stockXwidth/4-stockXwidth/16, -(stockYheight/4-stockYheight/8))
gcp.rapidZ(0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2)
gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos()-stockYheight/9, gcp.zpos())
gcp.cutline(gcp.xpos(), gcp.ypos()+stockYheight/9, gcp.zpos())
gcp.cutline(gcp.xpos(), gcp.ypos(), 0)

gcp.rapidZ(retractheight)
gcp.toolchange(56142, 10000)
gcp.rapidXY(-stockXwidth/2, -(stockYheight/2+0.508/2))
gcp.cutline(gcp.xpos(), gcp.ypos(), -1.531)
gcp.cutlinedxfgc(stockXwidth/2+0.508/2, -(stockYheight/2+0.508/2), -1.531)

gcp.rapidZ(retractheight)

gcp.cutline(gcp.xpos(), gcp.ypos(), -1.531)
gcp.cutlinedxfgc(stockXwidth/2+0.508/2, (stockYheight/2+0.508/2), -1.531)

gcp.rapidZ(retractheight)
gcp.toolchange(45982, 10000)
gcp.rapidXY(stockXwidth/8, 0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -(stockZthickness*7/8))
gcp.cutlinedxfgc(gcp.xpos(), -stockYheight/2, -(stockZthickness*7/8))

gcp.rapidZ(retractheight)
gcp.toolchange(204, 10000)
gcp.rapidXY(stockXwidth*0.3125, 0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -(stockZthickness*7/8))
gcp.cutlinedxfgc(gcp.xpos(), -stockYheight/2, -(stockZthickness*7/8))

gcp.rapidZ(retractheight)
gcp.toolchange(502, 10000)
gcp.rapidXY(stockXwidth*0.375, 0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -4.24)
gcp.cutlinedxfgc(gcp.xpos(), -stockYheight/2, -4.24)

gcp.rapidZ(retractheight)
gcp.toolchange(13921, 10000)
gcp.rapidXY(-stockXwidth*0.375, 0)
gcp.cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2)
gcp.cutlinedxfgc(gcp.xpos(), -stockYheight/2, -stockZthickness/2)

gcp.rapidZ(retractheight)

gcp.stockandtoolpaths()

gcp.closegcodefile()
gcp.closedxffile()

\end{writecode}
\addtocounter{gcptmplpy}{285}

%gcp.opendxffiles(Base_filename,
%                 large_square_tool_num,
%                 small_square_tool_num,
%                 large_ball_tool_num,
%                 small_ball_tool_num,
%                 large_V_tool_num,
%                 small_V_tool_num,
%                 DT_tool_num,
%                 KH_tool_num,
%                 Roundover_tool_num,
%                 MISC_tool_num)
%
%gcp.closedxffiles()

\begin{samepage}
\noindent Which generates a \textsc{3d} model which previews in PythonSCAD as:

\bigskip

%\includeimage{gcodepreview_unittests.png}
\includeimage{gcodepreviewtemplate.png}
\end{samepage}

\subsection{gcodepreviewtemplate.scad}

Since the project began in OpenSCAD, having an implementation in that language has always been a goal. This is quite straight-forward since the Python code when imported into OpenSCAD may be accessed by quite simple modules which are for the most part, a series of decorators/\allowbreak descriptors which wrap up the Python definitions as OpenSCAD modules. Moreover, such an implementation will facilitate usage by tools intended for this application such as OpenSCAD Graph Editor: \url{https://github.com/derkork/openscad-graph-editor}. 

\lstset{firstnumber=1}%\thegcptmplscad}
\begin{writecode}{w}{gcodepreviewtemplate.scad}{scad}
//!OpenSCAD

use <gcodepreview.py>
include <gcodepreview.scad>

$fn = $preview ? 32 : 256;
fn = $preview ? 32 : 256;

/* [Stock] */
stockXwidth = 220;
/* [Stock] */
stockYheight = 150;
/* [Stock] */
stockZthickness = 8.35;
/* [Stock] */
zeroheight = "Top"; // [Top, Bottom]
/* [Stock] */
stockzero = "Center"; // [Lower-Left, Center-Left, Top-Left, Center]
/* [Stock] */
retractheight = 9;

/* [Export] */
Base_filename = "export";
/* [Export] */
generatedxf = true;
/* [Export] */
generategcode = true;

/* [CAM] */
toolradius = 1.5875;
/* [CAM] */
large_square_tool_num = 0; // [0:0, 112:112, 102:102, 201:201]
/* [CAM] */
small_square_tool_num = 102; // [0:0, 122:122, 112:112, 102:102]
/* [CAM] */
large_ball_tool_num = 0; // [0:0, 111:111, 101:101, 202:202]
/* [CAM] */
small_ball_tool_num = 0; // [0:0, 121:121, 111:111, 101:101]
/* [CAM] */
large_V_tool_num = 0; // [0:0, 301:301, 690:690]
/* [CAM] */
small_V_tool_num = 0; // [0:0, 390:390, 301:301]
/* [CAM] */
DT_tool_num = 0; // [0:0, 814:814, 808079:808079]
/* [CAM] */
KH_tool_num = 0; // [0:0, 374:374, 375:375, 376:376, 378:378]
/* [CAM] */
Roundover_tool_num = 0; // [56142:56142, 56125:56125, 1570:1570]
/* [CAM] */
MISC_tool_num = 0; // [648:648, 45982:45982]
//648 threadmill_shaft(2.4, 0.75, 18)
//45982 Carbide Tipped Bowl & Tray 1/4 Radius x 3/4 Dia x 5/8 x 1/4 Inch Shank

/* [Feeds and Speeds] */
plunge = 100;
/* [Feeds and Speeds] */
feed = 400;
/* [Feeds and Speeds] */
speed = 16000;
/* [Feeds and Speeds] */
small_square_ratio = 0.75; // [0.25:2]
/* [Feeds and Speeds] */
large_ball_ratio = 1.0; // [0.25:2]
/* [Feeds and Speeds] */
small_ball_ratio = 0.75; // [0.25:2]
/* [Feeds and Speeds] */
large_V_ratio = 0.875; // [0.25:2]
/* [Feeds and Speeds] */
small_V_ratio = 0.625; // [0.25:2]
/* [Feeds and Speeds] */
DT_ratio = 0.75; // [0.25:2]
/* [Feeds and Speeds] */
KH_ratio = 0.75; // [0.25:2]
/* [Feeds and Speeds] */
RO_ratio = 0.5; // [0.25:2]
/* [Feeds and Speeds] */
MISC_ratio = 0.5; // [0.25:2]

thegeneratedxf = generatedxf == true ? 1 : 0;
thegenerategcode = generategcode == true ? 1 : 0;

gcp = gcodepreview("cut", // or "print" (no preview not suited to OpenSCAD)
                   thegenerategcode,
                   thegeneratedxf,
                   );

opengcodefile(Base_filename);
opendxffile(Base_filename);

setupstock(stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero);

//echo(gcp);
//gcpversion();

//c = myfunc(4);
//echo(c);

//echo(getvv());

cutline(stockXwidth/2, stockYheight/2, -stockZthickness);

rapidZ(retractheight);
toolchange(201, 10000);
rapidXY(0, stockYheight/16);
rapidZ(0);
cutlinedxfgc(stockXwidth/16*7, stockYheight/2, -stockZthickness);


rapidZ(retractheight);
toolchange(202, 10000);
rapidXY(0, stockYheight/8);
rapidZ(0);
cutlinedxfgc(stockXwidth/16*6, stockYheight/2, -stockZthickness);

rapidZ(retractheight);
toolchange(101, 10000);
rapidXY(0, stockYheight/16*3);
rapidZ(0);
cutlinedxfgc(stockXwidth/16*5, stockYheight/2, -stockZthickness);

rapidZ(retractheight);
toolchange(390, 10000);
rapidXY(0, stockYheight/16*4);
rapidZ(0);

cutlinedxfgc(stockXwidth/16*4, stockYheight/2, -stockZthickness);
rapidZ(retractheight);

toolchange(301, 10000);
rapidXY(0, stockYheight/16*6);
rapidZ(0);

cutlinedxfgc(stockXwidth/16*2, stockYheight/2, -stockZthickness);


movetosafeZ();
rapid(gcp.xpos(), gcp.ypos(), retractheight);
toolchange(102, 10000);

//rapidXY(stockXwidth/4+stockYheight/8+stockYheight/16, +stockYheight/8);
rapidXY(-stockXwidth/4+stockXwidth/16, (stockYheight/4));//+stockYheight/16
rapidZ(0);

//cutarcCW(360, 270, gcp.xpos()-stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness);
//gcp.cutarcCW(270, 180, gcp.xpos(), gcp.ypos()+stockYheight/16, stockYheight/16))
//cutarcCC(0, 90, gcp.xpos()-stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4);
//cutarcCC(90, 180, gcp.xpos(), gcp.ypos()-stockYheight/16, stockYheight/16, -stockZthickness/4);
//cutarcCC(180, 270, gcp.xpos()+stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4);
//cutarcCC(270, 360, gcp.xpos(), gcp.ypos()+stockYheight/16, stockYheight/16, -stockZthickness/4);

movetosafeZ();
//rapidXY(stockXwidth/4+stockYheight/8-stockYheight/16, -stockYheight/8);
rapidXY(stockXwidth/4-stockYheight/16, -(stockYheight/4));
rapidZ(0);

//cutarcCW(180, 90, gcp.xpos()+stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4);
//cutarcCW(90, 0, gcp.xpos(), gcp.ypos()-stockYheight/16, stockYheight/16, -stockZthickness/4);
//cutarcCW(360, 270, gcp.xpos()-stockYheight/16, gcp.ypos(), stockYheight/16, -stockZthickness/4);
//cutarcCW(270, 180, gcp.xpos(), gcp.ypos()+stockYheight/16, stockYheight/16, -stockZthickness/4);

movetosafeZ();

rapidXY(-stockXwidth/4 + stockYheight/8, (stockYheight/4));
rapidZ(0);

cutquarterCCNEdxf(xpos() - stockYheight/8, ypos() + stockYheight/8, -stockZthickness/4, stockYheight/8);
cutquarterCCNWdxf(xpos() - stockYheight/8, ypos() - stockYheight/8, -stockZthickness/2, stockYheight/8);
cutquarterCCSWdxf(xpos() + stockYheight/8, ypos() - stockYheight/8, -stockZthickness * 0.75, stockYheight/8);
//cutquarterCCSEdxf(xpos() + stockYheight/8, ypos() + stockYheight/8, -stockZthickness, stockYheight/8);

movetosafeZ();
toolchange(201, 10000);
rapidXY(stockXwidth /2 -6.34, - stockYheight /2);
rapidZ(0);
//cutarcCW(180, 90, stockXwidth /2, -stockYheight/2, 6.34, - stockZthickness);

movetosafeZ();
rapidXY(stockXwidth/2, -stockYheight/2);
rapidZ(0);

//gcp.cutlinedxfgc(gcp.xpos(), gcp.ypos(), -stockZthickness);

movetosafeZ();
toolchange(814, 10000);
rapidXY(0, -(stockYheight/2+12.7));
rapidZ(0);

cutlinedxfgc(xpos(), ypos(), -stockZthickness);
cutlinedxfgc(xpos(), -12.7, -stockZthickness);
rapidXY(0, -(stockYheight/2+12.7));

//rapidXY(stockXwidth/2-6.34, -stockYheight/2);
//rapidZ(0);

//movetosafeZ();
//toolchange(374, 10000);
//rapidXY(-(stockXwidth/4 - stockXwidth /16), -(stockYheight/4 + stockYheight/16))

//cutline(xpos(), ypos(), (stockZthickness/2) * -1);
//cutlinedxfgc(xpos() + stockYheight /9, ypos(), zpos());
//cutline(xpos() - stockYheight /9, ypos(), zpos());
//cutline(xpos(), ypos(), 0);

movetosafeZ();

toolchange(374, 10000);
rapidXY(-stockXwidth/4-stockXwidth/16, -(stockYheight/4+stockYheight/16))
//rapidXY(-(stockXwidth/4 - stockXwidth /16), -(stockYheight/4 + stockYheight/16))
rapidZ(0);

cutline(xpos(), ypos(), (stockZthickness/2) * -1);
cutlinedxfgc(xpos() + stockYheight /9, ypos(), zpos());
cutline(xpos() - stockYheight /9, ypos(), zpos());
cutline(xpos(), ypos(), 0);

rapidZ(retractheight);
rapidXY(-stockXwidth/4+stockXwidth/16, -(stockYheight/4+stockYheight/16));
rapidZ(0);
cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2);
cutlinedxfgc(gcp.xpos(), gcp.ypos()+stockYheight/9, gcp.zpos());
cutline(gcp.xpos(), gcp.ypos()-stockYheight/9, gcp.zpos());
cutline(gcp.xpos(), gcp.ypos(), 0);

rapidZ(retractheight);
rapidXY(-stockXwidth/4+stockXwidth/16, -(stockYheight/4-stockYheight/8));
rapidZ(0);
cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2);
cutlinedxfgc(gcp.xpos()-stockYheight/9, gcp.ypos(), gcp.zpos());
cutline(gcp.xpos()+stockYheight/9, gcp.ypos(), gcp.zpos());
cutline(gcp.xpos(), gcp.ypos(), 0);

rapidZ(retractheight);
rapidXY(-stockXwidth/4-stockXwidth/16, -(stockYheight/4-stockYheight/8));
rapidZ(0);
cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2);
cutlinedxfgc(gcp.xpos(), gcp.ypos()-stockYheight/9, gcp.zpos());
cutline(gcp.xpos(), gcp.ypos()+stockYheight/9, gcp.zpos());
cutline(gcp.xpos(), gcp.ypos(), 0);

rapidZ(retractheight);
toolchange(45982, 10000);
rapidXY(stockXwidth/8, 0);
cutline(gcp.xpos(), gcp.ypos(), -(stockZthickness*7/8));
cutlinedxfgc(gcp.xpos(), -stockYheight/2, -(stockZthickness*7/8));

rapidZ(retractheight);
toolchange(204, 10000);
rapidXY(stockXwidth*0.3125, 0);
cutline(gcp.xpos(), gcp.ypos(), -(stockZthickness*7/8));
cutlinedxfgc(gcp.xpos(), -stockYheight/2, -(stockZthickness*7/8));

rapidZ(retractheight);
toolchange(502, 10000);
rapidXY(stockXwidth*0.375, 0);
cutline(gcp.xpos(), gcp.ypos(), -4.24);
cutlinedxfgc(gcp.xpos(), -stockYheight/2, -4.24);

rapidZ(retractheight);
toolchange(13921, 10000);
rapidXY(-stockXwidth*0.375, 0);
cutline(gcp.xpos(), gcp.ypos(), -stockZthickness/2);
cutlinedxfgc(gcp.xpos(), -stockYheight/2, -stockZthickness/2);

rapidZ(retractheight);
gcp.toolchange(56142, 10000);
gcp.rapidXY(-stockXwidth/2, -(stockYheight/2+0.508/2));
cutlineZgcfeed(-1.531, plunge);
//cutline(gcp.xpos(), gcp.ypos(), -1.531);
cutlinedxfgc(stockXwidth/2+0.508/2, -(stockYheight/2+0.508/2), -1.531);

rapidZ(retractheight);
//#gcp.toolchange(56125, 10000)
cutlineZgcfeed(-1.531, plunge);
//toolpaths.append(gcp.cutline(gcp.xpos(), gcp.ypos(), -1.531))
cutlinedxfgc(stockXwidth/2+0.508/2, (stockYheight/2+0.508/2), -1.531);

stockandtoolpaths();
//stockwotoolpaths();
//outputtoolpaths();

//makecube(3, 2, 1);

//instantiatecube();

closegcodefile();
closedxffile();

\end{writecode}
\addtocounter{gcptmplscad}{300}

%opendxffiles(Base_filename,
%                 large_square_tool_num,
%                 small_square_tool_num,
%                 large_ball_tool_num,
%                 small_ball_tool_num,
%                 large_V_tool_num,
%                 small_V_tool_num,
%                 DT_tool_num,
%                 KH_tool_num,
%                 Roundover_tool_num,
%                 MISC_tool_num);
%
%closedxffiles();

\begin{samepage}
\noindent Which generates a \textsc{3d} model which previews in OpenSCAD as:

\bigskip

%\includeimage{gcodepreview_unittests_scad.png}
\includeimage{gcodepreviewtemplate_scad.png}
\end{samepage}

\subsection{gpcthreedp.py}

Setting up \textsc{3d} printing will require accommodating the requirements of both the printer \emph{and} filament being used. The most straight-forward and expedient way to arrive at this is to leverage a traditional 3D printer slicer which has settings appropriate to the machine and filament being used which are tuned to the sort of part being made/printing being done, export the G-code, and use that as a template for setting up \textsc{3d} printing.

Towards that end, a G-code file for a very basic \textsc{3d} printer was output for printing \textsc{pla} from an Ordbot Quantum

\lstset{firstnumber=1}%\gcpthreedp}
\begin{writecode}{w}{gcpthreedp.py}{python}
#gcpthreedp.py --- Template for 3D printing 
#                  Initial version.
#!/usr/bin/env python

import sys

try:
    if 'gcodepreview' in sys.modules:
        del sys.modules['gcodepreview']
except AttributeError:
    pass

from gcodepreview import *

fa = 2
fs = 0.125

# [Export] */
Base_filename = "aexport"
# [Export] */
generatedxf = False
# [Export] */
generategcode = True
# [3D Printing] */
nozzlediameter = 0.4
filamentdiameter = 1.75
extrusionwidth = 0.6
layerheight = 0.2
temperature =200

gcp = gcodepreview("print", # "cut" or "no_preview"
                   generategcode,
                   generatedxf,
                   )

gcp.opengcodefile(Base_filename)

gcp.initializeforprinting(nozzlediameter, 
                          filamentdiameter, 
                          extrusionwidth, 
                          layerheight)

gcp.setandwaitforextrudertemperature(temperature)
gcp.liftandprimenozzle()

gcp.moveatfeedrate(0,0,layerheight,20000)
gcp.extrude(10, 20, layerheight)

gcp.stockandtoolpaths("toolpaths")

gcp.closegcodefile()

\end{writecode}
\addtocounter{gcpthreedp}{45}

%\begin{verbatim}
%; generated by PrusaSlicer 2.9.4 on 2025-11-28 at 13:50:31 UTC
%
%; 
%
%; external perimeters extrusion width = 0.39mm
%; perimeters extrusion width = 0.39mm
%; infill extrusion width = 0.39mm
%; solid infill extrusion width = 0.39mm
%; top infill extrusion width = 0.35mm
%; first layer extrusion width = 0.37mm
%
%M104 S200 ; set temperature
%;TYPE:Custom
%G28 ; home all axes
%G1 Z5 F5000 ; lift nozzle
%M109 S200 ; set temperature and wait for it to be reached
%G21 ; set units to millimeters
%G90 ; use absolute coordinates
%M82 ; use absolute distances for extrusion
%G92 E0
%; Filament gcode
%M107
%;LAYER_CHANGE
%;Z:0.35
%;HEIGHT:0.35
%G1 E-2 F2400
%G92 E0
%G1 Z.35 F7800
%G1 X4.269 Y-11.572
%G1 E2 F2400
%;TYPE:Skirt/Brim
%;WIDTH:0.37
%G1 F1800
%G1 X4.875 Y-11.348 E2.02772
%G1 X5.941 Y-10.829 E2.0786
%G1 X6.951 Y-10.21 E2.12943
%G1 X7.898 Y-9.496 E2.18032
%G1 X8.847 Y-8.619 E2.23577
%G1 X9.632 Y-7.731 E2.28663
%G1 X10.329 Y-6.772 E2.3375
%G1 X10.931 Y-5.751 E2.38836
%G1 X11.472 Y-4.577 E2.44383
%G1 X11.858 Y-3.456 E2.4947
%G1 X12.135 Y-2.304 E2.54554
%G1 X12.309 Y-1.023 E2.60101
%G1 X12.35 Y.162 E2.65189
%G1 X12.278 Y1.344 E2.7027
%G1 X12.092 Y2.515 E2.75358
%G1 X11.796 Y3.662 E2.80441
%G1 X11.348 Y4.875 E2.8599
%G1 X10.829 Y5.941 E2.91078
%G1 X10.148 Y7.04 E2.96626
%G1 X9.427 Y7.98 E3.01709
%G1 X8.618 Y8.848 E3.06801
%G1 X7.731 Y9.632 E3.11881
%G1 X6.682 Y10.388 E3.17429
%G1 X5.655 Y10.981 E3.22518
%G1 X4.577 Y11.472 E3.27601
%G1 X3.353 Y11.888 E3.33148
%G1 X2.198 Y12.154 E3.38234
%G1 X1.023 Y12.309 E3.4332
%G1 X-.162 Y12.35 E3.48408
%G1 X-1.344 Y12.278 E3.53489
%G1 X-2.515 Y12.092 E3.58577
%G1 X-3.766 Y11.763 E3.64128
%G1 X-4.875 Y11.348 E3.69209
%G1 X-5.941 Y10.829 E3.74297
%G1 X-6.951 Y10.21 E3.7938
%G1 X-7.898 Y9.496 E3.84469
%G1 X-8.847 Y8.618 E3.90017
%G1 X-9.632 Y7.731 E3.951
%G1 X-10.388 Y6.682 E4.00648
%G1 X-10.981 Y5.655 E4.05737
%G1 X-11.472 Y4.577 E4.1082
%G1 X-11.858 Y3.456 E4.15907
%G1 X-12.154 Y2.198 E4.21453
%G1 X-12.309 Y1.023 E4.26539
%G1 X-12.35 Y-.162 E4.31627
%G1 X-12.266 Y-1.452 E4.37174
%G1 X-12.07 Y-2.621 E4.4226
%G1 X-11.763 Y-3.766 E4.47347
%G1 X-11.348 Y-4.875 E4.52428
%G1 X-10.829 Y-5.941 E4.57516
%G1 X-10.21 Y-6.951 E4.62599
%G1 X-9.496 Y-7.898 E4.67688
%G1 X-8.618 Y-8.847 E4.73236
%G1 X-7.731 Y-9.632 E4.78319
%G1 X-6.682 Y-10.388 E4.83867
%G1 X-5.655 Y-10.981 E4.88956
%G1 X-4.577 Y-11.472 E4.94039
%G1 X-3.456 Y-11.858 E4.99126
%G1 X-2.198 Y-12.154 E5.04672
%G1 X-1.023 Y-12.309 E5.09758
%G1 X.162 Y-12.35 E5.14846
%G1 X1.344 Y-12.278 E5.19927
%G1 X2.515 Y-12.092 E5.25015
%G1 X3.662 Y-11.796 E5.30098
%G1 X4.22 Y-11.59 E5.3265
%G1 E3.3265 F2400
%G92 E0
%G92 E0
%G1 X2.057 Y-5.648 F7800
%G1 E2 F2400
%;TYPE:External perimeter
%;WIDTH:0.37
%G1 F1800
%G1 X2.352 Y-5.54 E2.01348
%G1 X2.919 Y-5.264 E2.04054
%G1 X3.566 Y-4.841 E2.07371
%G1 X4.061 Y-4.431 E2.10129
%G1 X4.434 Y-4.062 E2.1238
%G1 X4.801 Y-3.617 E2.14855
%G1 X5.179 Y-3.05 E2.17779
%G1 X5.428 Y-2.588 E2.20031
%G1 X5.648 Y-2.055 E2.22505
%G1 X5.845 Y-1.403 E2.25428
%G1 X5.947 Y-.888 E2.27681
%G1 X6.005 Y-.262 E2.30379
%G1 X5.996 Y.525 E2.33756
%G1 X5.908 Y1.149 E2.3646
%G1 X5.786 Y1.658 E2.38706
%G1 X5.58 Y2.255 E2.41416
%G1 X5.314 Y2.826 E2.44119
%G1 X4.99 Y3.366 E2.46821
%G1 X4.61 Y3.869 E2.49526
%G1 X4.256 Y4.256 E2.51777
%G1 X3.868 Y4.611 E2.54034
%G1 X3.366 Y4.99 E2.56733
%G1 X2.826 Y5.314 E2.59435
%G1 X2.255 Y5.58 E2.62138
%G1 X1.658 Y5.786 E2.64848
%G1 X1.149 Y5.908 E2.67094
%G1 X.524 Y5.996 E2.69802
%G1 X0 Y6.019 E2.72053
%G1 X-.525 Y5.996 E2.74308
%G1 X-1.149 Y5.908 E2.77012
%G1 X-1.658 Y5.786 E2.79258
%G1 X-2.255 Y5.58 E2.81968
%G1 X-2.826 Y5.314 E2.84671
%G1 X-3.366 Y4.989 E2.87375
%G1 X-3.787 Y4.678 E2.89621
%G1 X-4.257 Y4.255 E2.92334
%G1 X-4.61 Y3.869 E2.94579
%G1 X-4.99 Y3.366 E2.97284
%G1 X-5.315 Y2.825 E2.99992
%G1 X-5.541 Y2.351 E3.02245
%G1 X-5.756 Y1.76 E3.04944
%G1 X-5.908 Y1.148 E3.0765
%G1 X-5.996 Y.524 E3.10354
%G1 X-6.019 Y0 E3.12605
%G1 X-5.996 Y-.524 E3.14856
%G1 X-5.908 Y-1.149 E3.17564
%G1 X-5.786 Y-1.658 E3.1981
%G1 X-5.58 Y-2.255 E3.2252
%G1 X-5.314 Y-2.826 E3.25223
%G1 X-5.048 Y-3.277 E3.2747
%G1 X-4.677 Y-3.788 E3.3018
%G1 X-4.255 Y-4.256 E3.32884
%G1 X-3.868 Y-4.611 E3.35137
%G1 X-3.366 Y-4.99 E3.37836
%G1 X-2.826 Y-5.314 E3.40538
%G1 X-2.254 Y-5.581 E3.43247
%G1 X-1.761 Y-5.756 E3.45492
%G1 X-1.148 Y-5.908 E3.48202
%G1 X-.524 Y-5.996 E3.50906
%G1 X.001 Y-6.019 E3.53161
%G1 X.629 Y-5.986 E3.55859
%G1 X1.252 Y-5.887 E3.58566
%G1 X1.759 Y-5.756 E3.60813
%G1 X2.007 Y-5.666 E3.61945
%G1 X3.225 Y-4.972 F7800
%;TYPE:Solid infill
%;WIDTH:0.37236
%G1 F1800
%G1 X4.117 Y-4.08 E3.67401
%G1 X4.441 Y-3.727 E3.69473
%G1 X4.806 Y-3.242 E3.72098
%G1 X5.177 Y-2.6 E3.75305
%G1 X2.607 Y-5.17 E3.91026
%G1 X2.265 Y-5.336 E3.9267
%G1 X1.88 Y-5.477 E3.94443
%G1 X5.477 Y-1.88 E4.16446
%G1 X5.544 Y-1.695 E4.17297
%G1 X5.645 Y-1.292 E4.19094
%G1 X1.286 Y-5.65 E4.45755
%G1 X.777 Y-5.738 E4.47989
%G1 X5.74 Y-.775 E4.78348
%G1 X5.781 Y-.315 E4.80346
%G1 X.315 Y-5.781 E5.13781
%G1 X-.117 Y-5.792 E5.1565
%G1 X5.792 Y.117 E5.51795
%G1 X5.773 Y.519 E5.53536
%G1 X-.519 Y-5.773 E5.92024
%G1 X-.887 Y-5.722 E5.93631
%G1 X5.722 Y.887 E6.34058
%G1 X5.658 Y1.244 E6.35627
%G1 X-1.243 Y-5.657 E6.7784
%G1 X-1.579 Y-5.573 E6.79338
%G1 X5.576 Y1.583 E7.23108
%G1 X5.47 Y1.897 E7.24541
%G1 X-1.899 Y-5.472 E7.69617
%G1 X-2.206 Y-5.359 E7.71032
%G1 X5.359 Y2.206 E8.17307
%G1 X5.225 Y2.493 E8.18677
%G1 X-2.493 Y-5.225 E8.65888
%G1 X-2.775 Y-5.087 E8.67246
%G1 X5.087 Y2.775 E9.15338
%G1 X4.929 Y3.037 E9.16661
%G1 X-3.037 Y-4.929 E9.65389
%G1 X-3.295 Y-4.766 E9.66709
%G1 X4.766 Y3.295 E10.16018
%G1 X4.585 Y3.535 E10.17318
%G1 X-3.535 Y-4.586 E10.66991
%G1 X-3.77 Y-4.401 E10.68285
%G1 X4.401 Y3.77 E11.18267
%G1 X4.2 Y3.99 E11.19556
%G1 X-3.99 Y-4.2 E11.69654
%G1 X-4.199 Y-3.989 E11.70939
%G1 X3.99 Y4.2 E12.21031
%G1 X3.77 Y4.401 E12.2232
%G1 X-4.398 Y-3.767 E12.72284
%G1 X-4.587 Y-3.536 E12.73575
%G1 X3.535 Y4.586 E13.23257
%G1 X3.295 Y4.766 E13.24555
%G1 X-4.764 Y-3.292 E13.73849
%G1 X-4.932 Y-3.04 E13.75159
%G1 X3.037 Y4.929 E14.23905
%G1 X2.775 Y5.087 E14.25228
%G1 X-5.087 Y-2.775 E14.7332
%G1 X-5.225 Y-2.493 E14.74678
%G1 X2.493 Y5.225 E15.21889
%G1 X2.206 Y5.359 E15.23259
%G1 X-5.359 Y-2.206 E15.69534
%G1 X-5.47 Y-1.897 E15.70954
%G1 X1.897 Y5.47 E16.16018
%G1 X1.583 Y5.576 E16.17451
%G1 X-5.576 Y-1.583 E16.61242
%G1 X-5.658 Y-1.244 E16.62751
%G1 X1.244 Y5.658 E17.0497
%G1 X.887 Y5.722 E17.06539
%G1 X-5.722 Y-.887 E17.46966
%G1 X-5.773 Y-.519 E17.48573
%G1 X.519 Y5.773 E17.87061
%G1 X.117 Y5.792 E17.88802
%G1 X-5.792 Y-.117 E18.24947
%G1 X-5.784 Y.312 E18.26803
%G1 X-.312 Y5.784 E18.60275
%G1 X-.779 Y5.737 E18.62305
%G1 X-5.737 Y.779 E18.92633
%G1 X-5.691 Y1.106 E18.94061
%G1 X-5.644 Y1.292 E18.94891
%G1 X-1.289 Y5.647 E19.2153
%G1 X-1.596 Y5.573 E19.22896
%G1 X-1.882 Y5.475 E19.24204
%G1 X-5.477 Y1.88 E19.46195
%G1 X-5.336 Y2.265 E19.47968
%G1 X-5.177 Y2.6 E19.49572
%G1 X-2.603 Y5.174 E19.65317
%G1 X-3.243 Y4.805 E19.68512
%G1 X-3.647 Y4.507 E19.70683
%G1 X-4.087 Y4.11 E19.73246
%G1 X-4.969 Y3.228 E19.78641
%;LAYER_CHANGE
%;Z:0.65
%;HEIGHT:0.3
%G1 Z.65 F7800
%G1 X-5.03 Y3.269
%;TYPE:External perimeter
%;WIDTH:0.39
%G1 F900
%G1 X-5.114 Y3.144 E19.79253
%G1 X-5.394 Y2.629 E19.81634
%G1 X-5.656 Y2.005 E19.84383
%G1 X-5.813 Y1.5 E19.86531
%G1 X-5.927 Y.937 E19.88864
%G1 X-5.995 Y.26 E19.91627
%G1 X-5.997 Y-.262 E19.93747
%G1 X-5.935 Y-.889 E19.96306
%G1 X-5.837 Y-1.401 E19.98423
%G1 X-5.674 Y-1.954 E20.00764
%G1 X-5.417 Y-2.582 E20.0352
%G1 X-5.171 Y-3.05 E20.05667
%G1 X-4.854 Y-3.528 E20.07996
%G1 X-4.459 Y-4.015 E20.10543
%G1 X-3.977 Y-4.493 E20.133
%G1 X-3.568 Y-4.827 E20.15445
%G1 X-3.089 Y-5.144 E20.17778
%G1 X-2.49 Y-5.46 E20.20528
%G1 X-2.001 Y-5.66 E20.22674
%G1 X-1.45 Y-5.823 E20.25008
%G1 X-.785 Y-5.949 E20.27757
%G1 X-.259 Y-5.997 E20.29902
%G1 X.316 Y-5.992 E20.32237
%G1 X.992 Y-5.918 E20.34999
%G1 X1.503 Y-5.812 E20.37119
%G1 X2.103 Y-5.62 E20.39678
%G1 X2.584 Y-5.418 E20.41797
%G1 X3.137 Y-5.116 E20.44356
%G1 X3.571 Y-4.826 E20.46476
%G1 X4.053 Y-4.425 E20.49022
%G1 X4.428 Y-4.053 E20.51167
%G1 X4.825 Y-3.568 E20.53712
%G1 X5.118 Y-3.137 E20.55829
%G1 X5.393 Y-2.63 E20.58171
%G1 X5.656 Y-2.005 E20.60925
%G1 X5.813 Y-1.5 E20.63073
%G1 X5.927 Y-.937 E20.65406
%G1 X6.009 Y0 E20.69226
%G1 X5.976 Y.629 E20.71784
%G1 X5.898 Y1.147 E20.73911
%G1 X5.776 Y1.655 E20.76033
%G1 X5.571 Y2.252 E20.78597
%G1 X5.354 Y2.727 E20.80718
%G1 X5.039 Y3.273 E20.83278
%G1 X4.67 Y3.781 E20.85828
%G1 X4.249 Y4.249 E20.88385
%G1 X3.781 Y4.67 E20.90942
%G1 X3.148 Y5.112 E20.94078
%G1 X2.63 Y5.393 E20.96471
%G1 X2.052 Y5.639 E20.99022
%G1 X1.402 Y5.835 E21.01779
%G1 X.884 Y5.938 E21.03924
%G1 X.313 Y5.992 E21.06253
%G1 X-.368 Y5.989 E21.09019
%G1 X-.887 Y5.937 E21.11137
%G1 X-1.504 Y5.809 E21.13696
%G1 X-2.004 Y5.659 E21.15816
%G1 X-2.536 Y5.438 E21.18156
%G1 X-3.137 Y5.116 E21.20925
%G1 X-3.571 Y4.826 E21.23045
%G1 X-4.015 Y4.459 E21.25384
%G1 X-4.487 Y3.984 E21.28104
%G1 X-4.833 Y3.561 E21.30323
%G1 X-5 Y3.313 E21.31537
%G1 E19.31537 F2400
%G92 E0
%G1 X-3.688 Y-4.556 F7800
%G1 E2 F2400
%;TYPE:Solid infill
%;WIDTH:0.36188
%G1 F1200
%G1 X-4.134 Y-4.134 E2.02278
%G1 X-3.806 Y-4.444 E2.03953
%G1 X-3.022 Y-4.9 F7800
%;WIDTH:0.39
%G1 F1200
%G1 X-4.909 Y-3.013 E2.14791
%G1 X-5.051 Y-2.793 E2.15854
%;WIDTH:0.36188
%G1 X-5.113 Y-2.809 E2.16092
%G1 X-5.097 Y-2.747 E2.1633
%G1 X-5.061 Y-2.757 E2.16469
%G1 X-5.483 Y-1.841 F7800
%G1 F1200
%G1 X-5.519 Y-1.831 E2.16608
%G1 X-5.536 Y-1.893 E2.16847
%G1 X-5.474 Y-1.877 E2.17085
%;WIDTH:0.39
%G1 X-5.367 Y-2.095 E2.18071
%G1 X-2.093 Y-5.368 E2.36872
%G1 X-1.84 Y-5.484 E2.38002
%;WIDTH:0.36188
%G1 X-1.876 Y-5.474 E2.38141
%G1 X-1.892 Y-5.537 E2.38382
%G1 X-1.83 Y-5.52 E2.38621
%;WIDTH:0.39
%G1 X-1.423 Y-5.578 E2.40291
%G1 X-5.582 Y-1.419 E2.64178
%G1 X-5.694 Y-.846 E2.66549
%G1 X-.846 Y-5.694 E2.94394
%G1 X-.33 Y-5.75 E2.96502
%G1 X-5.75 Y-.33 E3.27632
%G1 X-5.757 Y.138 E3.29533
%G1 X.138 Y-5.757 E3.63391
%G1 X.575 Y-5.734 E3.65168
%G1 X-5.734 Y.575 E4.01404
%G1 X-5.674 Y.975 E4.03047
%G1 X.975 Y-5.674 E4.41236
%G1 X1.359 Y-5.597 E4.42827
%G1 X-5.597 Y1.359 E4.82779
%G1 X-5.499 Y1.722 E4.84306
%G1 X1.722 Y-5.499 E5.2578
%G1 X2.059 Y-5.376 E5.27237
%G1 X-5.376 Y2.059 E5.6994
%G1 X-5.241 Y2.385 E5.71373
%G1 X2.386 Y-5.242 E6.15179
%G1 X2.698 Y-5.094 E6.16581
%G1 X-5.09 Y2.695 E6.61315
%G1 X-4.923 Y2.988 E6.62685
%G1 X2.986 Y-4.921 E7.08111
%G1 X3.27 Y-4.745 E7.09468
%G1 X-4.745 Y3.27 E7.55503
%G1 X-4.549 Y3.534 E7.56838
%G1 X3.534 Y-4.549 E8.03263
%G1 X3.784 Y-4.338 E8.04592
%G1 X-4.338 Y3.784 E8.51241
%G1 X-4.12 Y4.027 E8.52567
%G1 X4.027 Y-4.12 E8.9936
%G1 X4.251 Y-3.884 E9.00681
%G1 X-3.883 Y4.25 E9.47399
%G1 X-3.64 Y4.468 E9.48725
%G1 X4.466 Y-3.639 E9.95285
%G1 X4.664 Y-3.376 E9.96622
%G1 X-3.377 Y4.665 E10.42806
%G1 X-3.103 Y4.851 E10.44151
%G1 X4.852 Y-3.104 E10.89841
%G1 X5.027 Y-2.818 E10.91203
%G1 X-2.815 Y5.024 E11.36244
%G1 X-2.511 Y5.18 E11.37632
%G1 X5.18 Y-2.51 E11.81803
%G1 X5.326 Y-2.196 E11.83209
%G1 X-2.197 Y5.327 E12.26418
%G1 X-1.86 Y5.451 E12.27876
%G1 X5.449 Y-1.859 E12.69858
%G1 X5.558 Y-1.507 E12.71355
%G1 X-1.506 Y5.557 E13.11927
%G1 X-1.137 Y5.649 E13.13471
%G1 X5.648 Y-1.137 E13.52444
%G1 X5.711 Y-.739 E13.54081
%G1 X-.74 Y5.712 E13.91133
%G1 X-.315 Y5.748 E13.92865
%G1 X5.748 Y-.315 E14.27688
%G1 X5.757 Y.136 E14.2952
%G1 X.136 Y5.757 E14.61804
%G1 X.624 Y5.729 E14.63789
%G1 X5.73 Y.624 E14.93113
%G1 X5.641 Y1.173 E14.95372
%G1 X1.174 Y5.64 E15.21028
%G1 X1.602 Y5.628 E15.22767
%;WIDTH:0.36188
%G1 X1.566 Y5.637 E15.22905
%G1 X1.55 Y5.575 E15.23143
%G1 X1.612 Y5.592 E15.23382
%;WIDTH:0.39
%G1 X1.806 Y5.468 E15.24317
%G1 X5.465 Y1.81 E15.4533
%G1 X5.629 Y1.609 E15.46384
%;WIDTH:0.36188
%G1 X5.593 Y1.618 E15.46522
%G1 X5.576 Y1.556 E15.46761
%G1 X5.639 Y1.573 E15.47003
%G1 X5.249 Y2.432 F7800
%;WIDTH:0.312445
%G1 F1200
%G1 X5.168 Y2.639 E15.47691
%G1 X4.863 Y3.166 E15.49575
%;WIDTH:0.359033
%G1 X4.486 Y3.643 E15.51809
%;WIDTH:0.374452
%G1 X4.075 Y4.087 E15.54149
%G1 X3.63 Y4.497 E15.56489
%;WIDTH:0.358969
%G1 X3.237 Y4.81 E15.58335
%;WIDTH:0.322524
%G1 X2.431 Y5.256 E15.61301
%G1 X2.729 Y4.959 E15.62656
%;WIDTH:0.358969
%G1 X3.438 Y4.275 E15.66276
%;WIDTH:0.374452
%G1 X4.273 Y3.44 E15.70843
%;WIDTH:0.359033
%G1 X4.675 Y3.005 E15.7302
%;WIDTH:0.312445
%G1 X5.133 Y2.547 E15.75024
%;LAYER_CHANGE
%;Z:0.95
%;HEIGHT:0.3
%G1 Z.95 F7800
%G1 X5.366 Y2.671
%;TYPE:External perimeter
%;WIDTH:0.39
%G1 F900
%G1 X5.116 Y3.137 E15.77172
%G1 X4.826 Y3.571 E15.79292
%G1 X4.423 Y4.055 E15.8185
%G1 X4.056 Y4.426 E15.83969
%G1 X3.568 Y4.825 E15.86529
%G1 X3.137 Y5.118 E15.88646
%G1 X2.63 Y5.393 E15.90988
%G1 X2.052 Y5.639 E15.93539
%G1 X1.404 Y5.834 E15.96287
%G1 X.882 Y5.938 E15.98449
%G1 X.259 Y5.995 E16.0099
%G1 X-.261 Y5.997 E16.03102
%G1 X-.835 Y5.942 E16.05444
%G1 X-1.493 Y5.812 E16.08168
%G1 X-2.015 Y5.655 E16.10382
%G1 X-2.484 Y5.465 E16.12437
%G1 X-3.002 Y5.196 E16.14808
%G1 X-3.527 Y4.854 E16.17353
%G1 X-4.055 Y4.423 E16.20121
%G1 X-4.426 Y4.056 E16.2224
%G1 X-4.792 Y3.611 E16.2458
%G1 X-5.143 Y3.09 E16.27131
%G1 X-5.461 Y2.487 E16.299
%G1 X-5.659 Y2.004 E16.3202
%G1 X-5.835 Y1.399 E16.34579
%G1 X-5.937 Y.887 E16.36699
%G1 X-5.992 Y.314 E16.39037
%G1 X-5.989 Y-.368 E16.41807
%G1 X-5.937 Y-.887 E16.43925
%G1 X-5.809 Y-1.504 E16.46484
%G1 X-5.659 Y-2.004 E16.48604
%G1 X-5.418 Y-2.58 E16.5114
%G1 X-5.17 Y-3.051 E16.53302
%G1 X-4.853 Y-3.529 E16.55631
%G1 X-4.459 Y-4.015 E16.58172
%G1 X-4.015 Y-4.459 E16.60722
%G1 X-3.483 Y-4.886 E16.63492
%G1 X-3.047 Y-5.172 E16.6561
%G1 X-2.487 Y-5.461 E16.68169
%G1 X-2.004 Y-5.659 E16.70289
%G1 X-1.452 Y-5.822 E16.72627
%G1 X-.787 Y-5.949 E16.75377
%G1 X-.257 Y-5.997 E16.77538
%G1 X.316 Y-5.992 E16.79865
%G1 X.992 Y-5.918 E16.82627
%G1 X1.503 Y-5.812 E16.84747
%G1 X2.052 Y-5.639 E16.87085
%G1 X2.668 Y-5.375 E16.89807
%G1 X3.147 Y-5.112 E16.92026
%G1 X3.566 Y-4.829 E16.94079
%G1 X4.052 Y-4.426 E16.96643
%G1 X4.429 Y-4.052 E16.988
%G1 X4.794 Y-3.61 E17.01128
%G1 X5.169 Y-3.049 E17.03869
%G1 X5.42 Y-2.58 E17.06029
%G1 X5.64 Y-2.05 E17.0836
%G1 X5.835 Y-1.399 E17.1112
%G1 X5.937 Y-.887 E17.1324
%G1 X5.992 Y-.314 E17.15578
%G1 X5.976 Y.629 E17.19408
%G1 X5.84 Y1.389 E17.22544
%G1 X5.674 Y1.954 E17.24936
%G1 X5.438 Y2.536 E17.27487
%G1 X5.39 Y2.625 E17.27898
%G1 E15.27898 F2400
%G92 E0
%G1 X3.227 Y-4.951 F7800
%G1 E2 F2400
%;TYPE:Top solid infill
%;WIDTH:0.353516
%G1 F900
%G1 X4.116 Y-4.062 E2.04534
%G1 X4.435 Y-3.714 E2.06236
%G1 X4.795 Y-3.235 E2.08397
%G1 X5.156 Y-2.613 E2.10991
%G1 X2.62 Y-5.149 E2.23925
%G1 X2.26 Y-5.324 E2.25369
%G1 X1.907 Y-5.453 E2.26724
%G1 X5.453 Y-1.907 E2.44809
%G1 X5.531 Y-1.691 E2.45637
%G1 X5.622 Y-1.33 E2.4698
%G1 X1.325 Y-5.626 E2.68892
%G1 X.825 Y-5.718 E2.70725
%G1 X5.72 Y-.822 E2.95692
%G1 X5.765 Y-.369 E2.97334
%G1 X.368 Y-5.765 E3.24856
%G1 X-.057 Y-5.782 E3.2639
%G1 X5.781 Y.057 E3.56166
%G1 X5.761 Y.445 E3.57567
%G1 X-.449 Y-5.765 E3.89238
%G1 X-.812 Y-5.719 E3.90558
%G1 X5.721 Y.815 E4.23879
%G1 X5.663 Y1.165 E4.25158
%G1 X-1.165 Y-5.663 E4.59981
%G1 X-1.492 Y-5.581 E4.61197
%G1 X5.584 Y1.495 E4.97285
%G1 X5.487 Y1.807 E4.98463
%G1 X-1.81 Y-5.49 E5.35678
%G1 X-2.112 Y-5.383 E5.36833
%G1 X5.382 Y2.111 E5.75052
%G1 X5.257 Y2.395 E5.76171
%G1 X-2.395 Y-5.257 E6.15196
%G1 X-2.673 Y-5.127 E6.16303
%G1 X5.127 Y2.673 E6.56083
%G1 X4.977 Y2.932 E6.57162
%G1 X-2.934 Y-4.979 E6.97508
%G1 X-3.188 Y-4.824 E6.98581
%G1 X4.823 Y3.188 E7.3944
%G1 X4.653 Y3.427 E7.40498
%G1 X-3.425 Y-4.652 E7.81698
%G1 X-3.66 Y-4.477 E7.82755
%G1 X4.477 Y3.66 E8.24254
%G1 X4.284 Y3.875 E8.25296
%G1 X-3.875 Y-4.284 E8.66907
%G1 X-4.09 Y-4.09 E8.67951
%G1 X4.09 Y4.09 E9.09669
%G1 X3.877 Y4.286 E9.10713
%G1 X-4.284 Y-3.875 E9.52334
%G1 X-4.478 Y-3.66 E9.53378
%G1 X3.658 Y4.476 E9.94872
%G1 X3.425 Y4.652 E9.95925
%G1 X-4.652 Y-3.425 E10.37118
%G1 X-4.824 Y-3.188 E10.38174
%G1 X3.188 Y4.824 E10.79035
%G1 X2.935 Y4.979 E10.80105
%G1 X-4.978 Y-2.934 E11.20461
%G1 X-5.127 Y-2.673 E11.21545
%G1 X2.671 Y5.124 E11.61312
%G1 X2.396 Y5.258 E11.62415
%G1 X-5.257 Y-2.395 E12.01445
%G1 X-5.383 Y-2.112 E12.02562
%G1 X2.108 Y5.38 E12.40769
%G1 X1.809 Y5.489 E12.41917
%G1 X-5.49 Y-1.81 E12.79142
%G1 X-5.581 Y-1.492 E12.80335
%G1 X1.492 Y5.581 E13.16407
%G1 X1.165 Y5.663 E13.17623
%G1 X-5.663 Y-1.165 E13.52446
%G1 X-5.721 Y-.814 E13.53729
%G1 X.814 Y5.721 E13.87058
%G1 X.445 Y5.761 E13.88397
%G1 X-5.761 Y-.445 E14.20048
%G1 X-5.781 Y-.057 E14.21449
%G1 X.057 Y5.781 E14.51223
%G1 X-.365 Y5.768 E14.52746
%G1 X-5.765 Y.369 E14.80284
%G1 X-5.72 Y.822 E14.81926
%G1 X-.825 Y5.717 E15.06891
%G1 X-1.104 Y5.678 E15.07907
%G1 X-1.33 Y5.622 E15.08747
%G1 X-5.622 Y1.33 E15.30636
%G1 X-5.531 Y1.693 E15.31986
%G1 X-5.456 Y1.904 E15.32794
%G1 X-1.904 Y5.456 E15.50909
%G1 X-2.167 Y5.363 E15.51915
%G1 X-2.607 Y5.162 E15.53659
%G1 X-5.154 Y2.615 E15.66649
%G1 X-4.795 Y3.234 E15.6923
%G1 X-4.43 Y3.719 E15.71419
%G1 X-4.116 Y4.062 E15.73096
%G1 X-3.217 Y4.961 E15.77681
%;LAYER_CHANGE
%;Z:1.25
%;HEIGHT:0.3
%G1 Z0.950 F7800
%;TYPE:External perimeter
%;WIDTH:0.39
%G1 F900
%G1 Z0.950 X-3.273 Y5.039 E15.77719
%G1 Z0.955 X-3.781 Y4.67 E15.80269
%G1 Z0.960 X-4.249 Y4.248 E15.82828
%G1 Z0.964 X-4.602 Y3.863 E15.84949
%G1 Z0.969 X-4.981 Y3.36 E15.87507
%G1 Z0.974 X-5.306 Y2.82 E15.90067
%G1 Z0.978 X-5.535 Y2.339 E15.92231
%G1 Z0.983 X-5.746 Y1.757 E15.94745
%G1 Z0.988 X-5.898 Y1.147 E15.97298
%G1 Z0.993 X-5.986 Y.523 E15.99857
%G1 Z0.998 X-6.009 Y0 E16.01983
%G1 Z1.002 X-5.986 Y-.523 E16.04109
%G1 Z1.007 X-5.898 Y-1.147 E16.06668
%G1 Z1.012 X-5.746 Y-1.758 E16.09225
%G1 Z1.016 X-5.567 Y-2.26 E16.1139
%G1 Z1.021 X-5.305 Y-2.821 E16.13905
%G1 Z1.026 X-4.981 Y-3.361 E16.16463
%G1 Z1.030 X-4.67 Y-3.781 E16.18585
%G1 Z1.035 X-4.249 Y-4.249 E16.21142
%G1 Z1.040 X-3.781 Y-4.67 E16.23699
%G1 Z1.044 X-3.352 Y-4.987 E16.25865
%G1 Z1.049 X-2.821 Y-5.305 E16.28379
%G1 Z1.054 X-2.25 Y-5.572 E16.30939
%G1 Z1.058 X-1.747 Y-5.749 E16.33105
%G1 Z1.063 X-1.147 Y-5.898 E16.35616
%G1 Z1.068 X-.523 Y-5.986 E16.38175
%G1 Z1.073 X.01 Y-6.009 E16.40342
%G1 Z1.078 X.628 Y-5.976 E16.42855
%G1 Z1.083 X1.25 Y-5.877 E16.45413
%G1 Z1.087 X1.756 Y-5.746 E16.47536
%G1 Z1.092 X2.348 Y-5.531 E16.50094
%G1 Z1.097 X2.914 Y-5.255 E16.52651
%G1 Z1.101 X3.36 Y-4.982 E16.54775
%G1 Z1.105 X3.789 Y-4.663 E16.56946
%G1 Z1.110 X4.249 Y-4.248 E16.59462
%G1 Z1.114 X4.602 Y-3.863 E16.61583
%G1 Z1.119 X4.981 Y-3.36 E16.64141
%G1 Z1.124 X5.305 Y-2.821 E16.66695
%G1 Z1.129 X5.572 Y-2.25 E16.69255
%G1 Z1.133 X5.746 Y-1.758 E16.71374
%G1 Z1.138 X5.899 Y-1.146 E16.73936
%G1 Z1.143 X5.976 Y-.629 E16.76059
%G1 Z1.148 X6.009 Y.001 E16.78621
%G1 Z1.152 X5.986 Y.523 E16.80743
%G1 Z1.157 X5.898 Y1.147 E16.83302
%G1 Z1.161 X5.776 Y1.655 E16.85424
%G1 Z1.166 X5.571 Y2.252 E16.87988
%G1 Z1.170 X5.354 Y2.727 E16.90109
%G1 Z1.175 X5.039 Y3.273 E16.92669
%G1 Z1.180 X4.67 Y3.781 E16.95219
%G1 Z1.185 X4.248 Y4.249 E16.97778
%G1 Z1.189 X3.863 Y4.602 E16.99899
%G1 Z1.194 X3.36 Y4.981 E17.02457
%G1 Z1.199 X2.821 Y5.305 E17.05011
%G1 Z1.204 X2.25 Y5.572 E17.07571
%G1 Z1.208 X1.758 Y5.746 E17.0969
%G1 Z1.213 X1.147 Y5.898 E17.12247
%G1 Z1.218 X.523 Y5.986 E17.14806
%G1 Z1.223 X0 Y6.009 E17.16932
%G1 Z1.227 X-.523 Y5.986 E17.19058
%G1 Z1.232 X-1.147 Y5.898 E17.21617
%G1 Z1.236 X-1.655 Y5.776 E17.23739
%G1 Z1.241 X-2.252 Y5.571 E17.26303
%G1 Z1.245 X-2.727 Y5.354 E17.28424
%G1 Z1.250 X-3.265 Y5.044 E17.30946
%;LAYER_CHANGE
%;Z:1.55
%;HEIGHT:0.3
%G1 Z1.250 F7800
%G1 F900
%G1 Z1.250 X-3.272 Y5.039 E17.30981
%G1 Z1.255 X-3.781 Y4.67 E17.33534
%G1 Z1.260 X-4.249 Y4.248 E17.36093
%G1 Z1.264 X-4.611 Y3.853 E17.38269
%G1 Z1.269 X-4.982 Y3.36 E17.40775
%G1 Z1.274 X-5.261 Y2.902 E17.42953
%G1 Z1.278 X-5.531 Y2.348 E17.45456
%G1 Z1.283 X-5.746 Y1.756 E17.48014
%G1 Z1.288 X-5.877 Y1.25 E17.50137
%G1 Z1.293 X-5.976 Y.628 E17.52695
%G1 Z1.298 X-6.009 Y-.001 E17.55253
%G1 Z1.302 X-5.986 Y-.523 E17.57375
%G1 Z1.307 X-5.898 Y-1.147 E17.59934
%G1 Z1.312 X-5.746 Y-1.758 E17.62491
%G1 Z1.316 X-5.572 Y-2.25 E17.6461
%G1 Z1.321 X-5.305 Y-2.822 E17.67174
%G1 Z1.325 X-5.032 Y-3.283 E17.6935
%G1 Z1.330 X-4.67 Y-3.781 E17.7185
%G1 Z1.335 X-4.248 Y-4.249 E17.74409
%G1 Z1.339 X-3.853 Y-4.611 E17.76585
%G1 Z1.344 X-3.36 Y-4.981 E17.79088
%G1 Z1.349 X-2.821 Y-5.305 E17.81642
%G1 Z1.354 X-2.25 Y-5.572 E17.84202
%G1 Z1.358 X-1.758 Y-5.746 E17.86321
%G1 Z1.363 X-1.147 Y-5.898 E17.88878
%G1 Z1.368 X-.523 Y-5.986 E17.91437
%G1 Z1.373 X.013 Y-6.009 E17.93616
%G1 Z1.378 X.628 Y-5.976 E17.96117
%G1 Z1.383 X1.25 Y-5.877 E17.98675
%G1 Z1.387 X1.756 Y-5.746 E18.00798
%G1 Z1.392 X2.348 Y-5.531 E18.03356
%G1 Z1.396 X2.832 Y-5.299 E18.05536
%G1 Z1.401 X3.361 Y-4.981 E18.08043
%G1 Z1.405 X3.791 Y-4.662 E18.10217
%G1 Z1.410 X4.249 Y-4.249 E18.12722
%G1 Z1.415 X4.67 Y-3.781 E18.15279
%G1 Z1.419 X4.989 Y-3.349 E18.1746
%G1 Z1.424 X5.305 Y-2.821 E18.19959
%G1 Z1.429 X5.572 Y-2.25 E18.22519
%G1 Z1.433 X5.746 Y-1.758 E18.24638
%G1 Z1.438 X5.899 Y-1.146 E18.272
%G1 Z1.443 X5.976 Y-.629 E18.29323
%G1 Z1.448 X6.009 Y.001 E18.31885
%G1 Z1.452 X5.986 Y.523 E18.34007
%G1 Z1.457 X5.898 Y1.147 E18.36566
%G1 Z1.462 X5.746 Y1.758 E18.39123
%G1 Z1.466 X5.571 Y2.251 E18.41248
%G1 Z1.470 X5.354 Y2.727 E18.43373
%G1 Z1.475 X5.039 Y3.273 E18.45933
%G1 Z1.480 X4.67 Y3.781 E18.48483
%G1 Z1.485 X4.248 Y4.249 E18.51042
%G1 Z1.489 X3.863 Y4.602 E18.53163
%G1 Z1.494 X3.36 Y4.981 E18.55721
%G1 Z1.499 X2.821 Y5.305 E18.58275
%G1 Z1.504 X2.25 Y5.572 E18.60835
%G1 Z1.508 X1.758 Y5.746 E18.62954
%G1 Z1.513 X1.147 Y5.898 E18.65511
%G1 Z1.518 X.523 Y5.986 E18.6807
%G1 Z1.523 X0 Y6.009 E18.70196
%G1 Z1.527 X-.523 Y5.986 E18.72322
%G1 Z1.532 X-1.147 Y5.898 E18.74881
%G1 Z1.536 X-1.655 Y5.776 E18.77003
%G1 Z1.541 X-2.252 Y5.571 E18.79567
%G1 Z1.545 X-2.739 Y5.348 E18.81742
%G1 Z1.550 X-3.265 Y5.044 E18.84209
%;LAYER_CHANGE
%;Z:1.85
%;HEIGHT:0.3
%G1 Z1.550 F7800
%G1 F900
%G1 Z1.551 X-3.361 Y4.981 E18.84674
%G1 Z1.555 X-3.781 Y4.67 E18.86796
%G1 Z1.560 X-4.249 Y4.249 E18.89353
%G1 Z1.565 X-4.67 Y3.781 E18.9191
%G1 Z1.570 X-5.04 Y3.272 E18.94466
%G1 Z1.574 X-5.305 Y2.822 E18.96587
%G1 Z1.579 X-5.572 Y2.25 E18.99151
%G1 Z1.583 X-5.746 Y1.758 E19.0127
%G1 Z1.588 X-5.899 Y1.146 E19.03832
%G1 Z1.593 X-5.976 Y.629 E19.05955
%G1 Z1.598 X-6.009 Y-.001 E19.08517
%G1 Z1.602 X-5.986 Y-.523 E19.10639
%G1 Z1.607 X-5.898 Y-1.147 E19.13198
%G1 Z1.612 X-5.746 Y-1.757 E19.15751
%G1 Z1.616 X-5.565 Y-2.265 E19.17941
%G1 Z1.621 X-5.305 Y-2.821 E19.20434
%G1 Z1.626 X-4.981 Y-3.36 E19.22988
%G1 Z1.631 X-4.602 Y-3.863 E19.25546
%G1 Z1.635 X-4.249 Y-4.248 E19.27667
%G1 Z1.640 X-3.781 Y-4.67 E19.30226
%G1 Z1.644 X-3.347 Y-4.99 E19.32416
%G1 Z1.649 X-2.821 Y-5.305 E19.34906
%G1 Z1.654 X-2.25 Y-5.572 E19.37466
%G1 Z1.658 X-1.758 Y-5.746 E19.39585
%G1 Z1.663 X-1.147 Y-5.898 E19.42142
%G1 Z1.668 X-.523 Y-5.986 E19.44701
%G1 Z1.673 X.016 Y-6.009 E19.46892
%G1 Z1.678 X.628 Y-5.976 E19.49381
%G1 Z1.683 X1.25 Y-5.877 E19.51939
%G1 Z1.687 X1.756 Y-5.746 E19.54062
%G1 Z1.692 X2.348 Y-5.531 E19.5662
%G1 Z1.697 X2.914 Y-5.255 E19.59177
%G1 Z1.701 X3.36 Y-4.982 E19.61301
%G1 Z1.705 X3.781 Y-4.67 E19.63429
%G1 Z1.710 X4.249 Y-4.249 E19.65986
%G1 Z1.715 X4.67 Y-3.781 E19.68543
%G1 Z1.719 X4.981 Y-3.361 E19.70665
%G1 Z1.724 X5.306 Y-2.82 E19.73228
%G1 Z1.729 X5.537 Y-2.333 E19.75417
%G1 Z1.733 X5.746 Y-1.757 E19.77906
%G1 Z1.738 X5.899 Y-1.146 E19.80464
%G1 Z1.743 X5.976 Y-.629 E19.82587
%G1 Z1.748 X6.009 Y.001 E19.85149
%G1 Z1.752 X5.986 Y.523 E19.87271
%G1 Z1.757 X5.898 Y1.147 E19.8983
%G1 Z1.761 X5.776 Y1.655 E19.91952
%G1 Z1.766 X5.571 Y2.251 E19.94512
%G1 Z1.771 X5.305 Y2.821 E19.97067
%G1 Z1.776 X4.981 Y3.36 E19.99621
%G1 Z1.781 X4.602 Y3.863 E20.02179
%G1 Z1.785 X4.249 Y4.249 E20.04303
%G1 Z1.789 X3.85 Y4.613 E20.06496
%G1 Z1.794 X3.359 Y4.982 E20.0899
%G1 Z1.798 X2.914 Y5.255 E20.1111
%G1 Z1.803 X2.348 Y5.531 E20.13667
%G1 Z1.808 X1.757 Y5.746 E20.16221
%G1 Z1.813 X1.147 Y5.898 E20.18774
%G1 Z1.818 X.523 Y5.986 E20.21333
%G1 Z1.823 X0 Y6.009 E20.23459
%G1 Z1.827 X-.523 Y5.986 E20.25585
%G1 Z1.832 X-1.147 Y5.898 E20.28144
%G1 Z1.837 X-1.758 Y5.746 E20.30701
%G1 Z1.841 X-2.25 Y5.572 E20.3282
%G1 Z1.846 X-2.821 Y5.305 E20.3538
%G1 Z1.850 X-3.263 Y5.04 E20.37473
%;LAYER_CHANGE
%;Z:2.15
%;HEIGHT:0.3
%G1 Z1.850 F7800
%G1 F900
%G1 Z1.850 X-3.288 Y5.029 E20.37582
%G1 Z1.855 X-3.781 Y4.67 E20.40059
%G1 Z1.860 X-4.249 Y4.248 E20.42618
%G1 Z1.864 X-4.602 Y3.863 E20.44739
%G1 Z1.869 X-4.981 Y3.36 E20.47297
%G1 Z1.874 X-5.305 Y2.821 E20.49851
%G1 Z1.879 X-5.571 Y2.251 E20.52406
%G1 Z1.884 X-5.776 Y1.655 E20.54966
%G1 Z1.888 X-5.898 Y1.147 E20.57088
%G1 Z1.893 X-5.986 Y.523 E20.59647
%G1 Z1.898 X-6.009 Y0 E20.61773
%G1 Z1.902 X-5.986 Y-.523 E20.63899
%G1 Z1.907 X-5.898 Y-1.146 E20.66454
%G1 Z1.912 X-5.746 Y-1.758 E20.69015
%G1 Z1.916 X-5.572 Y-2.25 E20.71134
%G1 Z1.921 X-5.305 Y-2.822 E20.73698
%G1 Z1.925 X-5.029 Y-3.288 E20.75898
%G1 Z1.930 X-4.67 Y-3.781 E20.78375
%G1 Z1.935 X-4.248 Y-4.249 E20.80934
%G1 Z1.939 X-3.863 Y-4.602 E20.83055
%G1 Z1.944 X-3.36 Y-4.981 E20.85613
%G1 Z1.949 X-2.821 Y-5.305 E20.88167
%G1 Z1.954 X-2.25 Y-5.572 E20.90727
%G1 Z1.958 X-1.758 Y-5.746 E20.92846
%G1 Z1.963 X-1.147 Y-5.898 E20.95403
%G1 Z1.968 X-.523 Y-5.986 E20.97962
%G1 Z1.973 X.019 Y-6.009 E21.00165
%G1 Z1.978 X.628 Y-5.976 E21.02642
%G1 Z1.983 X1.25 Y-5.877 E21.052
%G1 Z1.987 X1.756 Y-5.746 E21.07323
%G1 Z1.992 X2.348 Y-5.531 E21.09881
%G1 Z1.997 X2.914 Y-5.255 E21.12438
%G1 Z2.001 X3.36 Y-4.982 E21.14562
%G1 Z2.005 X3.781 Y-4.67 E21.1669
%G1 Z2.010 X4.249 Y-4.249 E21.19247
%G1 Z2.015 X4.67 Y-3.781 E21.21804
%G1 Z2.019 X4.981 Y-3.361 E21.23926
%G1 Z2.024 X5.305 Y-2.821 E21.26484
%G1 Z2.029 X5.571 Y-2.25 E21.29042
%G1 Z2.034 X5.751 Y-1.739 E21.31242
%G1 Z2.038 X5.899 Y-1.146 E21.33724
%G1 Z2.043 X5.976 Y-.629 E21.35847
%G1 Z2.048 X6.009 Y.001 E21.38409
%G1 Z2.052 X5.986 Y.523 E21.40531
%G1 Z2.057 X5.898 Y1.147 E21.4309
%G1 Z2.062 X5.746 Y1.758 E21.45647
%G1 Z2.066 X5.571 Y2.251 E21.47772
%G1 Z2.070 X5.354 Y2.727 E21.49897
%G1 Z2.075 X5.039 Y3.273 E21.52457
%G1 Z2.080 X4.67 Y3.781 E21.55007
%G1 Z2.085 X4.249 Y4.249 E21.57564
%G1 Z2.090 X3.781 Y4.67 E21.60121
%G1 Z2.094 X3.361 Y4.981 E21.62243
%G1 Z2.099 X2.82 Y5.306 E21.64806
%G1 Z2.104 X2.331 Y5.538 E21.67004
%G1 Z2.108 X1.757 Y5.746 E21.69484
%G1 Z2.113 X1.147 Y5.898 E21.72037
%G1 Z2.118 X.523 Y5.986 E21.74596
%G1 Z2.123 X0 Y6.009 E21.76722
%G1 Z2.127 X-.523 Y5.986 E21.78848
%G1 Z2.132 X-1.147 Y5.898 E21.81407
%G1 Z2.136 X-1.655 Y5.776 E21.83529
%G1 Z2.141 X-2.251 Y5.571 E21.86089
%G1 Z2.146 X-2.822 Y5.305 E21.88647
%G1 Z2.150 X-3.265 Y5.043 E21.90737
%;LAYER_CHANGE
%;Z:2.45
%;HEIGHT:0.3
%G1 Z2.150 F7800
%G1 F900
%G1 Z2.150 X-3.273 Y5.039 E21.90775
%G1 Z2.155 X-3.781 Y4.67 E21.93325
%G1 Z2.160 X-4.249 Y4.248 E21.95884
%G1 Z2.164 X-4.602 Y3.863 E21.98005
%G1 Z2.169 X-4.981 Y3.36 E22.00563
%G1 Z2.174 X-5.306 Y2.82 E22.03123
%G1 Z2.179 X-5.539 Y2.328 E22.05334
%G1 Z2.183 X-5.746 Y1.757 E22.07801
%G1 Z2.188 X-5.898 Y1.146 E22.10358
%G1 Z2.193 X-5.978 Y.607 E22.12571
%G1 Z2.198 X-6.009 Y-.001 E22.15043
%G1 Z2.202 X-5.986 Y-.523 E22.17165
%G1 Z2.207 X-5.898 Y-1.147 E22.19724
%G1 Z2.212 X-5.746 Y-1.757 E22.22277
%G1 Z2.216 X-5.563 Y-2.271 E22.24493
%G1 Z2.221 X-5.305 Y-2.821 E22.2696
%G1 Z2.226 X-4.981 Y-3.361 E22.29518
%G1 Z2.230 X-4.67 Y-3.781 E22.3164
%G1 Z2.235 X-4.249 Y-4.249 E22.34197
%G1 Z2.240 X-3.781 Y-4.67 E22.36754
%G1 Z2.244 X-3.342 Y-4.993 E22.38968
%G1 Z2.249 X-2.821 Y-5.305 E22.41434
%G1 Z2.254 X-2.25 Y-5.572 E22.43994
%G1 Z2.258 X-1.758 Y-5.746 E22.46113
%G1 Z2.263 X-1.147 Y-5.898 E22.4867
%G1 Z2.268 X-.523 Y-5.986 E22.51229
%G1 Z2.273 X.021 Y-6.009 E22.5344
%G1 Z2.278 X.628 Y-5.976 E22.55909
%G1 Z2.283 X1.25 Y-5.877 E22.58467
%G1 Z2.287 X1.756 Y-5.746 E22.6059
%G1 Z2.292 X2.348 Y-5.531 E22.63148
%G1 Z2.297 X2.914 Y-5.255 E22.65705
%G1 Z2.301 X3.36 Y-4.982 E22.67829
%G1 Z2.305 X3.781 Y-4.67 E22.69957
%G1 Z2.310 X4.249 Y-4.248 E22.72516
%G1 Z2.314 X4.602 Y-3.863 E22.74637
%G1 Z2.319 X4.981 Y-3.36 E22.77195
%G1 Z2.324 X5.305 Y-2.821 E22.79749
%G1 Z2.329 X5.571 Y-2.251 E22.82304
%G1 Z2.334 X5.776 Y-1.655 E22.84864
%G1 Z2.338 X5.898 Y-1.147 E22.86986
%G1 Z2.343 X5.976 Y-.629 E22.89113
%G1 Z2.348 X6.009 Y.001 E22.91675
%G1 Z2.352 X5.984 Y.545 E22.93887
%G1 Z2.357 X5.898 Y1.146 E22.96353
%G1 Z2.362 X5.746 Y1.758 E22.98914
%G1 Z2.366 X5.572 Y2.25 E23.01033
%G1 Z2.371 X5.305 Y2.821 E23.03593
%G1 Z2.376 X4.981 Y3.361 E23.06151
%G1 Z2.380 X4.67 Y3.781 E23.08273
%G1 Z2.385 X4.248 Y4.249 E23.10832
%G1 Z2.389 X3.863 Y4.602 E23.12953
%G1 Z2.394 X3.36 Y4.981 E23.15511
%G1 Z2.399 X2.82 Y5.306 E23.18071
%G1 Z2.404 X2.328 Y5.539 E23.20282
%G1 Z2.408 X1.757 Y5.746 E23.22749
%G1 Z2.413 X1.147 Y5.898 E23.25302
%G1 Z2.418 X.523 Y5.986 E23.27861
%G1 Z2.423 X0 Y6.009 E23.29987
%G1 Z2.427 X-.523 Y5.986 E23.32113
%G1 Z2.432 X-1.147 Y5.898 E23.34672
%G1 Z2.436 X-1.655 Y5.776 E23.36794
%G1 Z2.441 X-2.252 Y5.571 E23.39358
%G1 Z2.445 X-2.727 Y5.354 E23.41479
%G1 Z2.450 X-3.265 Y5.044 E23.44001
%;LAYER_CHANGE
%;Z:2.75
%;HEIGHT:0.3
%G1 Z2.450 F7800
%G1 F900
%G1 Z2.451 X-3.36 Y4.982 E23.44462
%G1 Z2.455 X-3.781 Y4.67 E23.4659
%G1 Z2.460 X-4.249 Y4.248 E23.49149
%G1 Z2.464 X-4.602 Y3.863 E23.5127
%G1 Z2.469 X-4.981 Y3.36 E23.53828
%G1 Z2.474 X-5.306 Y2.82 E23.56388
%G1 Z2.479 X-5.54 Y2.325 E23.58612
%G1 Z2.483 X-5.746 Y1.757 E23.61066
%G1 Z2.488 X-5.898 Y1.146 E23.63623
%G1 Z2.493 X-5.978 Y.604 E23.65848
%G1 Z2.498 X-6.009 Y-.001 E23.68308
%G1 Z2.502 X-5.986 Y-.523 E23.7043
%G1 Z2.507 X-5.898 Y-1.147 E23.72989
%G1 Z2.511 X-5.776 Y-1.655 E23.75111
%G1 Z2.516 X-5.571 Y-2.251 E23.77671
%G1 Z2.521 X-5.305 Y-2.822 E23.80229
%G1 Z2.525 X-5.026 Y-3.293 E23.82452
%G1 Z2.530 X-4.67 Y-3.781 E23.84905
%G1 Z2.535 X-4.248 Y-4.249 E23.87464
%G1 Z2.539 X-3.844 Y-4.618 E23.89686
%G1 Z2.544 X-3.36 Y-4.981 E23.92143
%G1 Z2.549 X-2.821 Y-5.305 E23.94697
%G1 Z2.554 X-2.25 Y-5.572 E23.97257
%G1 Z2.558 X-1.758 Y-5.746 E23.99376
%G1 Z2.563 X-1.147 Y-5.898 E24.01933
%G1 Z2.568 X-.523 Y-5.986 E24.04492
%G1 Z2.573 X.024 Y-6.009 E24.06715
%G1 Z2.578 X.628 Y-5.976 E24.09172
%G1 Z2.583 X1.25 Y-5.877 E24.1173
%G1 Z2.587 X1.756 Y-5.746 E24.13853
%G1 Z2.592 X2.348 Y-5.531 E24.16411
%G1 Z2.596 X2.842 Y-5.294 E24.18636
%G1 Z2.601 X3.36 Y-4.981 E24.21094
%G1 Z2.605 X3.8 Y-4.654 E24.2332
%G1 Z2.610 X4.249 Y-4.249 E24.25776
%G1 Z2.614 X4.618 Y-3.844 E24.28001
%G1 Z2.619 X4.981 Y-3.36 E24.30458
%G1 Z2.624 X5.306 Y-2.82 E24.33018
%G1 Z2.629 X5.54 Y-2.325 E24.35242
%G1 Z2.633 X5.746 Y-1.757 E24.37696
%G1 Z2.638 X5.898 Y-1.146 E24.40253
%G1 Z2.643 X5.978 Y-.604 E24.42478
%G1 Z2.648 X6.009 Y.001 E24.44938
%G1 Z2.652 X5.986 Y.523 E24.4706
%G1 Z2.657 X5.898 Y1.147 E24.49619
%G1 Z2.661 X5.776 Y1.655 E24.51741
%G1 Z2.666 X5.571 Y2.252 E24.54305
%G1 Z2.670 X5.354 Y2.727 E24.56426
%G1 Z2.675 X5.039 Y3.273 E24.58986
%G1 Z2.680 X4.67 Y3.781 E24.61536
%G1 Z2.685 X4.248 Y4.249 E24.64095
%G1 Z2.689 X3.863 Y4.602 E24.66216
%G1 Z2.694 X3.36 Y4.981 E24.68774
%G1 Z2.699 X2.82 Y5.306 E24.71334
%G1 Z2.703 X2.349 Y5.531 E24.73454
%G1 Z2.708 X1.757 Y5.746 E24.76012
%G1 Z2.713 X1.147 Y5.898 E24.78565
%G1 Z2.718 X.523 Y5.986 E24.81124
%G1 Z2.723 X.001 Y6.009 E24.83246
%G1 Z2.728 X-.628 Y5.976 E24.85804
%G1 Z2.733 X-1.25 Y5.877 E24.88362
%G1 Z2.737 X-1.756 Y5.746 E24.90485
%G1 Z2.742 X-2.348 Y5.531 E24.93043
%G1 Z2.747 X-2.914 Y5.255 E24.956
%G1 Z2.750 X-3.263 Y5.041 E24.97263
%;LAYER_CHANGE
%;Z:3.05
%;HEIGHT:0.3
%G1 Z2.750 F7800
%G1 F900
%G1 Z2.750 X-3.273 Y5.039 E24.97301
%G1 Z2.755 X-3.781 Y4.67 E24.99851
%G1 Z2.760 X-4.249 Y4.248 E25.0241
%G1 Z2.764 X-4.62 Y3.841 E25.04647
%G1 Z2.769 X-4.982 Y3.36 E25.07092
%G1 Z2.774 X-5.268 Y2.889 E25.0933
%G1 Z2.778 X-5.531 Y2.347 E25.11777
%G1 Z2.783 X-5.714 Y1.858 E25.13897
%G1 Z2.788 X-5.877 Y1.249 E25.16457
%G1 Z2.793 X-5.976 Y.628 E25.19011
%G1 Z2.798 X-6.009 Y-.001 E25.21569
%G1 Z2.802 X-5.986 Y-.523 E25.23691
%G1 Z2.807 X-5.898 Y-1.147 E25.2625
%G1 Z2.812 X-5.746 Y-1.758 E25.28807
%G1 Z2.816 X-5.572 Y-2.25 E25.30926
%G1 Z2.821 X-5.305 Y-2.821 E25.33486
%G1 Z2.825 X-5.024 Y-3.295 E25.35724
%G1 Z2.830 X-4.67 Y-3.781 E25.38166
%G1 Z2.835 X-4.248 Y-4.249 E25.40725
%G1 Z2.839 X-3.863 Y-4.602 E25.42846
%G1 Z2.844 X-3.36 Y-4.981 E25.45404
%G1 Z2.849 X-2.821 Y-5.305 E25.47958
%G1 Z2.854 X-2.25 Y-5.572 E25.50518
%G1 Z2.858 X-1.758 Y-5.746 E25.52637
%G1 Z2.863 X-1.147 Y-5.898 E25.55194
%G1 Z2.868 X-.523 Y-5.986 E25.57753
%G1 Z2.873 X.027 Y-6.009 E25.59989
%G1 Z2.878 X.628 Y-5.976 E25.62434
%G1 Z2.883 X1.249 Y-5.877 E25.64988
%G1 Z2.888 X1.858 Y-5.714 E25.67548
%G1 Z2.892 X2.347 Y-5.531 E25.69668
%G1 Z2.897 X2.914 Y-5.255 E25.72229
%G1 Z2.901 X3.36 Y-4.982 E25.74353
%G1 Z2.905 X3.781 Y-4.67 E25.76481
%G1 Z2.910 X4.249 Y-4.249 E25.79038
%G1 Z2.915 X4.67 Y-3.781 E25.81595
%G1 Z2.919 X4.981 Y-3.361 E25.83717
%G1 Z2.924 X5.305 Y-2.821 E25.86275
%G1 Z2.929 X5.572 Y-2.25 E25.88835
%G1 Z2.933 X5.746 Y-1.758 E25.90954
%G1 Z2.938 X5.899 Y-1.146 E25.93516
%G1 Z2.943 X5.976 Y-.629 E25.95639
%G1 Z2.948 X6.009 Y.001 E25.98201
%G1 Z2.952 X5.986 Y.523 E26.00323
%G1 Z2.957 X5.898 Y1.147 E26.02882
%G1 Z2.962 X5.746 Y1.758 E26.05439
%G1 Z2.966 X5.571 Y2.251 E26.07564
%G1 Z2.970 X5.354 Y2.727 E26.09689
%G1 Z2.975 X5.039 Y3.273 E26.12249
%G1 Z2.980 X4.67 Y3.781 E26.14799
%G1 Z2.985 X4.249 Y4.249 E26.17356
%G1 Z2.990 X3.781 Y4.67 E26.19913
%G1 Z2.994 X3.36 Y4.981 E26.22039
%G1 Z2.999 X2.889 Y5.268 E26.24279
%G1 Z3.003 X2.348 Y5.531 E26.26722
%G1 Z3.008 X1.757 Y5.746 E26.29276
%G1 Z3.013 X1.147 Y5.898 E26.31829
%G1 Z3.018 X.523 Y5.986 E26.34388
%G1 Z3.023 X0 Y6.009 E26.36514
%G1 Z3.027 X-.523 Y5.986 E26.3864
%G1 Z3.032 X-1.147 Y5.898 E26.41199
%G1 Z3.036 X-1.655 Y5.776 E26.43321
%G1 Z3.041 X-2.252 Y5.571 E26.45885
%G1 Z3.045 X-2.727 Y5.354 E26.48006
%G1 Z3.050 X-3.265 Y5.044 E26.50528
%;LAYER_CHANGE
%;Z:3.35
%;HEIGHT:0.3
%G1 Z3.050 F7800
%G1 F900
%G1 Z3.050 X-3.273 Y5.039 E26.50566
%G1 Z3.055 X-3.781 Y4.67 E26.53116
%G1 Z3.060 X-4.249 Y4.248 E26.55675
%G1 Z3.064 X-4.602 Y3.863 E26.57796
%G1 Z3.069 X-4.982 Y3.359 E26.6036
%G1 Z3.073 X-5.255 Y2.914 E26.6248
%G1 Z3.078 X-5.531 Y2.347 E26.65041
%G1 Z3.083 X-5.714 Y1.858 E26.67161
%G1 Z3.088 X-5.877 Y1.249 E26.69721
%G1 Z3.093 X-5.976 Y.628 E26.72275
%G1 Z3.098 X-6.009 Y-.001 E26.74833
%G1 Z3.102 X-5.986 Y-.523 E26.76955
%G1 Z3.107 X-5.898 Y-1.147 E26.79514
%G1 Z3.111 X-5.776 Y-1.655 E26.81636
%G1 Z3.116 X-5.571 Y-2.251 E26.84196
%G1 Z3.121 X-5.305 Y-2.821 E26.86751
%G1 Z3.125 X-5.023 Y-3.298 E26.89001
%G1 Z3.130 X-4.67 Y-3.781 E26.91431
%G1 Z3.135 X-4.248 Y-4.249 E26.9399
%G1 Z3.139 X-3.839 Y-4.622 E26.96238
%G1 Z3.144 X-3.36 Y-4.981 E26.98669
%G1 Z3.149 X-2.821 Y-5.305 E27.01223
%G1 Z3.154 X-2.25 Y-5.572 E27.03783
%G1 Z3.158 X-1.758 Y-5.746 E27.05902
%G1 Z3.163 X-1.147 Y-5.898 E27.08459
%G1 Z3.168 X-.523 Y-5.986 E27.11018
%G1 Z3.173 X.03 Y-6.009 E27.13266
%G1 Z3.178 X.628 Y-5.976 E27.15698
%G1 Z3.183 X1.249 Y-5.877 E27.18252
%G1 Z3.188 X1.858 Y-5.714 E27.20812
%G1 Z3.192 X2.347 Y-5.531 E27.22932
%G1 Z3.197 X2.914 Y-5.255 E27.25493
%G1 Z3.201 X3.36 Y-4.982 E27.27617
%G1 Z3.205 X3.781 Y-4.67 E27.29745
%G1 Z3.210 X4.249 Y-4.248 E27.32304
%G1 Z3.214 X4.622 Y-3.839 E27.34552
%G1 Z3.219 X4.982 Y-3.36 E27.36986
%G1 Z3.223 X5.255 Y-2.914 E27.3911
%G1 Z3.228 X5.531 Y-2.348 E27.41667
%G1 Z3.233 X5.746 Y-1.756 E27.44225
%G1 Z3.238 X5.877 Y-1.25 E27.46348
%G1 Z3.243 X5.976 Y-.628 E27.48906
%G1 Z3.248 X6.009 Y.001 E27.51464
%G1 Z3.252 X5.983 Y.554 E27.53712
%G1 Z3.257 X5.898 Y1.146 E27.56141
%G1 Z3.262 X5.746 Y1.757 E27.58698
%G1 Z3.267 X5.531 Y2.348 E27.61252
%G1 Z3.272 X5.255 Y2.914 E27.63809
%G1 Z3.276 X4.982 Y3.36 E27.65933
%G1 Z3.280 X4.67 Y3.781 E27.68061
%G1 Z3.285 X4.248 Y4.249 E27.7062
%G1 Z3.289 X3.863 Y4.602 E27.72741
%G1 Z3.294 X3.36 Y4.981 E27.75299
%G1 Z3.299 X2.821 Y5.305 E27.77853
%G1 Z3.304 X2.25 Y5.572 E27.80413
%G1 Z3.308 X1.758 Y5.746 E27.82532
%G1 Z3.313 X1.147 Y5.898 E27.85089
%G1 Z3.318 X.523 Y5.986 E27.87648
%G1 Z3.323 X0 Y6.009 E27.89774
%G1 Z3.327 X-.554 Y5.983 E27.92026
%G1 Z3.332 X-1.147 Y5.898 E27.94459
%G1 Z3.336 X-1.655 Y5.776 E27.96581
%G1 Z3.341 X-2.252 Y5.571 E27.99145
%G1 Z3.345 X-2.727 Y5.354 E28.01266
%G1 Z3.350 X-3.265 Y5.044 E28.03788
%;LAYER_CHANGE
%;Z:3.65
%;HEIGHT:0.3
%G1 Z3.350 F7800
%G1 F900
%G1 Z3.350 X-3.273 Y5.039 E28.03826
%G1 Z3.355 X-3.781 Y4.67 E28.06376
%G1 Z3.360 X-4.249 Y4.248 E28.08935
%G1 Z3.364 X-4.602 Y3.863 E28.11056
%G1 Z3.369 X-4.981 Y3.36 E28.13614
%G1 Z3.374 X-5.306 Y2.82 E28.16174
%G1 Z3.379 X-5.544 Y2.317 E28.18434
%G1 Z3.383 X-5.746 Y1.757 E28.20852
%G1 Z3.388 X-5.899 Y1.146 E28.2341
%G1 Z3.393 X-5.976 Y.629 E28.25533
%G1 Z3.398 X-6.009 Y-.001 E28.28095
%G1 Z3.402 X-5.986 Y-.523 E28.30217
%G1 Z3.407 X-5.898 Y-1.147 E28.32776
%G1 Z3.412 X-5.746 Y-1.758 E28.35333
%G1 Z3.416 X-5.572 Y-2.25 E28.37452
%G1 Z3.421 X-5.305 Y-2.821 E28.40012
%G1 Z3.425 X-5.021 Y-3.3 E28.42274
%G1 Z3.430 X-4.67 Y-3.781 E28.44692
%G1 Z3.435 X-4.249 Y-4.249 E28.47249
%G1 Z3.440 X-3.781 Y-4.67 E28.49806
%G1 Z3.445 X-3.332 Y-5 E28.52069
%G1 Z3.449 X-2.821 Y-5.305 E28.54486
%G1 Z3.454 X-2.25 Y-5.572 E28.57046
%G1 Z3.458 X-1.758 Y-5.746 E28.59165
%G1 Z3.463 X-1.147 Y-5.898 E28.61722
%G1 Z3.468 X-.523 Y-5.986 E28.64281
%G1 Z3.473 X.033 Y-6.008 E28.66541
%G1 Z3.478 X.628 Y-5.976 E28.68961
%G1 Z3.483 X1.249 Y-5.877 E28.71515
%G1 Z3.488 X1.858 Y-5.714 E28.74075
%G1 Z3.492 X2.347 Y-5.531 E28.76195
%G1 Z3.497 X2.914 Y-5.255 E28.78756
%G1 Z3.501 X3.36 Y-4.982 E28.8088
%G1 Z3.505 X3.781 Y-4.67 E28.83008
%G1 Z3.510 X4.249 Y-4.248 E28.85567
%G1 Z3.514 X4.602 Y-3.863 E28.87688
%G1 Z3.519 X4.981 Y-3.36 E28.90246
%G1 Z3.524 X5.306 Y-2.82 E28.92806
%G1 Z3.529 X5.544 Y-2.317 E28.95066
%G1 Z3.533 X5.746 Y-1.757 E28.97484
%G1 Z3.538 X5.898 Y-1.146 E29.00041
%G1 Z3.543 X5.979 Y-.595 E29.02303
%G1 Z3.548 X6.009 Y.001 E29.04727
%G1 Z3.552 X5.986 Y.523 E29.06849
%G1 Z3.557 X5.898 Y1.147 E29.09408
%G1 Z3.562 X5.746 Y1.758 E29.11965
%G1 Z3.566 X5.572 Y2.25 E29.14084
%G1 Z3.571 X5.305 Y2.821 E29.16644
%G1 Z3.575 X5.021 Y3.3 E29.18906
%G1 Z3.580 X4.67 Y3.781 E29.21324
%G1 Z3.585 X4.248 Y4.249 E29.23883
%G1 Z3.589 X3.863 Y4.602 E29.26004
%G1 Z3.594 X3.36 Y4.981 E29.28562
%G1 Z3.599 X2.821 Y5.305 E29.31116
%G1 Z3.604 X2.25 Y5.572 E29.33676
%G1 Z3.608 X1.758 Y5.746 E29.35795
%G1 Z3.613 X1.147 Y5.898 E29.38352
%G1 Z3.618 X.523 Y5.986 E29.40911
%G1 Z3.623 X0 Y6.009 E29.43037
%G1 Z3.627 X-.523 Y5.986 E29.45163
%G1 Z3.632 X-1.147 Y5.898 E29.47722
%G1 Z3.636 X-1.655 Y5.776 E29.49844
%G1 Z3.641 X-2.252 Y5.571 E29.52408
%G1 Z3.645 X-2.727 Y5.354 E29.54529
%G1 Z3.650 X-3.265 Y5.044 E29.57051
%;LAYER_CHANGE
%;Z:3.95
%;HEIGHT:0.3
%G1 Z3.650 F7800
%G1 F900
%G1 Z3.651 X-3.361 Y4.981 E29.57516
%G1 Z3.655 X-3.781 Y4.67 E29.59638
%G1 Z3.660 X-4.249 Y4.249 E29.62195
%G1 Z3.665 X-4.67 Y3.781 E29.64752
%G1 Z3.670 X-5.039 Y3.273 E29.67302
%G1 Z3.675 X-5.354 Y2.727 E29.69862
%G1 Z3.679 X-5.571 Y2.251 E29.71987
%G1 Z3.683 X-5.746 Y1.758 E29.74112
%G1 Z3.688 X-5.898 Y1.146 E29.76673
%G1 Z3.693 X-5.979 Y.592 E29.78947
%G1 Z3.698 X-6.009 Y-.001 E29.81358
%G1 Z3.702 X-5.986 Y-.523 E29.8348
%G1 Z3.707 X-5.898 Y-1.147 E29.86039
%G1 Z3.712 X-5.746 Y-1.757 E29.88592
%G1 Z3.716 X-5.557 Y-2.284 E29.90866
%G1 Z3.721 X-5.306 Y-2.821 E29.93273
%G1 Z3.726 X-4.981 Y-3.361 E29.95833
%G1 Z3.730 X-4.67 Y-3.781 E29.97955
%G1 Z3.735 X-4.248 Y-4.249 E30.00514
%G1 Z3.739 X-3.863 Y-4.602 E30.02635
%G1 Z3.744 X-3.36 Y-4.981 E30.05193
%G1 Z3.749 X-2.821 Y-5.305 E30.07747
%G1 Z3.754 X-2.25 Y-5.572 E30.10307
%G1 Z3.758 X-1.758 Y-5.746 E30.12426
%G1 Z3.763 X-1.147 Y-5.898 E30.14983
%G1 Z3.768 X-.523 Y-5.986 E30.17542
%G1 Z3.773 X.036 Y-6.008 E30.19814
%G1 Z3.778 X.628 Y-5.976 E30.22222
%G1 Z3.783 X1.25 Y-5.877 E30.2478
%G1 Z3.787 X1.756 Y-5.746 E30.26903
%G1 Z3.792 X2.349 Y-5.531 E30.29465
%G1 Z3.796 X2.82 Y-5.306 E30.31585
%G1 Z3.801 X3.361 Y-4.981 E30.34148
%G1 Z3.805 X3.781 Y-4.67 E30.3627
%G1 Z3.810 X4.249 Y-4.249 E30.38827
%G1 Z3.815 X4.67 Y-3.781 E30.41384
%G1 Z3.820 X5.001 Y-3.33 E30.43656
%G1 Z3.824 X5.305 Y-2.821 E30.46064
%G1 Z3.829 X5.572 Y-2.25 E30.48624
%G1 Z3.833 X5.746 Y-1.758 E30.50743
%G1 Z3.838 X5.899 Y-1.146 E30.53305
%G1 Z3.843 X5.976 Y-.629 E30.55428
%G1 Z3.848 X6.009 Y.001 E30.5799
%G1 Z3.852 X5.982 Y.559 E30.60259
%G1 Z3.857 X5.898 Y1.147 E30.62671
%G1 Z3.861 X5.776 Y1.655 E30.64793
%G1 Z3.866 X5.571 Y2.251 E30.67353
%G1 Z3.871 X5.305 Y2.821 E30.69908
%G1 Z3.876 X4.981 Y3.361 E30.72466
%G1 Z3.880 X4.67 Y3.781 E30.74588
%G1 Z3.885 X4.248 Y4.249 E30.77147
%G1 Z3.889 X3.863 Y4.602 E30.79268
%G1 Z3.894 X3.36 Y4.981 E30.81826
%G1 Z3.899 X2.82 Y5.306 E30.84386
%G1 Z3.903 X2.349 Y5.531 E30.86506
%G1 Z3.908 X1.757 Y5.746 E30.89064
%G1 Z3.913 X1.147 Y5.898 E30.91617
%G1 Z3.918 X.523 Y5.986 E30.94176
%G1 Z3.923 X0 Y6.009 E30.96302
%G1 Z3.927 X-.523 Y5.986 E30.98428
%G1 Z3.932 X-1.147 Y5.898 E31.00987
%G1 Z3.936 X-1.655 Y5.776 E31.03109
%G1 Z3.941 X-2.251 Y5.571 E31.05669
%G1 Z3.946 X-2.821 Y5.305 E31.08224
%G1 Z3.950 X-3.263 Y5.04 E31.10317
%;LAYER_CHANGE
%;Z:4.25
%;HEIGHT:0.3
%G1 Z3.950 F7800
%G1 F900
%G1 Z3.950 X-3.273 Y5.039 E31.10355
%G1 Z3.955 X-3.781 Y4.67 E31.12905
%G1 Z3.960 X-4.249 Y4.248 E31.15464
%G1 Z3.964 X-4.602 Y3.863 E31.17585
%G1 Z3.969 X-4.981 Y3.36 E31.20143
%G1 Z3.974 X-5.306 Y2.821 E31.22699
%G1 Z3.979 X-5.546 Y2.312 E31.24984
%G1 Z3.983 X-5.746 Y1.757 E31.2738
%G1 Z3.988 X-5.899 Y1.146 E31.29938
%G1 Z3.993 X-5.976 Y.629 E31.32061
%G1 Z3.998 X-6.009 Y0 E31.34619
%G1 Z4.002 X-5.982 Y-.562 E31.36904
%G1 Z4.007 X-5.898 Y-1.147 E31.39304
%G1 Z4.011 X-5.776 Y-1.655 E31.41426
%G1 Z4.016 X-5.571 Y-2.251 E31.43986
%G1 Z4.021 X-5.305 Y-2.821 E31.46541
%G1 Z4.025 X-5.018 Y-3.305 E31.48826
%G1 Z4.030 X-4.67 Y-3.781 E31.51221
%G1 Z4.035 X-4.249 Y-4.249 E31.53778
%G1 Z4.040 X-3.781 Y-4.67 E31.56335
%G1 Z4.045 X-3.328 Y-5.003 E31.58618
%G1 Z4.049 X-2.821 Y-5.305 E31.61015
%G1 Z4.054 X-2.251 Y-5.571 E31.6357
%G1 Z4.059 X-1.655 Y-5.776 E31.6613
%G1 Z4.063 X-1.147 Y-5.898 E31.68252
%G1 Z4.068 X-.523 Y-5.986 E31.70811
%G1 Z4.073 X.039 Y-6.008 E31.73095
%G1 Z4.078 X.628 Y-5.976 E31.75491
%G1 Z4.083 X1.25 Y-5.877 E31.78049
%G1 Z4.087 X1.756 Y-5.746 E31.80172
%G1 Z4.092 X2.349 Y-5.531 E31.82734
%G1 Z4.096 X2.82 Y-5.306 E31.84854
%G1 Z4.101 X3.361 Y-4.981 E31.87417
%G1 Z4.105 X3.781 Y-4.67 E31.89539
%G1 Z4.110 X4.249 Y-4.248 E31.92098
%G1 Z4.114 X4.602 Y-3.863 E31.94219
%G1 Z4.119 X4.981 Y-3.36 E31.96777
%G1 Z4.124 X5.306 Y-2.821 E31.99333
%G1 Z4.129 X5.546 Y-2.312 E32.01618
%G1 Z4.133 X5.746 Y-1.757 E32.04014
%G1 Z4.138 X5.899 Y-1.146 E32.06572
%G1 Z4.143 X5.976 Y-.629 E32.08695
%G1 Z4.148 X6.009 Y.001 E32.11257
%G1 Z4.152 X5.986 Y.523 E32.13379
%G1 Z4.157 X5.898 Y1.147 E32.15938
%G1 Z4.162 X5.746 Y1.758 E32.18495
%G1 Z4.166 X5.571 Y2.251 E32.2062
%G1 Z4.170 X5.354 Y2.727 E32.22745
%G1 Z4.175 X5.039 Y3.273 E32.25305
%G1 Z4.180 X4.67 Y3.781 E32.27855
%G1 Z4.185 X4.248 Y4.249 E32.30414
%G1 Z4.189 X3.863 Y4.602 E32.32535
%G1 Z4.194 X3.359 Y4.982 E32.35099
%G1 Z4.198 X2.914 Y5.255 E32.37219
%G1 Z4.203 X2.348 Y5.531 E32.39776
%G1 Z4.208 X1.757 Y5.746 E32.4233
%G1 Z4.213 X1.146 Y5.899 E32.44888
%G1 Z4.218 X.629 Y5.976 E32.47011
%G1 Z4.223 X-.001 Y6.009 E32.49573
%G1 Z4.227 X-.523 Y5.986 E32.51695
%G1 Z4.232 X-1.147 Y5.898 E32.54254
%G1 Z4.236 X-1.655 Y5.776 E32.56376
%G1 Z4.241 X-2.252 Y5.571 E32.5894
%G1 Z4.245 X-2.727 Y5.354 E32.61061
%G1 Z4.250 X-3.265 Y5.044 E32.63583
%;LAYER_CHANGE
%;Z:4.55
%;HEIGHT:0.3
%G1 Z4.250 F7800
%G1 F900
%G1 Z4.251 X-3.36 Y4.981 E32.64044
%G1 Z4.256 X-3.863 Y4.602 E32.66602
%G1 Z4.260 X-4.248 Y4.249 E32.68723
%G1 Z4.265 X-4.67 Y3.781 E32.71282
%G1 Z4.270 X-5.005 Y3.325 E32.7358
%G1 Z4.274 X-5.305 Y2.821 E32.75962
%G1 Z4.279 X-5.572 Y2.25 E32.78522
%G1 Z4.283 X-5.746 Y1.758 E32.80641
%G1 Z4.288 X-5.898 Y1.147 E32.83198
%G1 Z4.293 X-5.986 Y.523 E32.85757
%G1 Z4.298 X-6.009 Y0 E32.87883
%G1 Z4.302 X-5.986 Y-.523 E32.90009
%G1 Z4.307 X-5.898 Y-1.147 E32.92568
%G1 Z4.312 X-5.746 Y-1.757 E32.95121
%G1 Z4.316 X-5.555 Y-2.29 E32.9742
%G1 Z4.321 X-5.306 Y-2.821 E32.99802
%G1 Z4.326 X-4.981 Y-3.36 E33.02358
%G1 Z4.330 X-4.643 Y-3.814 E33.04657
%G1 Z4.335 X-4.249 Y-4.249 E33.07041
%G1 Z4.340 X-3.781 Y-4.67 E33.09598
%G1 Z4.345 X-3.325 Y-5.005 E33.11896
%G1 Z4.349 X-2.821 Y-5.305 E33.14278
%G1 Z4.354 X-2.25 Y-5.572 E33.16838
%G1 Z4.358 X-1.758 Y-5.746 E33.18957
%G1 Z4.363 X-1.147 Y-5.898 E33.21514
%G1 Z4.368 X-.523 Y-5.986 E33.24073
%G1 Z4.373 X.042 Y-6.008 E33.26369
%G1 Z4.378 X.628 Y-5.976 E33.28752
%G1 Z4.383 X1.25 Y-5.877 E33.3131
%G1 Z4.387 X1.756 Y-5.746 E33.33433
%G1 Z4.392 X2.348 Y-5.531 E33.35991
%G1 Z4.397 X2.914 Y-5.255 E33.38548
%G1 Z4.401 X3.36 Y-4.982 E33.40672
%G1 Z4.405 X3.814 Y-4.643 E33.42973
%G1 Z4.410 X4.249 Y-4.248 E33.45359
%G1 Z4.414 X4.602 Y-3.863 E33.4748
%G1 Z4.419 X4.981 Y-3.36 E33.50038
%G1 Z4.424 X5.306 Y-2.821 E33.52594
%G1 Z4.429 X5.547 Y-2.309 E33.54892
%G1 Z4.433 X5.746 Y-1.757 E33.57275
%G1 Z4.438 X5.899 Y-1.146 E33.59833
%G1 Z4.443 X5.976 Y-.629 E33.61956
%G1 Z4.448 X6.009 Y.001 E33.64518
%G1 Z4.452 X5.986 Y.523 E33.6664
%G1 Z4.457 X5.898 Y1.147 E33.69199
%G1 Z4.462 X5.746 Y1.758 E33.71756
%G1 Z4.466 X5.571 Y2.251 E33.73881
%G1 Z4.470 X5.354 Y2.727 E33.76006
%G1 Z4.475 X5.039 Y3.273 E33.78566
%G1 Z4.480 X4.67 Y3.781 E33.81116
%G1 Z4.485 X4.249 Y4.249 E33.83673
%G1 Z4.490 X3.83 Y4.63 E33.85973
%G1 Z4.494 X3.36 Y4.981 E33.88355
%G1 Z4.499 X2.82 Y5.306 E33.90915
%G1 Z4.503 X2.349 Y5.531 E33.93035
%G1 Z4.508 X1.757 Y5.746 E33.95593
%G1 Z4.513 X1.146 Y5.898 E33.9815
%G1 Z4.518 X.587 Y5.98 E34.00445
%G1 Z4.523 X-.001 Y6.009 E34.02836
%G1 Z4.527 X-.523 Y5.986 E34.04958
%G1 Z4.532 X-1.147 Y5.898 E34.07517
%G1 Z4.536 X-1.655 Y5.776 E34.09639
%G1 Z4.541 X-2.251 Y5.571 E34.12199
%G1 Z4.546 X-2.821 Y5.305 E34.14754
%G1 Z4.550 X-3.263 Y5.04 E34.16847
%;LAYER_CHANGE
%;Z:4.85
%;HEIGHT:0.3
%G1 Z4.550 F7800
%G1 F900
%G1 Z4.551 X-3.361 Y4.981 E34.17312
%G1 Z4.555 X-3.781 Y4.67 E34.19434
%G1 Z4.560 X-4.249 Y4.249 E34.21991
%G1 Z4.565 X-4.631 Y3.828 E34.243
%G1 Z4.569 X-4.982 Y3.36 E34.26676
%G1 Z4.574 X-5.277 Y2.874 E34.28985
%G1 Z4.578 X-5.531 Y2.347 E34.31361
%G1 Z4.583 X-5.714 Y1.858 E34.33481
%G1 Z4.588 X-5.877 Y1.249 E34.36041
%G1 Z4.593 X-5.976 Y.628 E34.38595
%G1 Z4.598 X-6.009 Y-.001 E34.41153
%G1 Z4.602 X-5.986 Y-.523 E34.43275
%G1 Z4.607 X-5.898 Y-1.147 E34.45834
%G1 Z4.612 X-5.746 Y-1.757 E34.48387
%G1 Z4.616 X-5.554 Y-2.292 E34.50695
%G1 Z4.621 X-5.306 Y-2.821 E34.53068
%G1 Z4.626 X-4.981 Y-3.36 E34.55624
%G1 Z4.631 X-4.602 Y-3.863 E34.58182
%G1 Z4.635 X-4.249 Y-4.248 E34.60303
%G1 Z4.640 X-3.781 Y-4.67 E34.62862
%G1 Z4.645 X-3.323 Y-5.006 E34.65169
%G1 Z4.649 X-2.821 Y-5.305 E34.67542
%G1 Z4.654 X-2.25 Y-5.572 E34.70102
%G1 Z4.658 X-1.758 Y-5.746 E34.72221
%G1 Z4.663 X-1.147 Y-5.898 E34.74778
%G1 Z4.668 X-.523 Y-5.986 E34.77337
%G1 Z4.673 X.045 Y-6.008 E34.79646
%G1 Z4.678 X.628 Y-5.976 E34.82017
%G1 Z4.683 X1.25 Y-5.877 E34.84575
%G1 Z4.687 X1.756 Y-5.746 E34.86698
%G1 Z4.692 X2.349 Y-5.531 E34.8926
%G1 Z4.696 X2.82 Y-5.306 E34.9138
%G1 Z4.701 X3.361 Y-4.981 E34.93943
%G1 Z4.705 X3.781 Y-4.67 E34.96065
%G1 Z4.710 X4.249 Y-4.249 E34.98622
%G1 Z4.715 X4.631 Y-3.828 E35.00931
%G1 Z4.719 X4.982 Y-3.36 E35.03307
%G1 Z4.723 X5.255 Y-2.914 E35.05431
%G1 Z4.728 X5.531 Y-2.348 E35.07988
%G1 Z4.733 X5.746 Y-1.756 E35.10546
%G1 Z4.738 X5.877 Y-1.25 E35.12669
%G1 Z4.743 X5.976 Y-.628 E35.15227
%G1 Z4.748 X6.009 Y.001 E35.17785
%G1 Z4.752 X5.986 Y.523 E35.19907
%G1 Z4.757 X5.898 Y1.147 E35.22466
%G1 Z4.761 X5.776 Y1.655 E35.24588
%G1 Z4.766 X5.571 Y2.251 E35.27148
%G1 Z4.771 X5.305 Y2.821 E35.29703
%G1 Z4.776 X4.981 Y3.361 E35.32261
%G1 Z4.780 X4.67 Y3.781 E35.34383
%G1 Z4.785 X4.249 Y4.249 E35.3694
%G1 Z4.790 X3.781 Y4.67 E35.39497
%G1 Z4.794 X3.36 Y4.982 E35.41625
%G1 Z4.798 X2.914 Y5.255 E35.43749
%G1 Z4.803 X2.348 Y5.531 E35.46306
%G1 Z4.808 X1.757 Y5.746 E35.4886
%G1 Z4.813 X1.147 Y5.898 E35.51413
%G1 Z4.818 X.523 Y5.986 E35.53972
%G1 Z4.823 X0 Y6.009 E35.56098
%G1 Z4.827 X-.523 Y5.986 E35.58224
%G1 Z4.832 X-1.147 Y5.898 E35.60783
%G1 Z4.836 X-1.655 Y5.776 E35.62905
%G1 Z4.841 X-2.251 Y5.571 E35.65465
%G1 Z4.846 X-2.821 Y5.305 E35.6802
%G1 Z4.850 X-3.263 Y5.04 E35.70113
%;LAYER_CHANGE
%;Z:5.15
%;HEIGHT:0.3
%G1 Z4.850 F7800
%G1 F900
%G1 Z4.850 X-3.312 Y5.013 E35.70341
%G1 Z4.855 X-3.781 Y4.67 E35.72701
%G1 Z4.860 X-4.249 Y4.249 E35.75258
%G1 Z4.865 X-4.67 Y3.781 E35.77815
%G1 Z4.869 X-4.981 Y3.361 E35.79937
%G1 Z4.874 X-5.306 Y2.821 E35.82497
%G1 Z4.879 X-5.549 Y2.304 E35.84817
%G1 Z4.883 X-5.746 Y1.757 E35.87178
%G1 Z4.888 X-5.898 Y1.146 E35.89735
%G1 Z4.893 X-5.98 Y.581 E35.92054
%G1 Z4.898 X-6.009 Y-.001 E35.94421
%G1 Z4.902 X-5.986 Y-.523 E35.96543
%G1 Z4.907 X-5.898 Y-1.147 E35.99102
%G1 Z4.912 X-5.746 Y-1.758 E36.01659
%G1 Z4.916 X-5.572 Y-2.25 E36.03778
%G1 Z4.921 X-5.305 Y-2.821 E36.06338
%G1 Z4.926 X-4.981 Y-3.361 E36.08896
%G1 Z4.930 X-4.67 Y-3.781 E36.11018
%G1 Z4.935 X-4.248 Y-4.249 E36.13577
%G1 Z4.939 X-3.863 Y-4.602 E36.15698
%G1 Z4.944 X-3.36 Y-4.981 E36.18256
%G1 Z4.949 X-2.821 Y-5.305 E36.2081
%G1 Z4.954 X-2.251 Y-5.571 E36.23365
%G1 Z4.959 X-1.655 Y-5.776 E36.25925
%G1 Z4.963 X-1.147 Y-5.898 E36.28047
%G1 Z4.968 X-.523 Y-5.986 E36.30606
%G1 Z4.973 X.048 Y-6.008 E36.32927
%G1 Z4.978 X.628 Y-5.976 E36.35286
%G1 Z4.983 X1.249 Y-5.877 E36.3784
%G1 Z4.988 X1.858 Y-5.714 E36.404
%G1 Z4.992 X2.347 Y-5.531 E36.4252
%G1 Z4.997 X2.914 Y-5.255 E36.45081
%G1 Z5.001 X3.36 Y-4.982 E36.47205
%G1 Z5.005 X3.818 Y-4.639 E36.49529
%G1 Z5.010 X4.249 Y-4.248 E36.51892
%G1 Z5.014 X4.602 Y-3.863 E36.54013
%G1 Z5.019 X4.981 Y-3.36 E36.56571
%G1 Z5.024 X5.306 Y-2.821 E36.59127
%G1 Z5.029 X5.549 Y-2.304 E36.61447
%G1 Z5.033 X5.746 Y-1.757 E36.63808
%G1 Z5.038 X5.899 Y-1.146 E36.66366
%G1 Z5.043 X5.976 Y-.629 E36.68489
%G1 Z5.048 X6.009 Y0 E36.71047
%G1 Z5.052 X5.981 Y.571 E36.73369
%G1 Z5.057 X5.898 Y1.146 E36.75728
%G1 Z5.062 X5.746 Y1.758 E36.78289
%G1 Z5.066 X5.572 Y2.25 E36.80408
%G1 Z5.071 X5.305 Y2.821 E36.82968
%G1 Z5.076 X4.981 Y3.36 E36.85522
%G1 Z5.080 X4.639 Y3.818 E36.87843
%G1 Z5.085 X4.248 Y4.249 E36.90206
%G1 Z5.089 X3.863 Y4.602 E36.92327
%G1 Z5.094 X3.36 Y4.981 E36.94885
%G1 Z5.099 X2.821 Y5.305 E36.97439
%G1 Z5.104 X2.25 Y5.572 E36.99999
%G1 Z5.108 X1.758 Y5.746 E37.02118
%G1 Z5.113 X1.146 Y5.898 E37.04679
%G1 Z5.118 X.581 Y5.98 E37.06998
%G1 Z5.123 X-.001 Y6.009 E37.09365
%G1 Z5.127 X-.523 Y5.986 E37.11487
%G1 Z5.132 X-1.147 Y5.898 E37.14046
%G1 Z5.137 X-1.758 Y5.746 E37.16603
%G1 Z5.141 X-2.25 Y5.572 E37.18722
%G1 Z5.146 X-2.821 Y5.305 E37.21282
%G1 Z5.150 X-3.264 Y5.042 E37.23374
%;LAYER_CHANGE
%;Z:5.45
%;HEIGHT:0.3
%G1 Z5.150 F7800
%G1 F900
%G1 Z5.150 X-3.273 Y5.039 E37.23412
%G1 Z5.155 X-3.781 Y4.67 E37.25962
%G1 Z5.160 X-4.249 Y4.249 E37.28519
%G1 Z5.165 X-4.635 Y3.823 E37.30854
%G1 Z5.169 X-4.981 Y3.36 E37.33201
%G1 Z5.174 X-5.306 Y2.821 E37.35757
%G1 Z5.179 X-5.55 Y2.301 E37.3809
%G1 Z5.183 X-5.746 Y1.757 E37.40438
%G1 Z5.188 X-5.898 Y1.147 E37.42991
%G1 Z5.193 X-5.986 Y.523 E37.4555
%G1 Z5.198 X-6.009 Y0 E37.47676
%G1 Z5.202 X-5.986 Y-.523 E37.49802
%G1 Z5.207 X-5.898 Y-1.147 E37.52361
%G1 Z5.211 X-5.776 Y-1.655 E37.54483
%G1 Z5.216 X-5.571 Y-2.251 E37.57043
%G1 Z5.220 X-5.331 Y-2.773 E37.59376
%G1 Z5.225 X-5.04 Y-3.272 E37.61722
%G1 Z5.230 X-4.67 Y-3.781 E37.64278
%G1 Z5.235 X-4.249 Y-4.249 E37.66835
%G1 Z5.240 X-3.781 Y-4.67 E37.69392
%G1 Z5.245 X-3.318 Y-5.009 E37.71723
%G1 Z5.249 X-2.821 Y-5.305 E37.74072
%G1 Z5.254 X-2.25 Y-5.572 E37.76632
%G1 Z5.258 X-1.758 Y-5.746 E37.78751
%G1 Z5.263 X-1.147 Y-5.898 E37.81308
%G1 Z5.268 X-.523 Y-5.986 E37.83867
%G1 Z5.273 X.05 Y-6.008 E37.86196
%G1 Z5.278 X.628 Y-5.976 E37.88547
%G1 Z5.283 X1.25 Y-5.877 E37.91105
%G1 Z5.287 X1.756 Y-5.746 E37.93228
%G1 Z5.292 X2.349 Y-5.531 E37.9579
%G1 Z5.296 X2.82 Y-5.306 E37.9791
%G1 Z5.301 X3.36 Y-4.981 E38.0047
%G1 Z5.306 X3.863 Y-4.602 E38.03028
%G1 Z5.310 X4.249 Y-4.249 E38.05152
%G1 Z5.314 X4.602 Y-3.863 E38.07276
%G1 Z5.319 X4.982 Y-3.359 E38.0984
%G1 Z5.323 X5.255 Y-2.914 E38.1196
%G1 Z5.328 X5.531 Y-2.348 E38.14517
%G1 Z5.333 X5.746 Y-1.756 E38.17075
%G1 Z5.338 X5.877 Y-1.25 E38.19198
%G1 Z5.343 X5.976 Y-.628 E38.21756
%G1 Z5.348 X6.009 Y.001 E38.24314
%G1 Z5.352 X5.986 Y.523 E38.26436
%G1 Z5.357 X5.898 Y1.147 E38.28995
%G1 Z5.362 X5.746 Y1.758 E38.31552
%G1 Z5.366 X5.572 Y2.25 E38.33671
%G1 Z5.371 X5.305 Y2.821 E38.36231
%G1 Z5.376 X4.981 Y3.36 E38.38785
%G1 Z5.381 X4.602 Y3.863 E38.41343
%G1 Z5.385 X4.249 Y4.249 E38.43467
%G1 Z5.390 X3.823 Y4.635 E38.45802
%G1 Z5.394 X3.36 Y4.981 E38.48149
%G1 Z5.399 X2.821 Y5.306 E38.50705
%G1 Z5.404 X2.301 Y5.55 E38.53038
%G1 Z5.408 X1.757 Y5.746 E38.55386
%G1 Z5.413 X1.146 Y5.898 E38.57943
%G1 Z5.418 X.578 Y5.981 E38.60274
%G1 Z5.423 X0 Y6.009 E38.62624
%G1 Z5.427 X-.523 Y5.986 E38.6475
%G1 Z5.432 X-1.147 Y5.898 E38.67309
%G1 Z5.436 X-1.655 Y5.776 E38.69431
%G1 Z5.441 X-2.252 Y5.571 E38.71995
%G1 Z5.445 X-2.727 Y5.354 E38.74116
%G1 Z5.450 X-3.265 Y5.044 E38.76638
%;LAYER_CHANGE
%;Z:5.75
%;HEIGHT:0.3
%G1 Z5.450 F7800
%G1 F900
%G1 Z5.451 X-3.359 Y4.982 E38.77096
%G1 Z5.456 X-3.862 Y4.603 E38.79654
%G1 Z5.461 X-4.323 Y4.173 E38.82214
%G1 Z5.465 X-4.669 Y3.782 E38.84334
%G1 Z5.470 X-5.039 Y3.273 E38.8689
%G1 Z5.475 X-5.354 Y2.727 E38.8945
%G1 Z5.479 X-5.571 Y2.252 E38.91571
%G1 Z5.484 X-5.776 Y1.656 E38.94131
%G1 Z5.489 X-5.908 Y1.094 E38.96476
%G1 Z5.493 X-5.986 Y.524 E38.98813
%G1 Z5.498 X-6.008 Y-.105 E39.01369
%G1 Z5.503 X-5.964 Y-.733 E39.03926
%G1 Z5.508 X-5.878 Y-1.249 E39.06051
%G1 Z5.512 X-5.746 Y-1.756 E39.08179
%G1 Z5.517 X-5.531 Y-2.348 E39.10737
%G1 Z5.522 X-5.255 Y-2.913 E39.13291
%G1 Z5.526 X-4.951 Y-3.404 E39.15636
%G1 Z5.531 X-4.603 Y-3.862 E39.17972
%G1 Z5.536 X-4.173 Y-4.323 E39.20532
%G1 Z5.540 X-3.782 Y-4.669 E39.22652
%G1 Z5.545 X-3.272 Y-5.04 E39.25213
%G1 Z5.549 X-2.822 Y-5.305 E39.27334
%G1 Z5.554 X-2.25 Y-5.572 E39.29898
%G1 Z5.558 X-1.758 Y-5.746 E39.32017
%G1 Z5.563 X-1.147 Y-5.898 E39.34574
%G1 Z5.568 X-.523 Y-5.986 E39.37133
%G1 Z5.573 X.053 Y-6.008 E39.39474
%G1 Z5.578 X.628 Y-5.976 E39.41813
%G1 Z5.583 X1.25 Y-5.877 E39.44371
%G1 Z5.587 X1.756 Y-5.746 E39.46494
%G1 Z5.592 X2.348 Y-5.531 E39.49052
%G1 Z5.596 X2.868 Y-5.28 E39.51397
%G1 Z5.601 X3.36 Y-4.982 E39.53733
%G1 Z5.606 X3.862 Y-4.603 E39.56288
%G1 Z5.611 X4.323 Y-4.173 E39.58848
%G1 Z5.615 X4.669 Y-3.782 E39.60968
%G1 Z5.620 X5.039 Y-3.273 E39.63524
%G1 Z5.625 X5.354 Y-2.727 E39.66084
%G1 Z5.629 X5.571 Y-2.252 E39.68205
%G1 Z5.634 X5.776 Y-1.655 E39.70769
%G1 Z5.638 X5.898 Y-1.147 E39.72891
%G1 Z5.643 X5.986 Y-.524 E39.75446
%G1 Z5.648 X6.008 Y.105 E39.78002
%G1 Z5.653 X5.964 Y.733 E39.80559
%G1 Z5.658 X5.878 Y1.248 E39.8268
%G1 Z5.663 X5.715 Y1.857 E39.8524
%G1 Z5.667 X5.51 Y2.397 E39.87586
%G1 Z5.672 X5.256 Y2.913 E39.89922
%G1 Z5.677 X4.922 Y3.447 E39.9248
%G1 Z5.681 X4.604 Y3.862 E39.94603
%G1 Z5.686 X4.173 Y4.323 E39.97166
%G1 Z5.690 X3.782 Y4.669 E39.99286
%G1 Z5.695 X3.272 Y5.04 E40.01847
%G1 Z5.699 X2.822 Y5.305 E40.03968
%G1 Z5.704 X2.25 Y5.572 E40.06532
%G1 Z5.708 X1.758 Y5.746 E40.08651
%G1 Z5.713 X1.147 Y5.898 E40.11208
%G1 Z5.718 X.524 Y5.986 E40.13763
%G1 Z5.723 X-.105 Y6.008 E40.16319
%G1 Z5.728 X-.733 Y5.964 E40.18876
%G1 Z5.733 X-1.249 Y5.878 E40.21001
%G1 Z5.737 X-1.756 Y5.746 E40.23129
%G1 Z5.742 X-2.348 Y5.531 E40.25687
%G1 Z5.747 X-2.914 Y5.255 E40.28244
%G1 Z5.750 X-3.263 Y5.041 E40.29907
%;LAYER_CHANGE
%;Z:6.05
%;HEIGHT:0.3
%G1 Z5.750 F7800
%G1 F900
%G1 Z5.751 X-3.359 Y4.982 E40.30365
%G1 Z5.756 X-3.862 Y4.603 E40.32923
%G1 Z5.761 X-4.323 Y4.174 E40.35481
%G1 Z5.766 X-4.705 Y3.737 E40.37838
%G1 Z5.770 X-5.04 Y3.272 E40.40166
%G1 Z5.774 X-5.305 Y2.822 E40.42287
%G1 Z5.779 X-5.572 Y2.25 E40.44851
%G1 Z5.783 X-5.746 Y1.758 E40.4697
%G1 Z5.788 X-5.898 Y1.147 E40.49527
%G1 Z5.793 X-5.986 Y.524 E40.52082
%G1 Z5.798 X-6.008 Y-.105 E40.54638
%G1 Z5.803 X-5.964 Y-.733 E40.57195
%G1 Z5.808 X-5.878 Y-1.249 E40.5932
%G1 Z5.812 X-5.746 Y-1.756 E40.61448
%G1 Z5.817 X-5.531 Y-2.348 E40.64006
%G1 Z5.821 X-5.279 Y-2.87 E40.6636
%G1 Z5.826 X-4.982 Y-3.36 E40.68687
%G1 Z5.831 X-4.603 Y-3.862 E40.71242
%G1 Z5.836 X-4.173 Y-4.323 E40.73802
%G1 Z5.840 X-3.782 Y-4.669 E40.75922
%G1 Z5.845 X-3.272 Y-5.04 E40.78483
%G1 Z5.850 X-2.771 Y-5.331 E40.80836
%G1 Z5.854 X-2.251 Y-5.571 E40.83162
%G1 Z5.858 X-1.758 Y-5.746 E40.85287
%G1 Z5.863 X-1.147 Y-5.898 E40.87844
%G1 Z5.868 X-.523 Y-5.986 E40.90403
%G1 Z5.873 X.056 Y-6.008 E40.92756
%G1 Z5.878 X.628 Y-5.976 E40.95083
%G1 Z5.883 X1.25 Y-5.877 E40.97641
%G1 Z5.887 X1.756 Y-5.746 E40.99764
%G1 Z5.892 X2.348 Y-5.531 E41.02322
%G1 Z5.897 X2.913 Y-5.255 E41.04876
%G1 Z5.901 X3.406 Y-4.95 E41.0723
%G1 Z5.906 X3.862 Y-4.603 E41.09557
%G1 Z5.911 X4.323 Y-4.173 E41.12117
%G1 Z5.915 X4.669 Y-3.782 E41.14237
%G1 Z5.920 X5.04 Y-3.272 E41.16798
%G1 Z5.924 X5.305 Y-2.822 E41.18919
%G1 Z5.929 X5.572 Y-2.25 E41.21483
%G1 Z5.933 X5.746 Y-1.758 E41.23602
%G1 Z5.938 X5.898 Y-1.147 E41.26159
%G1 Z5.943 X5.986 Y-.524 E41.28714
%G1 Z5.948 X6.008 Y.105 E41.3127
%G1 Z5.953 X5.964 Y.733 E41.33827
%G1 Z5.958 X5.878 Y1.248 E41.35948
%G1 Z5.963 X5.715 Y1.857 E41.38508
%G1 Z5.967 X5.509 Y2.399 E41.40863
%G1 Z5.972 X5.256 Y2.913 E41.4319
%G1 Z5.977 X4.922 Y3.447 E41.45748
%G1 Z5.981 X4.604 Y3.862 E41.47871
%G1 Z5.986 X4.174 Y4.322 E41.50428
%G1 Z5.991 X3.699 Y4.736 E41.52987
%G1 Z5.995 X3.273 Y5.039 E41.5511
%G1 Z6.000 X2.727 Y5.354 E41.5767
%G1 Z6.004 X2.251 Y5.571 E41.59795
%G1 Z6.008 X1.758 Y5.746 E41.6192
%G1 Z6.013 X1.147 Y5.898 E41.64477
%G1 Z6.018 X.524 Y5.986 E41.67032
%G1 Z6.023 X-.105 Y6.008 E41.69588
%G1 Z6.028 X-.684 Y5.969 E41.71945
%G1 Z6.033 X-1.249 Y5.878 E41.74269
%G1 Z6.038 X-1.858 Y5.714 E41.7683
%G1 Z6.042 X-2.347 Y5.531 E41.7895
%G1 Z6.047 X-2.914 Y5.255 E41.81511
%G1 Z6.050 X-3.263 Y5.041 E41.83174
%;LAYER_CHANGE
%;Z:6.35
%;HEIGHT:0.3
%G1 Z6.050 F7800
%G1 F900
%G1 Z6.051 X-3.359 Y4.982 E41.83632
%G1 Z6.056 X-3.862 Y4.603 E41.8619
%G1 Z6.061 X-4.323 Y4.174 E41.88748
%G1 Z6.066 X-4.707 Y3.735 E41.91117
%G1 Z6.070 X-5.04 Y3.272 E41.93433
%G1 Z6.074 X-5.305 Y2.822 E41.95554
%G1 Z6.079 X-5.572 Y2.25 E41.98118
%G1 Z6.083 X-5.746 Y1.758 E42.00237
%G1 Z6.088 X-5.898 Y1.147 E42.02794
%G1 Z6.093 X-5.986 Y.524 E42.05349
%G1 Z6.098 X-6.008 Y-.105 E42.07905
%G1 Z6.103 X-5.969 Y-.687 E42.10274
%G1 Z6.108 X-5.878 Y-1.249 E42.12586
%G1 Z6.113 X-5.715 Y-1.857 E42.15142
%G1 Z6.117 X-5.507 Y-2.402 E42.17511
%G1 Z6.122 X-5.256 Y-2.913 E42.19823
%G1 Z6.127 X-4.922 Y-3.447 E42.22381
%G1 Z6.131 X-4.604 Y-3.862 E42.24504
%G1 Z6.136 X-4.174 Y-4.323 E42.27064
%G1 Z6.141 X-3.735 Y-4.707 E42.29433
%G1 Z6.145 X-3.272 Y-5.04 E42.31749
%G1 Z6.149 X-2.822 Y-5.305 E42.3387
%G1 Z6.154 X-2.25 Y-5.572 E42.36434
%G1 Z6.158 X-1.758 Y-5.746 E42.38553
%G1 Z6.163 X-1.147 Y-5.898 E42.4111
%G1 Z6.168 X-.523 Y-5.986 E42.43669
%G1 Z6.173 X.059 Y-6.008 E42.46034
%G1 Z6.178 X.628 Y-5.976 E42.48349
%G1 Z6.183 X1.25 Y-5.877 E42.50907
%G1 Z6.187 X1.756 Y-5.746 E42.5303
%G1 Z6.192 X2.348 Y-5.531 E42.55588
%G1 Z6.197 X2.914 Y-5.255 E42.58145
%G1 Z6.201 X3.359 Y-4.982 E42.60265
%G1 Z6.206 X3.862 Y-4.603 E42.62823
%G1 Z6.211 X4.323 Y-4.173 E42.65383
%G1 Z6.215 X4.669 Y-3.782 E42.67503
%G1 Z6.220 X5.039 Y-3.273 E42.70059
%G1 Z6.225 X5.354 Y-2.727 E42.72619
%G1 Z6.229 X5.571 Y-2.251 E42.74744
%G1 Z6.233 X5.746 Y-1.758 E42.76869
%G1 Z6.238 X5.898 Y-1.147 E42.79426
%G1 Z6.243 X5.986 Y-.524 E42.81981
%G1 Z6.248 X6.008 Y.105 E42.84537
%G1 Z6.253 X5.964 Y.733 E42.87094
%G1 Z6.258 X5.878 Y1.248 E42.89215
%G1 Z6.263 X5.715 Y1.857 E42.91775
%G1 Z6.267 X5.507 Y2.402 E42.94144
%G1 Z6.272 X5.256 Y2.913 E42.96456
%G1 Z6.277 X4.922 Y3.446 E42.99011
%G1 Z6.282 X4.534 Y3.943 E43.01572
%G1 Z6.286 X4.175 Y4.322 E43.03692
%G1 Z6.291 X3.699 Y4.735 E43.06251
%G1 Z6.295 X3.273 Y5.039 E43.08376
%G1 Z6.299 X2.822 Y5.305 E43.10502
%G1 Z6.304 X2.25 Y5.572 E43.13066
%G1 Z6.308 X1.758 Y5.746 E43.15185
%G1 Z6.313 X1.147 Y5.898 E43.17742
%G1 Z6.318 X.524 Y5.986 E43.20297
%G1 Z6.323 X-.106 Y6.008 E43.22857
%G1 Z6.328 X-.627 Y5.976 E43.24977
%G1 Z6.333 X-1.249 Y5.877 E43.27535
%G1 Z6.338 X-1.858 Y5.714 E43.30095
%G1 Z6.342 X-2.347 Y5.531 E43.32215
%G1 Z6.347 X-2.914 Y5.255 E43.34776
%G1 Z6.350 X-3.263 Y5.041 E43.36439
%;LAYER_CHANGE
%;Z:6.65
%;HEIGHT:0.3
%G1 Z6.350 F7800
%G1 F900
%G1 Z6.352 X-3.446 Y4.922 E43.37326
%G1 Z6.357 X-3.943 Y4.534 E43.39887
%G1 Z6.361 X-4.322 Y4.174 E43.4201
%G1 Z6.365 X-4.669 Y3.782 E43.44136
%G1 Z6.370 X-5.04 Y3.272 E43.46697
%G1 Z6.374 X-5.305 Y2.822 E43.48818
%G1 Z6.379 X-5.572 Y2.25 E43.51382
%G1 Z6.383 X-5.746 Y1.758 E43.53501
%G1 Z6.388 X-5.898 Y1.147 E43.56058
%G1 Z6.393 X-5.986 Y.524 E43.58613
%G1 Z6.398 X-6.008 Y-.105 E43.61169
%G1 Z6.403 X-5.964 Y-.733 E43.63726
%G1 Z6.408 X-5.864 Y-1.31 E43.66104
%G1 Z6.413 X-5.715 Y-1.856 E43.68403
%G1 Z6.418 X-5.489 Y-2.444 E43.70961
%G1 Z6.422 X-5.225 Y-2.967 E43.7334
%G1 Z6.427 X-4.922 Y-3.447 E43.75645
%G1 Z6.431 X-4.604 Y-3.862 E43.77768
%G1 Z6.436 X-4.174 Y-4.323 E43.80328
%G1 Z6.441 X-3.733 Y-4.708 E43.82706
%G1 Z6.445 X-3.272 Y-5.04 E43.85013
%G1 Z6.449 X-2.822 Y-5.305 E43.87134
%G1 Z6.454 X-2.25 Y-5.572 E43.89698
%G1 Z6.458 X-1.758 Y-5.746 E43.91817
%G1 Z6.463 X-1.147 Y-5.898 E43.94374
%G1 Z6.468 X-.523 Y-5.986 E43.96933
%G1 Z6.473 X.062 Y-6.008 E43.99311
%G1 Z6.478 X.628 Y-5.976 E44.01613
%G1 Z6.483 X1.25 Y-5.877 E44.04171
%G1 Z6.487 X1.756 Y-5.746 E44.06294
%G1 Z6.492 X2.348 Y-5.531 E44.08852
%G1 Z6.497 X2.914 Y-5.255 E44.11409
%G1 Z6.501 X3.359 Y-4.982 E44.13529
%G1 Z6.506 X3.862 Y-4.603 E44.16087
%G1 Z6.511 X4.323 Y-4.173 E44.18647
%G1 Z6.515 X4.669 Y-3.782 E44.20767
%G1 Z6.520 X5.04 Y-3.272 E44.23328
%G1 Z6.524 X5.305 Y-2.822 E44.25449
%G1 Z6.529 X5.572 Y-2.25 E44.28013
%G1 Z6.533 X5.746 Y-1.758 E44.30132
%G1 Z6.538 X5.898 Y-1.147 E44.32689
%G1 Z6.543 X5.986 Y-.524 E44.35244
%G1 Z6.548 X6.008 Y.105 E44.378
%G1 Z6.553 X5.964 Y.733 E44.40357
%G1 Z6.558 X5.878 Y1.248 E44.42478
%G1 Z6.563 X5.715 Y1.857 E44.45038
%G1 Z6.567 X5.506 Y2.405 E44.4742
%G1 Z6.572 X5.256 Y2.913 E44.49719
%G1 Z6.577 X4.922 Y3.446 E44.52274
%G1 Z6.582 X4.534 Y3.943 E44.54835
%G1 Z6.586 X4.174 Y4.322 E44.56958
%G1 Z6.590 X3.782 Y4.669 E44.59084
%G1 Z6.595 X3.273 Y5.039 E44.6164
%G1 Z6.600 X2.727 Y5.354 E44.642
%G1 Z6.604 X2.252 Y5.571 E44.66321
%G1 Z6.609 X1.656 Y5.776 E44.68881
%G1 Z6.614 X1.085 Y5.91 E44.71263
%G1 Z6.618 X.524 Y5.986 E44.73562
%G1 Z6.623 X-.105 Y6.008 E44.76118
%G1 Z6.628 X-.733 Y5.964 E44.78675
%G1 Z6.633 X-1.248 Y5.878 E44.80796
%G1 Z6.638 X-1.857 Y5.715 E44.83356
%G1 Z6.643 X-2.445 Y5.489 E44.85914
%G1 Z6.647 X-2.912 Y5.256 E44.88034
%G1 Z6.650 X-3.261 Y5.038 E44.89705
%;LAYER_CHANGE
%;Z:6.95
%;HEIGHT:0.3
%G1 Z6.650 F7800
%G1 F900
%G1 Z6.651 X-3.359 Y4.982 E44.90163
%G1 Z6.656 X-3.862 Y4.603 E44.92721
%G1 Z6.661 X-4.323 Y4.173 E44.95281
%G1 Z6.665 X-4.669 Y3.782 E44.97401
%G1 Z6.670 X-5.04 Y3.272 E44.99962
%G1 Z6.674 X-5.305 Y2.822 E45.02083
%G1 Z6.679 X-5.572 Y2.25 E45.04647
%G1 Z6.683 X-5.746 Y1.758 E45.06766
%G1 Z6.688 X-5.898 Y1.147 E45.09323
%G1 Z6.693 X-5.986 Y.524 E45.11878
%G1 Z6.698 X-6.008 Y-.105 E45.14434
%G1 Z6.703 X-5.964 Y-.733 E45.16991
%G1 Z6.708 X-5.878 Y-1.248 E45.19112
%G1 Z6.713 X-5.715 Y-1.857 E45.21672
%G1 Z6.717 X-5.505 Y-2.407 E45.24063
%G1 Z6.722 X-5.256 Y-2.913 E45.26353
%G1 Z6.727 X-4.922 Y-3.447 E45.28911
%G1 Z6.731 X-4.604 Y-3.862 E45.31034
%G1 Z6.736 X-4.173 Y-4.323 E45.33597
%G1 Z6.740 X-3.782 Y-4.669 E45.35717
%G1 Z6.745 X-3.272 Y-5.04 E45.38278
%G1 Z6.750 X-2.763 Y-5.335 E45.40667
%G1 Z6.754 X-2.251 Y-5.571 E45.42957
%G1 Z6.758 X-1.758 Y-5.746 E45.45082
%G1 Z6.763 X-1.147 Y-5.898 E45.47639
%G1 Z6.768 X-.523 Y-5.986 E45.50198
%G1 Z6.773 X.065 Y-6.008 E45.52588
%G1 Z6.778 X.628 Y-5.976 E45.54878
%G1 Z6.783 X1.25 Y-5.877 E45.57436
%G1 Z6.787 X1.756 Y-5.746 E45.59559
%G1 Z6.792 X2.348 Y-5.531 E45.62117
%G1 Z6.797 X2.914 Y-5.255 E45.64674
%G1 Z6.801 X3.359 Y-4.982 E45.66794
%G1 Z6.806 X3.862 Y-4.603 E45.69352
%G1 Z6.811 X4.323 Y-4.173 E45.71912
%G1 Z6.815 X4.669 Y-3.782 E45.74032
%G1 Z6.820 X5.039 Y-3.273 E45.76588
%G1 Z6.825 X5.354 Y-2.727 E45.79148
%G1 Z6.829 X5.571 Y-2.251 E45.81273
%G1 Z6.833 X5.746 Y-1.758 E45.83398
%G1 Z6.838 X5.898 Y-1.147 E45.85955
%G1 Z6.843 X5.986 Y-.524 E45.8851
%G1 Z6.848 X6.008 Y.105 E45.91066
%G1 Z6.853 X5.964 Y.733 E45.93623
%G1 Z6.858 X5.878 Y1.248 E45.95744
%G1 Z6.863 X5.715 Y1.857 E45.98304
%G1 Z6.867 X5.505 Y2.407 E46.00695
%G1 Z6.872 X5.256 Y2.913 E46.02985
%G1 Z6.877 X4.922 Y3.446 E46.0554
%G1 Z6.882 X4.534 Y3.943 E46.08101
%G1 Z6.886 X4.175 Y4.322 E46.10221
%G1 Z6.891 X3.699 Y4.735 E46.1278
%G1 Z6.895 X3.273 Y5.039 E46.14905
%G1 Z6.899 X2.822 Y5.305 E46.17031
%G1 Z6.904 X2.25 Y5.572 E46.19595
%G1 Z6.908 X1.758 Y5.746 E46.21714
%G1 Z6.913 X1.147 Y5.898 E46.24271
%G1 Z6.918 X.524 Y5.986 E46.26826
%G1 Z6.923 X-.106 Y6.008 E46.29386
%G1 Z6.928 X-.627 Y5.976 E46.31506
%G1 Z6.933 X-1.25 Y5.877 E46.34068
%G1 Z6.937 X-1.756 Y5.746 E46.36191
%G1 Z6.942 X-2.348 Y5.531 E46.38749
%G1 Z6.947 X-2.914 Y5.255 E46.41306
%G1 Z6.950 X-3.263 Y5.041 E46.42969
%;LAYER_CHANGE
%;Z:7.25
%;HEIGHT:0.3
%G1 Z6.950 F7800
%G1 F900
%G1 Z6.952 X-3.447 Y4.922 E46.43859
%G1 Z6.956 X-3.914 Y4.559 E46.46261
%G1 Z6.961 X-4.323 Y4.174 E46.48542
%G1 Z6.965 X-4.669 Y3.782 E46.50665
%G1 Z6.970 X-5.04 Y3.272 E46.53226
%G1 Z6.975 X-5.337 Y2.761 E46.55626
%G1 Z6.979 X-5.571 Y2.251 E46.57905
%G1 Z6.984 X-5.776 Y1.656 E46.60461
%G1 Z6.989 X-5.911 Y1.08 E46.62864
%G1 Z6.993 X-5.986 Y.524 E46.65143
%G1 Z6.998 X-6.008 Y-.105 E46.67699
%G1 Z7.003 X-5.968 Y-.696 E46.70105
%G1 Z7.008 X-5.878 Y-1.249 E46.7238
%G1 Z7.013 X-5.715 Y-1.857 E46.74936
%G1 Z7.018 X-5.489 Y-2.444 E46.77491
%G1 Z7.022 X-5.222 Y-2.972 E46.79894
%G1 Z7.027 X-4.922 Y-3.447 E46.82176
%G1 Z7.031 X-4.604 Y-3.862 E46.84299
%G1 Z7.036 X-4.173 Y-4.323 E46.86862
%G1 Z7.040 X-3.782 Y-4.669 E46.88982
%G1 Z7.045 X-3.272 Y-5.04 E46.91543
%G1 Z7.049 X-2.822 Y-5.305 E46.93664
%G1 Z7.054 X-2.25 Y-5.572 E46.96228
%G1 Z7.058 X-1.758 Y-5.746 E46.98347
%G1 Z7.063 X-1.147 Y-5.898 E47.00904
%G1 Z7.068 X-.523 Y-5.986 E47.03463
%G1 Z7.073 X.068 Y-6.008 E47.05865
%G1 Z7.078 X.628 Y-5.976 E47.08143
%G1 Z7.083 X1.25 Y-5.877 E47.10701
%G1 Z7.087 X1.756 Y-5.746 E47.12824
%G1 Z7.092 X2.348 Y-5.531 E47.15382
%G1 Z7.097 X2.914 Y-5.255 E47.17939
%G1 Z7.101 X3.359 Y-4.982 E47.20059
%G1 Z7.106 X3.862 Y-4.603 E47.22617
%G1 Z7.111 X4.323 Y-4.173 E47.25177
%G1 Z7.115 X4.669 Y-3.782 E47.27297
%G1 Z7.120 X5.039 Y-3.273 E47.29853
%G1 Z7.125 X5.354 Y-2.727 E47.32413
%G1 Z7.129 X5.571 Y-2.251 E47.34538
%G1 Z7.133 X5.746 Y-1.758 E47.36663
%G1 Z7.138 X5.898 Y-1.147 E47.3922
%G1 Z7.143 X5.986 Y-.524 E47.41775
%G1 Z7.148 X6.008 Y.105 E47.44331
%G1 Z7.153 X5.964 Y.733 E47.46888
%G1 Z7.158 X5.878 Y1.249 E47.49013
%G1 Z7.163 X5.715 Y1.857 E47.51569
%G1 Z7.168 X5.489 Y2.445 E47.54127
%G1 Z7.172 X5.256 Y2.912 E47.56247
%G1 Z7.177 X4.922 Y3.447 E47.58808
%G1 Z7.181 X4.559 Y3.914 E47.6121
%G1 Z7.186 X4.174 Y4.322 E47.63488
%G1 Z7.191 X3.728 Y4.712 E47.65894
%G1 Z7.195 X3.272 Y5.04 E47.68175
%G1 Z7.199 X2.822 Y5.305 E47.70296
%G1 Z7.204 X2.251 Y5.571 E47.72854
%G1 Z7.209 X1.655 Y5.776 E47.75414
%G1 Z7.213 X1.147 Y5.898 E47.77536
%G1 Z7.218 X.524 Y5.986 E47.80091
%G1 Z7.223 X-.106 Y6.008 E47.82651
%G1 Z7.228 X-.627 Y5.976 E47.84771
%G1 Z7.233 X-1.249 Y5.877 E47.87329
%G1 Z7.238 X-1.857 Y5.715 E47.89884
%G1 Z7.243 X-2.445 Y5.489 E47.92442
%G1 Z7.247 X-2.912 Y5.256 E47.94562
%G1 Z7.250 X-3.261 Y5.038 E47.96233
%;LAYER_CHANGE
%;Z:7.55
%;HEIGHT:0.3
%G1 Z7.250 F7800
%G1 F900
%G1 Z7.252 X-3.447 Y4.922 E47.97123
%G1 Z7.256 X-3.916 Y4.557 E47.99537
%G1 Z7.261 X-4.322 Y4.174 E48.01804
%G1 Z7.266 X-4.736 Y3.699 E48.04363
%G1 Z7.270 X-5.039 Y3.273 E48.06486
%G1 Z7.275 X-5.354 Y2.727 E48.09046
%G1 Z7.279 X-5.571 Y2.252 E48.11167
%G1 Z7.284 X-5.776 Y1.656 E48.13727
%G1 Z7.289 X-5.911 Y1.077 E48.16142
%G1 Z7.293 X-5.986 Y.524 E48.18408
%G1 Z7.298 X-6.008 Y-.105 E48.20964
%G1 Z7.303 X-5.968 Y-.698 E48.23378
%G1 Z7.308 X-5.878 Y-1.249 E48.25645
%G1 Z7.313 X-5.715 Y-1.857 E48.28201
%G1 Z7.317 X-5.503 Y-2.413 E48.30618
%G1 Z7.322 X-5.256 Y-2.913 E48.32883
%G1 Z7.327 X-4.922 Y-3.447 E48.35441
%G1 Z7.331 X-4.604 Y-3.862 E48.37564
%G1 Z7.336 X-4.174 Y-4.322 E48.40121
%G1 Z7.341 X-3.726 Y-4.714 E48.42539
%G1 Z7.345 X-3.273 Y-5.039 E48.44803
%G1 Z7.350 X-2.758 Y-5.338 E48.47222
%G1 Z7.354 X-2.251 Y-5.571 E48.49488
%G1 Z7.358 X-1.758 Y-5.746 E48.51613
%G1 Z7.363 X-1.147 Y-5.898 E48.5417
%G1 Z7.368 X-.523 Y-5.986 E48.56729
%G1 Z7.373 X.071 Y-6.008 E48.59143
%G1 Z7.378 X.628 Y-5.976 E48.61409
%G1 Z7.383 X1.25 Y-5.877 E48.63967
%G1 Z7.387 X1.756 Y-5.746 E48.6609
%G1 Z7.392 X2.349 Y-5.531 E48.68652
%G1 Z7.396 X2.82 Y-5.306 E48.70772
%G1 Z7.401 X3.36 Y-4.981 E48.73332
%G1 Z7.406 X3.862 Y-4.603 E48.75884
%G1 Z7.411 X4.323 Y-4.173 E48.78444
%G1 Z7.415 X4.669 Y-3.782 E48.80564
%G1 Z7.420 X5.039 Y-3.272 E48.83123
%G1 Z7.425 X5.338 Y-2.758 E48.85538
%G1 Z7.429 X5.571 Y-2.251 E48.87804
%G1 Z7.433 X5.746 Y-1.758 E48.89929
%G1 Z7.438 X5.898 Y-1.147 E48.92486
%G1 Z7.443 X5.986 Y-.524 E48.95041
%G1 Z7.448 X6.008 Y.105 E48.97597
%G1 Z7.453 X5.964 Y.733 E49.00154
%G1 Z7.458 X5.878 Y1.248 E49.02275
%G1 Z7.463 X5.715 Y1.857 E49.04835
%G1 Z7.467 X5.503 Y2.413 E49.07252
%G1 Z7.472 X5.256 Y2.913 E49.09517
%G1 Z7.477 X4.922 Y3.447 E49.12075
%G1 Z7.481 X4.604 Y3.862 E49.14198
%G1 Z7.486 X4.173 Y4.323 E49.16761
%G1 Z7.490 X3.782 Y4.669 E49.18881
%G1 Z7.495 X3.272 Y5.04 E49.21442
%G1 Z7.499 X2.822 Y5.305 E49.23563
%G1 Z7.504 X2.25 Y5.572 E49.26127
%G1 Z7.508 X1.758 Y5.746 E49.28246
%G1 Z7.513 X1.147 Y5.898 E49.30803
%G1 Z7.518 X.524 Y5.986 E49.33358
%G1 Z7.523 X-.106 Y6.008 E49.35918
%G1 Z7.528 X-.627 Y5.976 E49.38038
%G1 Z7.533 X-1.25 Y5.877 E49.406
%G1 Z7.537 X-1.824 Y5.725 E49.43012
%G1 Z7.542 X-2.347 Y5.531 E49.45277
%G1 Z7.547 X-2.913 Y5.255 E49.47834
%G1 Z7.550 X-3.261 Y5.038 E49.495
%;LAYER_CHANGE
%;Z:7.85
%;HEIGHT:0.3
%G1 Z7.550 F7800
%G1 F900
%G1 Z7.551 X-3.359 Y4.982 E49.49958
%G1 Z7.556 X-3.862 Y4.603 E49.52516
%G1 Z7.561 X-4.323 Y4.173 E49.55076
%G1 Z7.565 X-4.669 Y3.782 E49.57196
%G1 Z7.570 X-5.04 Y3.272 E49.59757
%G1 Z7.574 X-5.305 Y2.822 E49.61878
%G1 Z7.579 X-5.572 Y2.25 E49.64442
%G1 Z7.583 X-5.746 Y1.758 E49.66561
%G1 Z7.588 X-5.898 Y1.147 E49.69118
%G1 Z7.593 X-5.986 Y.524 E49.71673
%G1 Z7.598 X-6.008 Y-.105 E49.74229
%G1 Z7.603 X-5.964 Y-.733 E49.76786
%G1 Z7.608 X-5.878 Y-1.249 E49.78911
%G1 Z7.612 X-5.746 Y-1.756 E49.81039
%G1 Z7.617 X-5.531 Y-2.348 E49.83597
%G1 Z7.622 X-5.255 Y-2.913 E49.86151
%G1 Z7.626 X-4.94 Y-3.421 E49.88579
%G1 Z7.631 X-4.603 Y-3.862 E49.90833
%G1 Z7.636 X-4.173 Y-4.323 E49.93393
%G1 Z7.640 X-3.782 Y-4.669 E49.95513
%G1 Z7.645 X-3.272 Y-5.04 E49.98074
%G1 Z7.649 X-2.822 Y-5.305 E50.00195
%G1 Z7.654 X-2.25 Y-5.572 E50.02759
%G1 Z7.658 X-1.758 Y-5.746 E50.04878
%G1 Z7.663 X-1.147 Y-5.898 E50.07435
%G1 Z7.668 X-.523 Y-5.986 E50.09994
%G1 Z7.673 X.074 Y-6.008 E50.1242
%G1 Z7.678 X.628 Y-5.976 E50.14674
%G1 Z7.683 X1.25 Y-5.877 E50.17232
%G1 Z7.687 X1.756 Y-5.746 E50.19355
%G1 Z7.692 X2.349 Y-5.531 E50.21917
%G1 Z7.696 X2.82 Y-5.306 E50.24037
%G1 Z7.701 X3.36 Y-4.981 E50.26597
%G1 Z7.706 X3.862 Y-4.603 E50.29149
%G1 Z7.711 X4.322 Y-4.174 E50.31704
%G1 Z7.716 X4.735 Y-3.699 E50.3426
%G1 Z7.720 X5.039 Y-3.273 E50.36385
%G1 Z7.724 X5.305 Y-2.822 E50.38511
%G1 Z7.729 X5.572 Y-2.25 E50.41075
%G1 Z7.733 X5.746 Y-1.758 E50.43194
%G1 Z7.738 X5.898 Y-1.147 E50.45751
%G1 Z7.743 X5.986 Y-.524 E50.48306
%G1 Z7.748 X6.008 Y.105 E50.50862
%G1 Z7.753 X5.968 Y.701 E50.53288
%G1 Z7.758 X5.878 Y1.249 E50.55543
%G1 Z7.763 X5.715 Y1.857 E50.58099
%G1 Z7.768 X5.489 Y2.445 E50.60657
%G1 Z7.772 X5.256 Y2.912 E50.62777
%G1 Z7.777 X4.922 Y3.447 E50.65338
%G1 Z7.781 X4.604 Y3.862 E50.67461
%G1 Z7.786 X4.174 Y4.323 E50.70021
%G1 Z7.791 X3.724 Y4.716 E50.72447
%G1 Z7.795 X3.272 Y5.04 E50.74706
%G1 Z7.799 X2.822 Y5.305 E50.76827
%G1 Z7.804 X2.25 Y5.572 E50.79391
%G1 Z7.808 X1.758 Y5.746 E50.8151
%G1 Z7.813 X1.147 Y5.898 E50.84067
%G1 Z7.818 X.524 Y5.986 E50.86622
%G1 Z7.823 X-.106 Y6.008 E50.89182
%G1 Z7.828 X-.627 Y5.976 E50.91302
%G1 Z7.833 X-1.25 Y5.877 E50.93864
%G1 Z7.837 X-1.756 Y5.746 E50.95987
%G1 Z7.842 X-2.348 Y5.531 E50.98545
%G1 Z7.847 X-2.914 Y5.255 E51.01102
%G1 Z7.850 X-3.263 Y5.041 E51.02765
%;LAYER_CHANGE
%;Z:8.15
%;HEIGHT:0.3
%G1 Z7.850 F7800
%G1 F900
%G1 Z7.852 X-3.447 Y4.922 E51.03655
%G1 Z7.857 X-3.921 Y4.553 E51.06095
%G1 Z7.861 X-4.323 Y4.174 E51.08339
%G1 Z7.865 X-4.669 Y3.782 E51.10462
%G1 Z7.870 X-5.039 Y3.273 E51.13018
%G1 Z7.875 X-5.354 Y2.727 E51.15578
%G1 Z7.879 X-5.571 Y2.251 E51.17703
%G1 Z7.883 X-5.746 Y1.758 E51.19828
%G1 Z7.888 X-5.898 Y1.147 E51.22385
%G1 Z7.893 X-5.986 Y.524 E51.2494
%G1 Z7.898 X-6.008 Y-.105 E51.27496
%G1 Z7.903 X-5.967 Y-.704 E51.29934
%G1 Z7.908 X-5.878 Y-1.249 E51.32177
%G1 Z7.913 X-5.715 Y-1.857 E51.34733
%G1 Z7.917 X-5.501 Y-2.418 E51.37172
%G1 Z7.922 X-5.256 Y-2.913 E51.39415
%G1 Z7.927 X-4.922 Y-3.447 E51.41973
%G1 Z7.931 X-4.604 Y-3.862 E51.44096
%G1 Z7.936 X-4.173 Y-4.323 E51.46659
%G1 Z7.940 X-3.782 Y-4.669 E51.48779
%G1 Z7.945 X-3.272 Y-5.039 E51.51338
%G1 Z7.950 X-2.753 Y-5.341 E51.53777
%G1 Z7.954 X-2.251 Y-5.571 E51.5602
%G1 Z7.958 X-1.758 Y-5.746 E51.58145
%G1 Z7.963 X-1.147 Y-5.898 E51.60702
%G1 Z7.968 X-.524 Y-5.986 E51.63257
%G1 Z7.973 X.077 Y-6.008 E51.65699
%G1 Z7.978 X.627 Y-5.976 E51.67936
%G1 Z7.983 X1.25 Y-5.877 E51.70498
%G1 Z7.987 X1.756 Y-5.746 E51.72621
%G1 Z7.992 X2.348 Y-5.531 E51.75179
%G1 Z7.997 X2.913 Y-5.255 E51.77733
%G1 Z8.002 X3.423 Y-4.938 E51.80172
%G1 Z8.006 X3.862 Y-4.603 E51.82415
%G1 Z8.011 X4.322 Y-4.174 E51.8497
%G1 Z8.016 X4.717 Y-3.721 E51.87411
%G1 Z8.020 X5.039 Y-3.273 E51.89652
%G1 Z8.025 X5.354 Y-2.728 E51.92209
%G1 Z8.030 X5.599 Y-2.18 E51.94647
%G1 Z8.034 X5.776 Y-1.657 E51.96889
%G1 Z8.039 X5.917 Y-1.043 E51.99448
%G1 Z8.044 X5.994 Y-.418 E52.02006
%G1 Z8.048 X6.008 Y.104 E52.04127
%G1 Z8.053 X5.964 Y.733 E52.06688
%G1 Z8.058 X5.878 Y1.248 E52.08809
%G1 Z8.063 X5.715 Y1.857 E52.11369
%G1 Z8.067 X5.501 Y2.418 E52.13808
%G1 Z8.072 X5.256 Y2.913 E52.16051
%G1 Z8.077 X4.922 Y3.446 E52.18606
%G1 Z8.082 X4.534 Y3.943 E52.21167
%G1 Z8.086 X4.175 Y4.322 E52.23287
%G1 Z8.091 X3.699 Y4.735 E52.25846
%G1 Z8.095 X3.273 Y5.039 E52.27971
%G1 Z8.099 X2.822 Y5.305 E52.30097
%G1 Z8.104 X2.25 Y5.572 E52.32661
%G1 Z8.108 X1.758 Y5.746 E52.3478
%G1 Z8.113 X1.147 Y5.898 E52.37337
%G1 Z8.118 X.524 Y5.986 E52.39892
%G1 Z8.123 X-.106 Y6.008 E52.42452
%G1 Z8.128 X-.627 Y5.976 E52.44572
%G1 Z8.133 X-1.249 Y5.877 E52.4713
%G1 Z8.138 X-1.857 Y5.715 E52.49685
%G1 Z8.142 X-2.418 Y5.501 E52.52124
%G1 Z8.147 X-2.913 Y5.256 E52.54367
%G1 Z8.150 X-3.261 Y5.038 E52.56035
%;LAYER_CHANGE
%;Z:8.45
%;HEIGHT:0.3
%G1 Z8.150 F7800
%G1 F900
%G1 Z8.151 X-3.36 Y4.981 E52.565
%G1 Z8.156 X-3.862 Y4.603 E52.59052
%G1 Z8.161 X-4.323 Y4.173 E52.61612
%G1 Z8.165 X-4.669 Y3.782 E52.63732
%G1 Z8.170 X-5.039 Y3.273 E52.66288
%G1 Z8.175 X-5.354 Y2.728 E52.68845
%G1 Z8.180 X-5.6 Y2.177 E52.71296
%G1 Z8.184 X-5.776 Y1.657 E52.73526
%G1 Z8.189 X-5.918 Y1.043 E52.76085
%G1 Z8.193 X-5.986 Y.525 E52.78207
%G1 Z8.198 X-6.008 Y-.105 E52.80767
%G1 Z8.203 X-5.967 Y-.707 E52.83218
%G1 Z8.208 X-5.878 Y-1.249 E52.85449
%G1 Z8.213 X-5.715 Y-1.857 E52.88005
%G1 Z8.218 X-5.489 Y-2.444 E52.9056
%G1 Z8.222 X-5.216 Y-2.982 E52.9301
%G1 Z8.227 X-4.922 Y-3.446 E52.95241
%G1 Z8.232 X-4.551 Y-3.923 E52.97695
%G1 Z8.236 X-4.174 Y-4.323 E52.99927
%G1 Z8.240 X-3.782 Y-4.669 E53.0205
%G1 Z8.245 X-3.272 Y-5.039 E53.04609
%G1 Z8.250 X-2.75 Y-5.342 E53.0706
%G1 Z8.254 X-2.251 Y-5.571 E53.0929
%G1 Z8.258 X-1.758 Y-5.746 E53.11415
%G1 Z8.263 X-1.147 Y-5.898 E53.13972
%G1 Z8.268 X-.524 Y-5.986 E53.16527
%G1 Z8.273 X.08 Y-6.008 E53.18982
%G1 Z8.278 X.627 Y-5.976 E53.21207
%G1 Z8.283 X1.25 Y-5.877 E53.23769
%G1 Z8.287 X1.756 Y-5.746 E53.25892
%G1 Z8.292 X2.348 Y-5.531 E53.2845
%G1 Z8.297 X2.914 Y-5.255 E53.31007
%G1 Z8.301 X3.359 Y-4.982 E53.33127
%G1 Z8.306 X3.862 Y-4.603 E53.35685
%G1 Z8.311 X4.323 Y-4.173 E53.38245
%G1 Z8.315 X4.669 Y-3.782 E53.40365
%G1 Z8.320 X5.039 Y-3.273 E53.42921
%G1 Z8.325 X5.354 Y-2.727 E53.45481
%G1 Z8.329 X5.571 Y-2.251 E53.47606
%G1 Z8.333 X5.746 Y-1.758 E53.49731
%G1 Z8.338 X5.898 Y-1.147 E53.52288
%G1 Z8.343 X5.986 Y-.524 E53.54843
%G1 Z8.348 X6.008 Y.105 E53.57399
%G1 Z8.353 X5.964 Y.733 E53.59956
%G1 Z8.358 X5.878 Y1.248 E53.62077
%G1 Z8.363 X5.715 Y1.857 E53.64637
%G1 Z8.367 X5.499 Y2.421 E53.6709
%G1 Z8.372 X5.256 Y2.913 E53.69319
%G1 Z8.377 X4.922 Y3.446 E53.71874
%G1 Z8.382 X4.534 Y3.943 E53.74435
%G1 Z8.386 X4.175 Y4.322 E53.76555
%G1 Z8.391 X3.699 Y4.735 E53.79114
%G1 Z8.395 X3.273 Y5.039 E53.81239
%G1 Z8.400 X2.728 Y5.354 E53.83796
%G1 Z8.405 X2.177 Y5.6 E53.86247
%G1 Z8.409 X1.657 Y5.776 E53.88477
%G1 Z8.414 X1.043 Y5.918 E53.91036
%G1 Z8.418 X.525 Y5.986 E53.93158
%G1 Z8.423 X-.106 Y6.008 E53.95722
%G1 Z8.428 X-.627 Y5.976 E53.97842
%G1 Z8.433 X-1.249 Y5.877 E54.004
%G1 Z8.438 X-1.858 Y5.714 E54.0296
%G1 Z8.442 X-2.348 Y5.531 E54.05084
%G1 Z8.446 X-2.82 Y5.306 E54.07208
%G1 Z8.450 X-3.262 Y5.04 E54.09303
%;LAYER_CHANGE
%;Z:8.75
%;HEIGHT:0.3
%G1 Z8.450 F7800
%G1 F900
%G1 Z8.452 X-3.447 Y4.922 E54.10193
%G1 Z8.457 X-3.925 Y4.549 E54.12655
%G1 Z8.461 X-4.322 Y4.174 E54.14873
%G1 Z8.466 X-4.735 Y3.699 E54.17429
%G1 Z8.470 X-5.039 Y3.273 E54.19554
%G1 Z8.475 X-5.354 Y2.727 E54.22114
%G1 Z8.479 X-5.571 Y2.251 E54.24239
%G1 Z8.483 X-5.746 Y1.758 E54.26364
%G1 Z8.488 X-5.898 Y1.147 E54.28921
%G1 Z8.493 X-5.986 Y.524 E54.31476
%G1 Z8.498 X-6.008 Y-.105 E54.34032
%G1 Z8.503 X-5.964 Y-.733 E54.36589
%G1 Z8.508 X-5.878 Y-1.249 E54.38714
%G1 Z8.512 X-5.746 Y-1.756 E54.40842
%G1 Z8.517 X-5.531 Y-2.348 E54.434
%G1 Z8.522 X-5.255 Y-2.913 E54.45954
%G1 Z8.527 X-4.935 Y-3.428 E54.48416
%G1 Z8.531 X-4.603 Y-3.862 E54.50635
%G1 Z8.536 X-4.174 Y-4.322 E54.5319
%G1 Z8.541 X-3.699 Y-4.736 E54.55749
%G1 Z8.545 X-3.273 Y-5.039 E54.57872
%G1 Z8.549 X-2.822 Y-5.305 E54.59998
%G1 Z8.554 X-2.25 Y-5.572 E54.62562
%G1 Z8.558 X-1.758 Y-5.746 E54.64681
%G1 Z8.563 X-1.147 Y-5.898 E54.67238
%G1 Z8.568 X-.524 Y-5.986 E54.69793
%G1 Z8.573 X.082 Y-6.008 E54.72256
%G1 Z8.578 X.627 Y-5.976 E54.74473
%G1 Z8.583 X1.25 Y-5.877 E54.77035
%G1 Z8.587 X1.756 Y-5.746 E54.79158
%G1 Z8.592 X2.348 Y-5.531 E54.81716
%G1 Z8.597 X2.913 Y-5.255 E54.8427
%G1 Z8.602 X3.428 Y-4.935 E54.86732
%G1 Z8.606 X3.862 Y-4.603 E54.88951
%G1 Z8.611 X4.323 Y-4.173 E54.91511
%G1 Z8.615 X4.669 Y-3.782 E54.93631
%G1 Z8.620 X5.039 Y-3.272 E54.9619
%G1 Z8.625 X5.344 Y-2.748 E54.98652
%G1 Z8.629 X5.571 Y-2.251 E55.00871
%G1 Z8.633 X5.746 Y-1.758 E55.02996
%G1 Z8.638 X5.898 Y-1.147 E55.05553
%G1 Z8.643 X5.986 Y-.524 E55.08108
%G1 Z8.648 X6.008 Y.105 E55.10664
%G1 Z8.653 X5.964 Y.733 E55.13221
%G1 Z8.658 X5.878 Y1.248 E55.15342
%G1 Z8.663 X5.715 Y1.857 E55.17902
%G1 Z8.667 X5.498 Y2.423 E55.20364
%G1 Z8.672 X5.256 Y2.913 E55.22584
%G1 Z8.677 X4.922 Y3.446 E55.25139
%G1 Z8.682 X4.534 Y3.943 E55.277
%G1 Z8.686 X4.175 Y4.322 E55.2982
%G1 Z8.691 X3.699 Y4.736 E55.32382
%G1 Z8.695 X3.273 Y5.039 E55.34505
%G1 Z8.700 X2.727 Y5.354 E55.37065
%G1 Z8.704 X2.251 Y5.571 E55.3919
%G1 Z8.708 X1.758 Y5.746 E55.41315
%G1 Z8.713 X1.147 Y5.898 E55.43872
%G1 Z8.718 X.524 Y5.986 E55.46427
%G1 Z8.723 X-.105 Y6.008 E55.48983
%G1 Z8.728 X-.733 Y5.964 E55.5154
%G1 Z8.733 X-1.248 Y5.878 E55.53661
%G1 Z8.738 X-1.858 Y5.714 E55.56226
%G1 Z8.742 X-2.347 Y5.531 E55.58346
%G1 Z8.747 X-2.913 Y5.255 E55.60903
%G1 Z8.750 X-3.261 Y5.038 E55.62569
%;LAYER_CHANGE
%;Z:9.05
%;HEIGHT:0.3
%G1 Z8.750 F7800
%G1 F900
%G1 Z8.751 X-3.359 Y4.982 E55.63027
%G1 Z8.756 X-3.862 Y4.603 E55.65585
%G1 Z8.761 X-4.323 Y4.173 E55.68145
%G1 Z8.765 X-4.669 Y3.782 E55.70265
%G1 Z8.770 X-5.04 Y3.272 E55.72826
%G1 Z8.774 X-5.305 Y2.822 E55.74947
%G1 Z8.779 X-5.572 Y2.25 E55.77511
%G1 Z8.783 X-5.746 Y1.758 E55.7963
%G1 Z8.788 X-5.898 Y1.147 E55.82187
%G1 Z8.793 X-5.986 Y.524 E55.84742
%G1 Z8.798 X-6.008 Y-.105 E55.87298
%G1 Z8.803 X-5.964 Y-.733 E55.89855
%G1 Z8.808 X-5.878 Y-1.248 E55.91976
%G1 Z8.813 X-5.715 Y-1.857 E55.94536
%G1 Z8.817 X-5.497 Y-2.426 E55.97011
%G1 Z8.822 X-5.256 Y-2.913 E55.99218
%G1 Z8.827 X-4.922 Y-3.447 E56.01776
%G1 Z8.831 X-4.604 Y-3.862 E56.03899
%G1 Z8.836 X-4.173 Y-4.323 E56.06462
%G1 Z8.840 X-3.782 Y-4.669 E56.08582
%G1 Z8.845 X-3.273 Y-5.039 E56.11138
%G1 Z8.850 X-2.745 Y-5.345 E56.13616
%G1 Z8.854 X-2.251 Y-5.571 E56.15822
%G1 Z8.858 X-1.758 Y-5.746 E56.17947
%G1 Z8.863 X-1.147 Y-5.898 E56.20504
%G1 Z8.868 X-.524 Y-5.986 E56.23059
%G1 Z8.873 X.085 Y-6.008 E56.25534
%G1 Z8.878 X.627 Y-5.976 E56.27739
%G1 Z8.883 X1.25 Y-5.877 E56.30301
%G1 Z8.887 X1.756 Y-5.746 E56.32424
%G1 Z8.892 X2.348 Y-5.531 E56.34982
%G1 Z8.897 X2.913 Y-5.255 E56.37536
%G1 Z8.902 X3.43 Y-4.933 E56.4001
%G1 Z8.906 X3.862 Y-4.603 E56.42218
%G1 Z8.911 X4.323 Y-4.173 E56.44778
%G1 Z8.915 X4.669 Y-3.782 E56.46898
%G1 Z8.920 X5.039 Y-3.272 E56.49457
%G1 Z8.925 X5.345 Y-2.745 E56.51932
%G1 Z8.929 X5.571 Y-2.251 E56.54138
%G1 Z8.933 X5.746 Y-1.758 E56.56263
%G1 Z8.938 X5.898 Y-1.147 E56.5882
%G1 Z8.943 X5.986 Y-.524 E56.61375
%G1 Z8.948 X6.008 Y.105 E56.63931
%G1 Z8.953 X5.964 Y.733 E56.66488
%G1 Z8.958 X5.878 Y1.248 E56.68609
%G1 Z8.963 X5.715 Y1.857 E56.71169
%G1 Z8.967 X5.497 Y2.426 E56.73644
%G1 Z8.972 X5.256 Y2.913 E56.75851
%G1 Z8.977 X4.922 Y3.447 E56.78409
%G1 Z8.982 X4.548 Y3.927 E56.8088
%G1 Z8.986 X4.174 Y4.322 E56.83089
%G1 Z8.991 X3.699 Y4.735 E56.85645
%G1 Z8.995 X3.273 Y5.039 E56.8777
%G1 Z8.999 X2.822 Y5.305 E56.89896
%G1 Z9.004 X2.25 Y5.572 E56.9246
%G1 Z9.008 X1.758 Y5.746 E56.94579
%G1 Z9.013 X1.147 Y5.898 E56.97136
%G1 Z9.018 X.524 Y5.986 E56.99691
%G1 Z9.023 X-.105 Y6.008 E57.02247
%G1 Z9.028 X-.733 Y5.964 E57.04804
%G1 Z9.033 X-1.249 Y5.878 E57.06929
%G1 Z9.037 X-1.838 Y5.721 E57.09405
%G1 Z9.042 X-2.347 Y5.531 E57.11612
%G1 Z9.047 X-2.914 Y5.255 E57.14173
%G1 Z9.050 X-3.263 Y5.041 E57.15836
%;LAYER_CHANGE
%;Z:9.35
%;HEIGHT:0.3
%G1 Z9.050 F7800
%G1 F900
%G1 Z9.052 X-3.447 Y4.922 E57.16726
%G1 Z9.057 X-3.929 Y4.546 E57.19209
%G1 Z9.061 X-4.323 Y4.174 E57.2141
%G1 Z9.065 X-4.669 Y3.782 E57.23533
%G1 Z9.070 X-5.04 Y3.272 E57.26094
%G1 Z9.074 X-5.305 Y2.822 E57.28215
%G1 Z9.079 X-5.571 Y2.251 E57.30773
%G1 Z9.084 X-5.776 Y1.656 E57.33329
%G1 Z9.089 X-5.914 Y1.06 E57.35814
%G1 Z9.093 X-5.986 Y.524 E57.3801
%G1 Z9.098 X-6.008 Y-.105 E57.40566
%G1 Z9.103 X-5.966 Y-.716 E57.43053
%G1 Z9.108 X-5.878 Y-1.249 E57.45247
%G1 Z9.113 X-5.715 Y-1.857 E57.47803
%G1 Z9.117 X-5.496 Y-2.429 E57.50291
%G1 Z9.122 X-5.256 Y-2.912 E57.52481
%G1 Z9.127 X-4.922 Y-3.447 E57.55042
%G1 Z9.131 X-4.604 Y-3.862 E57.57165
%G1 Z9.136 X-4.174 Y-4.322 E57.59722
%G1 Z9.141 X-3.712 Y-4.725 E57.62212
%G1 Z9.145 X-3.272 Y-5.04 E57.6441
%G1 Z9.149 X-2.822 Y-5.305 E57.66531
%G1 Z9.154 X-2.251 Y-5.571 E57.69089
%G1 Z9.159 X-1.655 Y-5.776 E57.71649
%G1 Z9.163 X-1.147 Y-5.898 E57.73771
%G1 Z9.168 X-.524 Y-5.986 E57.76326
%G1 Z9.173 X.088 Y-6.008 E57.78813
%G1 Z9.178 X.627 Y-5.976 E57.81006
%G1 Z9.183 X1.249 Y-5.877 E57.83564
%G1 Z9.188 X1.858 Y-5.714 E57.86124
%G1 Z9.192 X2.347 Y-5.531 E57.88244
%G1 Z9.197 X2.899 Y-5.263 E57.90736
%G1 Z9.201 X3.359 Y-4.982 E57.92925
%G1 Z9.206 X3.862 Y-4.603 E57.95483
%G1 Z9.211 X4.323 Y-4.173 E57.98043
%G1 Z9.215 X4.669 Y-3.782 E58.00163
%G1 Z9.220 X5.04 Y-3.272 E58.02724
%G1 Z9.224 X5.305 Y-2.822 E58.04845
%G1 Z9.229 X5.572 Y-2.25 E58.07409
%G1 Z9.233 X5.746 Y-1.758 E58.09528
%G1 Z9.238 X5.898 Y-1.147 E58.12085
%G1 Z9.243 X5.986 Y-.524 E58.1464
%G1 Z9.248 X6.008 Y.105 E58.17196
%G1 Z9.253 X5.964 Y.733 E58.19753
%G1 Z9.258 X5.878 Y1.249 E58.21878
%G1 Z9.263 X5.715 Y1.857 E58.24434
%G1 Z9.268 X5.489 Y2.445 E58.26992
%G1 Z9.272 X5.256 Y2.912 E58.29112
%G1 Z9.277 X4.922 Y3.447 E58.31673
%G1 Z9.281 X4.604 Y3.862 E58.33796
%G1 Z9.286 X4.174 Y4.322 E58.36353
%G1 Z9.291 X3.712 Y4.725 E58.38843
%G1 Z9.295 X3.273 Y5.039 E58.41035
%G1 Z9.299 X2.822 Y5.305 E58.43161
%G1 Z9.304 X2.25 Y5.572 E58.45725
%G1 Z9.308 X1.758 Y5.746 E58.47844
%G1 Z9.313 X1.147 Y5.898 E58.50401
%G1 Z9.318 X.524 Y5.986 E58.52956
%G1 Z9.323 X-.105 Y6.008 E58.55512
%G1 Z9.328 X-.733 Y5.964 E58.58069
%G1 Z9.333 X-1.248 Y5.878 E58.6019
%G1 Z9.338 X-1.857 Y5.715 E58.6275
%G1 Z9.342 X-2.429 Y5.496 E58.65238
%G1 Z9.347 X-2.913 Y5.256 E58.67432
%G1 Z9.350 X-3.261 Y5.038 E58.691
%;LAYER_CHANGE
%;Z:9.65
%;HEIGHT:0.299999
%G1 Z9.350 F7800
%G1 F900
%G1 Z9.352 X-3.447 Y4.922 E58.6999
%G1 Z9.357 X-3.932 Y4.544 E58.72487
%G1 Z9.361 X-4.322 Y4.174 E58.7467
%G1 Z9.366 X-4.726 Y3.71 E58.77169
%G1 Z9.370 X-5.039 Y3.273 E58.79352
%G1 Z9.375 X-5.354 Y2.727 E58.81912
%G1 Z9.379 X-5.571 Y2.251 E58.84037
%G1 Z9.383 X-5.746 Y1.758 E58.86162
%G1 Z9.388 X-5.898 Y1.146 E58.88723
%G1 Z9.393 X-5.986 Y.524 E58.91274
%G1 Z9.398 X-6.008 Y-.105 E58.9383
%G1 Z9.403 X-5.964 Y-.733 E58.96387
%G1 Z9.408 X-5.878 Y-1.248 E58.98508
%G1 Z9.413 X-5.715 Y-1.857 E59.01068
%G1 Z9.418 X-5.489 Y-2.445 E59.03626
%G1 Z9.422 X-5.256 Y-2.912 E59.05746
%G1 Z9.427 X-4.922 Y-3.446 E59.08304
%G1 Z9.432 X-4.544 Y-3.932 E59.10805
%G1 Z9.436 X-4.174 Y-4.322 E59.12988
%G1 Z9.440 X-3.782 Y-4.669 E59.15114
%G1 Z9.445 X-3.273 Y-5.039 E59.1767
%G1 Z9.450 X-2.74 Y-5.348 E59.20172
%G1 Z9.454 X-2.251 Y-5.571 E59.22355
%G1 Z9.458 X-1.758 Y-5.746 E59.2448
%G1 Z9.463 X-1.147 Y-5.898 E59.27037
%G1 Z9.468 X-.524 Y-5.986 E59.29592
%G1 Z9.473 X.091 Y-6.008 E59.32091
%G1 Z9.478 X.627 Y-5.976 E59.34272
%G1 Z9.483 X1.249 Y-5.877 E59.3683
%G1 Z9.487 X1.844 Y-5.719 E59.3933
%G1 Z9.492 X2.348 Y-5.531 E59.41515
%G1 Z9.496 X2.82 Y-5.306 E59.43639
%G1 Z9.501 X3.36 Y-4.981 E59.46199
%G1 Z9.506 X3.862 Y-4.603 E59.48751
%G1 Z9.511 X4.322 Y-4.174 E59.51306
%G1 Z9.516 X4.726 Y-3.71 E59.53805
%G1 Z9.520 X5.039 Y-3.273 E59.55988
%G1 Z9.525 X5.354 Y-2.727 E59.58548
%G1 Z9.529 X5.571 Y-2.251 E59.60673
%G1 Z9.533 X5.746 Y-1.758 E59.62798
%G1 Z9.538 X5.898 Y-1.147 E59.65355
%G1 Z9.543 X5.986 Y-.524 E59.6791
%G1 Z9.548 X6.008 Y.105 E59.70466
%G1 Z9.553 X5.966 Y.719 E59.72965
%G1 Z9.558 X5.878 Y1.249 E59.75147
%G1 Z9.563 X5.715 Y1.857 E59.77703
%G1 Z9.567 X5.495 Y2.431 E59.802
%G1 Z9.572 X5.256 Y2.913 E59.82385
%G1 Z9.577 X4.922 Y3.447 E59.84943
%G1 Z9.582 X4.544 Y3.932 E59.8744
%G1 Z9.586 X4.174 Y4.322 E59.89623
%G1 Z9.590 X3.782 Y4.669 E59.91749
%G1 Z9.595 X3.272 Y5.04 E59.9431
%G1 Z9.599 X2.822 Y5.305 E59.96431
%G1 Z9.604 X2.251 Y5.571 E59.98989
%G1 Z9.609 X1.656 Y5.776 E60.01545
%G1 Z9.614 X1.057 Y5.915 E60.04042
%G1 Z9.618 X.524 Y5.986 E60.06226
%G1 Z9.623 X-.106 Y6.008 E60.08786
%G1 Z9.628 X-.627 Y5.976 E60.10906
%G1 Z9.633 X-1.249 Y5.877 E60.13464
%G1 Z9.638 X-1.857 Y5.715 E60.16019
%G1 Z9.643 X-2.445 Y5.489 E60.18577
%G1 Z9.647 X-2.912 Y5.256 E60.20697
%G1 Z9.650 X-3.261 Y5.038 E60.22368
%;LAYER_CHANGE
%;Z:9.95
%;HEIGHT:0.3
%G1 Z9.650 F7800
%G1 F900
%G1 Z9.651 X-3.359 Y4.982 E60.22826
%G1 Z9.656 X-3.862 Y4.603 E60.25384
%G1 Z9.661 X-4.323 Y4.173 E60.27944
%G1 Z9.665 X-4.669 Y3.782 E60.30064
%G1 Z9.670 X-5.04 Y3.272 E60.32625
%G1 Z9.674 X-5.305 Y2.822 E60.34746
%G1 Z9.679 X-5.571 Y2.251 E60.37304
%G1 Z9.684 X-5.776 Y1.655 E60.39864
%G1 Z9.688 X-5.898 Y1.147 E60.41986
%G1 Z9.693 X-5.986 Y.524 E60.44541
%G1 Z9.698 X-6.008 Y-.105 E60.47097
%G1 Z9.703 X-5.964 Y-.733 E60.49654
%G1 Z9.708 X-5.878 Y-1.248 E60.51775
%G1 Z9.713 X-5.715 Y-1.857 E60.54335
%G1 Z9.717 X-5.494 Y-2.434 E60.56844
%G1 Z9.722 X-5.256 Y-2.912 E60.59013
%G1 Z9.727 X-4.922 Y-3.447 E60.61574
%G1 Z9.731 X-4.604 Y-3.862 E60.63697
%G1 Z9.736 X-4.173 Y-4.323 E60.6626
%G1 Z9.740 X-3.782 Y-4.669 E60.6838
%G1 Z9.745 X-3.272 Y-5.04 E60.70941
%G1 Z9.749 X-2.822 Y-5.305 E60.73062
%G1 Z9.754 X-2.25 Y-5.572 E60.75626
%G1 Z9.758 X-1.758 Y-5.746 E60.77745
%G1 Z9.763 X-1.147 Y-5.898 E60.80302
%G1 Z9.768 X-.524 Y-5.986 E60.82857
%G1 Z9.773 X.094 Y-6.008 E60.85368
%G1 Z9.778 X.627 Y-5.976 E60.87537
%G1 Z9.783 X1.249 Y-5.877 E60.90095
%G1 Z9.787 X1.847 Y-5.718 E60.92608
%G1 Z9.792 X2.348 Y-5.531 E60.9478
%G1 Z9.796 X2.82 Y-5.306 E60.96904
%G1 Z9.801 X3.36 Y-4.981 E60.99464
%G1 Z9.806 X3.862 Y-4.603 E61.02016
%G1 Z9.811 X4.323 Y-4.173 E61.04576
%G1 Z9.815 X4.669 Y-3.782 E61.06696
%G1 Z9.820 X5.039 Y-3.273 E61.09252
%G1 Z9.825 X5.354 Y-2.728 E61.11809
%G1 Z9.830 X5.606 Y-2.163 E61.14322
%G1 Z9.834 X5.776 Y-1.657 E61.1649
%G1 Z9.839 X5.917 Y-1.043 E61.19049
%G1 Z9.844 X5.993 Y-.43 E61.21558
%G1 Z9.848 X6.008 Y.104 E61.23728
%G1 Z9.853 X5.964 Y.733 E61.26289
%G1 Z9.858 X5.878 Y1.248 E61.2841
%G1 Z9.863 X5.715 Y1.857 E61.3097
%G1 Z9.868 X5.489 Y2.444 E61.33525
%G1 Z9.873 X5.203 Y3.005 E61.36082
%G1 Z9.877 X4.923 Y3.446 E61.38204
%G1 Z9.882 X4.534 Y3.943 E61.40767
%G1 Z9.886 X4.174 Y4.322 E61.4289
%G1 Z9.890 X3.782 Y4.669 E61.45016
%G1 Z9.895 X3.272 Y5.04 E61.47577
%G1 Z9.899 X2.822 Y5.305 E61.49698
%G1 Z9.904 X2.25 Y5.572 E61.52262
%G1 Z9.908 X1.758 Y5.746 E61.54381
%G1 Z9.913 X1.147 Y5.898 E61.56938
%G1 Z9.918 X.524 Y5.986 E61.59493
%G1 Z9.923 X-.105 Y6.008 E61.62049
%G1 Z9.928 X-.733 Y5.964 E61.64606
%G1 Z9.933 X-1.249 Y5.878 E61.66731
%G1 Z9.937 X-1.847 Y5.718 E61.69245
%G1 Z9.942 X-2.347 Y5.531 E61.71413
%G1 Z9.947 X-2.904 Y5.261 E61.73927
%G1 Z9.950 X-3.263 Y5.041 E61.75637
%;LAYER_CHANGE
%;Z:10.25
%;HEIGHT:0.3
%G1 Z9.950 F7800
%G1 F900
%G1 Z9.951 X-3.36 Y4.981 E61.76102
%G1 Z9.956 X-3.862 Y4.603 E61.78654
%G1 Z9.961 X-4.323 Y4.173 E61.81214
%G1 Z9.965 X-4.669 Y3.782 E61.83334
%G1 Z9.970 X-5.039 Y3.273 E61.8589
%G1 Z9.975 X-5.354 Y2.727 E61.8845
%G1 Z9.979 X-5.571 Y2.252 E61.90571
%G1 Z9.984 X-5.776 Y1.656 E61.93131
%G1 Z9.989 X-5.916 Y1.051 E61.95653
%G1 Z9.993 X-5.986 Y.524 E61.97812
%G1 Z9.998 X-6.008 Y-.105 E62.00368
%G1 Z10.003 X-5.965 Y-.724 E62.02888
%G1 Z10.008 X-5.878 Y-1.249 E62.05049
%G1 Z10.013 X-5.715 Y-1.857 E62.07605
%G1 Z10.018 X-5.492 Y-2.437 E62.10129
%G1 Z10.022 X-5.256 Y-2.912 E62.12283
%G1 Z10.027 X-4.922 Y-3.447 E62.14844
%G1 Z10.031 X-4.604 Y-3.862 E62.16967
%G1 Z10.036 X-4.173 Y-4.323 E62.1953
%G1 Z10.040 X-3.782 Y-4.669 E62.2165
%G1 Z10.045 X-3.272 Y-5.04 E62.24211
%G1 Z10.049 X-2.822 Y-5.305 E62.26332
%G1 Z10.054 X-2.251 Y-5.571 E62.2889
%G1 Z10.059 X-1.655 Y-5.776 E62.3145
%G1 Z10.063 X-1.147 Y-5.898 E62.33572
%G1 Z10.068 X-.524 Y-5.986 E62.36127
%G1 Z10.073 X.097 Y-6.008 E62.38651
%G1 Z10.078 X.627 Y-5.976 E62.40807
%G1 Z10.083 X1.25 Y-5.877 E62.43369
%G1 Z10.087 X1.756 Y-5.746 E62.45492
%G1 Z10.092 X2.349 Y-5.531 E62.48054
%G1 Z10.096 X2.82 Y-5.306 E62.50174
%G1 Z10.101 X3.36 Y-4.981 E62.52734
%G1 Z10.106 X3.862 Y-4.603 E62.55286
%G1 Z10.111 X4.323 Y-4.173 E62.57846
%G1 Z10.115 X4.669 Y-3.782 E62.59966
%G1 Z10.120 X5.039 Y-3.273 E62.62522
%G1 Z10.125 X5.35 Y-2.735 E62.65046
%G1 Z10.129 X5.571 Y-2.252 E62.67203
%G1 Z10.134 X5.776 Y-1.656 E62.69763
%G1 Z10.139 X5.916 Y-1.051 E62.72285
%G1 Z10.143 X5.986 Y-.524 E62.74444
%G1 Z10.148 X6.008 Y.105 E62.77
%G1 Z10.153 X5.964 Y.733 E62.79557
%G1 Z10.158 X5.878 Y1.248 E62.81678
%G1 Z10.163 X5.715 Y1.857 E62.84238
%G1 Z10.168 X5.492 Y2.437 E62.86762
%G1 Z10.172 X5.256 Y2.912 E62.88916
%G1 Z10.177 X4.922 Y3.447 E62.91477
%G1 Z10.181 X4.604 Y3.862 E62.936
%G1 Z10.186 X4.173 Y4.323 E62.96163
%G1 Z10.190 X3.782 Y4.669 E62.98283
%G1 Z10.195 X3.272 Y5.04 E63.00844
%G1 Z10.199 X2.822 Y5.305 E63.02965
%G1 Z10.204 X2.25 Y5.572 E63.05529
%G1 Z10.208 X1.758 Y5.746 E63.07648
%G1 Z10.213 X1.147 Y5.898 E63.10205
%G1 Z10.218 X.524 Y5.986 E63.1276
%G1 Z10.223 X-.105 Y6.008 E63.15316
%G1 Z10.228 X-.733 Y5.964 E63.17873
%G1 Z10.233 X-1.249 Y5.878 E63.19998
%G1 Z10.237 X-1.756 Y5.746 E63.22126
%G1 Z10.242 X-2.349 Y5.531 E63.24688
%G1 Z10.246 X-2.82 Y5.306 E63.26808
%G1 Z10.250 X-3.262 Y5.04 E63.28903
%;LAYER_CHANGE
%;Z:10.55
%;HEIGHT:0.3
%G1 Z10.250 F7800
%G1 F900
%G1 Z10.252 X-3.447 Y4.922 E63.29793
%G1 Z10.257 X-3.938 Y4.538 E63.32325
%G1 Z10.261 X-4.322 Y4.174 E63.34474
%G1 Z10.265 X-4.669 Y3.782 E63.366
%G1 Z10.270 X-5.04 Y3.272 E63.39161
%G1 Z10.274 X-5.305 Y2.822 E63.41282
%G1 Z10.279 X-5.571 Y2.251 E63.4384
%G1 Z10.284 X-5.776 Y1.656 E63.46396
%G1 Z10.289 X-5.917 Y1.048 E63.48931
%G1 Z10.293 X-5.986 Y.525 E63.51073
%G1 Z10.298 X-6.008 Y-.105 E63.53633
%G1 Z10.303 X-5.965 Y-.727 E63.56165
%G1 Z10.308 X-5.878 Y-1.249 E63.58314
%G1 Z10.313 X-5.715 Y-1.857 E63.6087
%G1 Z10.318 X-5.491 Y-2.439 E63.63403
%G1 Z10.322 X-5.256 Y-2.912 E63.65548
%G1 Z10.327 X-4.922 Y-3.446 E63.68106
%G1 Z10.332 X-4.538 Y-3.938 E63.70641
%G1 Z10.336 X-4.174 Y-4.322 E63.7279
%G1 Z10.340 X-3.782 Y-4.669 E63.74916
%G1 Z10.345 X-3.273 Y-5.039 E63.77472
%G1 Z10.350 X-2.732 Y-5.352 E63.8001
%G1 Z10.354 X-2.251 Y-5.571 E63.82156
%G1 Z10.358 X-1.758 Y-5.746 E63.84281
%G1 Z10.363 X-1.147 Y-5.898 E63.86838
%G1 Z10.368 X-.524 Y-5.986 E63.89393
%G1 Z10.373 X.1 Y-6.008 E63.91929
%G1 Z10.378 X.627 Y-5.976 E63.94073
%G1 Z10.383 X1.25 Y-5.877 E63.96635
%G1 Z10.387 X1.756 Y-5.746 E63.98758
%G1 Z10.392 X2.348 Y-5.531 E64.01316
%G1 Z10.397 X2.913 Y-5.255 E64.0387
%G1 Z10.402 X3.442 Y-4.925 E64.06402
%G1 Z10.406 X3.862 Y-4.604 E64.08549
%G1 Z10.411 X4.323 Y-4.173 E64.11112
%G1 Z10.415 X4.669 Y-3.782 E64.13232
%G1 Z10.420 X5.039 Y-3.273 E64.15788
%G1 Z10.425 X5.354 Y-2.728 E64.18345
%G1 Z10.430 X5.61 Y-2.153 E64.20901
%G1 Z10.434 X5.776 Y-1.657 E64.23025
%G1 Z10.439 X5.917 Y-1.043 E64.25584
%G1 Z10.444 X5.994 Y-.424 E64.28117
%G1 Z10.448 X6.008 Y.104 E64.30262
%G1 Z10.453 X5.965 Y.727 E64.32798
%G1 Z10.458 X5.878 Y1.249 E64.34947
%G1 Z10.463 X5.715 Y1.857 E64.37503
%G1 Z10.468 X5.491 Y2.439 E64.40036
%G1 Z10.472 X5.256 Y2.912 E64.42181
%G1 Z10.477 X4.922 Y3.446 E64.44739
%G1 Z10.482 X4.534 Y3.943 E64.473
%G1 Z10.486 X4.174 Y4.322 E64.49423
%G1 Z10.490 X3.782 Y4.669 E64.51549
%G1 Z10.495 X3.272 Y5.04 E64.5411
%G1 Z10.499 X2.822 Y5.305 E64.56231
%G1 Z10.504 X2.25 Y5.572 E64.58795
%G1 Z10.508 X1.758 Y5.746 E64.60914
%G1 Z10.513 X1.147 Y5.898 E64.63471
%G1 Z10.518 X.524 Y5.986 E64.66026
%G1 Z10.523 X-.106 Y6.008 E64.68586
%G1 Z10.528 X-.627 Y5.976 E64.70706
%G1 Z10.533 X-1.249 Y5.877 E64.73264
%G1 Z10.538 X-1.857 Y5.715 E64.75819
%G1 Z10.543 X-2.439 Y5.491 E64.78352
%G1 Z10.547 X-2.912 Y5.256 E64.80497
%G1 Z10.550 X-3.261 Y5.038 E64.82168
%;LAYER_CHANGE
%;Z:10.85
%;HEIGHT:0.3
%G1 Z10.550 F7800
%G1 F900
%G1 Z10.552 X-3.446 Y4.922 E64.83055
%G1 Z10.557 X-3.943 Y4.534 E64.85616
%G1 Z10.561 X-4.322 Y4.174 E64.87739
%G1 Z10.565 X-4.669 Y3.782 E64.89865
%G1 Z10.570 X-5.039 Y3.273 E64.92421
%G1 Z10.575 X-5.353 Y2.73 E64.94968
%G1 Z10.579 X-5.571 Y2.252 E64.97102
%G1 Z10.584 X-5.776 Y1.656 E64.99662
%G1 Z10.589 X-5.917 Y1.045 E65.02209
%G1 Z10.593 X-5.986 Y.525 E65.04339
%G1 Z10.598 X-6.008 Y-.105 E65.06899
%G1 Z10.603 X-5.964 Y-.73 E65.09444
%G1 Z10.608 X-5.878 Y-1.248 E65.11577
%G1 Z10.613 X-5.715 Y-1.857 E65.14137
%G1 Z10.618 X-5.49 Y-2.442 E65.16683
%G1 Z10.622 X-5.256 Y-2.912 E65.18815
%G1 Z10.627 X-4.922 Y-3.446 E65.21373
%G1 Z10.632 X-4.536 Y-3.941 E65.23922
%G1 Z10.636 X-4.174 Y-4.322 E65.26056
%G1 Z10.640 X-3.782 Y-4.669 E65.28182
%G1 Z10.645 X-3.273 Y-5.039 E65.30738
%G1 Z10.650 X-2.73 Y-5.353 E65.33285
%G1 Z10.654 X-2.252 Y-5.571 E65.35419
%G1 Z10.659 X-1.658 Y-5.775 E65.3797
%G1 Z10.663 X-1.147 Y-5.898 E65.40105
%G1 Z10.668 X-.524 Y-5.986 E65.4266
%G1 Z10.673 X.103 Y-6.008 E65.45208
%G1 Z10.678 X.627 Y-5.976 E65.4734
%G1 Z10.683 X1.25 Y-5.877 E65.49902
%G1 Z10.687 X1.756 Y-5.746 E65.52025
%G1 Z10.692 X2.348 Y-5.531 E65.54583
%G1 Z10.697 X2.913 Y-5.255 E65.57137
%G1 Z10.702 X3.445 Y-4.923 E65.59684
%G1 Z10.706 X3.862 Y-4.604 E65.61816
%G1 Z10.711 X4.323 Y-4.173 E65.64379
%G1 Z10.715 X4.669 Y-3.782 E65.66499
%G1 Z10.720 X5.039 Y-3.273 E65.69055
%G1 Z10.725 X5.353 Y-2.73 E65.71602
%G1 Z10.729 X5.571 Y-2.252 E65.73736
%G1 Z10.734 X5.776 Y-1.655 E65.763
%G1 Z10.738 X5.898 Y-1.147 E65.78422
%G1 Z10.743 X5.986 Y-.524 E65.80977
%G1 Z10.748 X6.008 Y.105 E65.83533
%G1 Z10.753 X5.964 Y.73 E65.86078
%G1 Z10.758 X5.878 Y1.249 E65.88215
%G1 Z10.763 X5.714 Y1.858 E65.90776
%G1 Z10.767 X5.531 Y2.347 E65.92896
%G1 Z10.772 X5.256 Y2.911 E65.95444
%G1 Z10.776 X4.982 Y3.359 E65.97577
%G1 Z10.781 X4.603 Y3.862 E66.00135
%G1 Z10.786 X4.173 Y4.323 E66.02695
%G1 Z10.790 X3.782 Y4.669 E66.04815
%G1 Z10.795 X3.272 Y5.04 E66.07376
%G1 Z10.799 X2.822 Y5.305 E66.09497
%G1 Z10.804 X2.25 Y5.572 E66.12061
%G1 Z10.808 X1.758 Y5.746 E66.1418
%G1 Z10.813 X1.147 Y5.898 E66.16737
%G1 Z10.818 X.524 Y5.986 E66.19292
%G1 Z10.823 X-.106 Y6.008 E66.21852
%G1 Z10.828 X-.627 Y5.976 E66.23972
%G1 Z10.833 X-1.249 Y5.877 E66.2653
%G1 Z10.838 X-1.857 Y5.715 E66.29085
%G1 Z10.843 X-2.445 Y5.489 E66.31643
%G1 Z10.847 X-2.912 Y5.256 E66.33763
%G1 Z10.850 X-3.261 Y5.038 E66.35434
%G1 E64.35434 F2400
%G92 E0
%M107
%;TYPE:Custom
%; Filament-specific end gcode 
%;END gcode for filament
%M104 S0 ; turn off temperature
%G28 X0  ; home X axis
%M84     ; disable motors
%; objects_info = {"objects":[]}
%; filament used [mm] = 102.28
%; filament used [cm3] = 0.25
%; total filament used [g] = 0.00
%; total filament cost = 0.00
%; total filament used for wipe tower [g] = 0.00
%; estimated printing time (normal mode) = 2m 30s
%; estimated first layer printing time (normal mode) = 18s
%
%; prusaslicer_config = begin
%; arc_fitting = disabled
%; autoemit_temperature_commands = 1
%; automatic_extrusion_widths = 0
%; automatic_infill_combination = 0
%; automatic_infill_combination_max_layer_height = 100%
%; avoid_crossing_curled_overhangs = 0
%; avoid_crossing_perimeters = 0
%; avoid_crossing_perimeters_max_detour = 0
%; bed_custom_model = 
%; bed_custom_texture = 
%; bed_shape = -55x-55,55x-55,55x55,-55x55
%; bed_temperature = 0
%; bed_temperature_extruder = 0
%; before_layer_gcode = 
%; between_objects_gcode = 
%; binary_gcode = 0
%; bottom_fill_pattern = monotonic
%; bottom_solid_layers = 3
%; bottom_solid_min_thickness = 0
%; bridge_acceleration = 0
%; bridge_angle = 0
%; bridge_fan_speed = 100
%; bridge_flow_ratio = 1
%; bridge_speed = 60
%; brim_separation = 0
%; brim_type = outer_only
%; brim_width = 0
%; chamber_minimal_temperature = 0
%; chamber_temperature = 0
%; color_change_gcode = M600
%; colorprint_heights = 
%; complete_objects = 0
%; cooling = 0
%; cooling_perimeter_transition_distance = 0
%; cooling_slowdown_logic = uniform_cooling
%; cooling_tube_length = 5
%; cooling_tube_retraction = 91.5
%; custom_parameters_filament = ""
%; custom_parameters_print = 
%; custom_parameters_printer = 
%; default_acceleration = 0
%; default_filament_profile = 
%; default_print_profile = 
%; deretract_speed = 0
%; disable_fan_first_layers = 3
%; dont_support_bridges = 1
%; draft_shield = disabled
%; duplicate_distance = 6
%; elefant_foot_compensation = 0
%; enable_dynamic_fan_speeds = 0
%; enable_dynamic_overhang_speeds = 0
%; end_filament_gcode = "; Filament-specific end gcode \n;END gcode for filament\n"
%; end_gcode = M104 S0 ; turn off temperature\nG28 X0  ; home X axis\nM84     ; disable motors\n
%; ensure_vertical_shell_thickness = enabled
%; external_perimeter_acceleration = 0
%; external_perimeter_extrusion_width = 0.39
%; external_perimeter_speed = 50%
%; external_perimeters_first = 0
%; extra_loading_move = -2
%; extra_perimeters = 1
%; extra_perimeters_on_overhangs = 0
%; extruder_clearance_height = 20
%; extruder_clearance_radius = 20
%; extruder_colour = ""
%; extruder_offset = 0x0
%; extrusion_axis = E
%; extrusion_multiplier = 1
%; extrusion_width = 0.39
%; fan_always_on = 0
%; fan_below_layer_time = 60
%; filament_abrasive = 0
%; filament_colour = #29B2B2
%; filament_cooling_final_speed = 3.4
%; filament_cooling_initial_speed = 2.2
%; filament_cooling_moves = 4
%; filament_cost = 0
%; filament_density = 0
%; filament_deretract_speed = nil
%; filament_diameter = 1.75
%; filament_infill_max_crossing_speed = 0
%; filament_infill_max_speed = 0
%; filament_load_time = 0
%; filament_loading_speed = 28
%; filament_loading_speed_start = 3
%; filament_max_volumetric_speed = 0
%; filament_minimal_purge_on_wipe_tower = 15
%; filament_multitool_ramming = 0
%; filament_multitool_ramming_flow = 10
%; filament_multitool_ramming_volume = 10
%; filament_notes = ""
%; filament_purge_multiplier = 100%
%; filament_ramming_parameters = "120 100 6.6 6.8 7.2 7.6 7.9 8.2 8.7 9.4 9.9 10.0| 0.05 6.6 0.45 6.8 0.95 7.8 1.45 8.3 1.95 9.7 2.45 10 2.95 7.6 3.45 7.6 3.95 7.6 4.45 7.6 4.95 7.6"
%; filament_retract_before_travel = nil
%; filament_retract_before_wipe = nil
%; filament_retract_layer_change = 0
%; filament_retract_length = nil
%; filament_retract_length_toolchange = nil
%; filament_retract_lift = nil
%; filament_retract_lift_above = nil
%; filament_retract_lift_below = nil
%; filament_retract_restart_extra = nil
%; filament_retract_restart_extra_toolchange = nil
%; filament_retract_speed = nil
%; filament_seam_gap_distance = nil
%; filament_settings_id = "My Settings"
%; filament_shrinkage_compensation_xy = 0%
%; filament_shrinkage_compensation_z = 0%
%; filament_soluble = 0
%; filament_spool_weight = 0
%; filament_stamping_distance = 0
%; filament_stamping_loading_speed = 20
%; filament_toolchange_delay = 0
%; filament_travel_lift_before_obstacle = nil
%; filament_travel_max_lift = nil
%; filament_travel_ramping_lift = nil
%; filament_travel_slope = nil
%; filament_type = PLA
%; filament_unload_time = 0
%; filament_unloading_speed = 90
%; filament_unloading_speed_start = 100
%; filament_vendor = (Unknown)
%; filament_wipe = nil
%; fill_angle = 45
%; fill_density = 0%
%; fill_pattern = stars
%; first_layer_acceleration = 0
%; first_layer_acceleration_over_raft = 0
%; first_layer_bed_temperature = 0
%; first_layer_extrusion_width = 0.37
%; first_layer_height = 0.35
%; first_layer_infill_speed = 0
%; first_layer_speed = 30
%; first_layer_speed_over_raft = 30
%; first_layer_temperature = 200
%; full_fan_speed_layer = 0
%; fuzzy_skin = none
%; fuzzy_skin_point_dist = 0.8
%; fuzzy_skin_thickness = 0.3
%; gap_fill_enabled = 1
%; gap_fill_speed = 20
%; gcode_comments = 0
%; gcode_flavor = smoothie
%; gcode_label_objects = disabled
%; gcode_resolution = 0.0125
%; gcode_substitutions = 
%; high_current_on_filament_swap = 0
%; host_type = prusalink
%; idle_temperature = nil
%; infill_acceleration = 0
%; infill_anchor = 600%
%; infill_anchor_max = 50
%; infill_every_layers = 1
%; infill_extruder = 1
%; infill_extrusion_width = 0.39
%; infill_first = 0
%; infill_overlap = 25%
%; infill_speed = 80
%; interface_shells = 0
%; interlocking_beam = 0
%; interlocking_beam_layer_count = 2
%; interlocking_beam_width = 0.8
%; interlocking_boundary_avoidance = 2
%; interlocking_depth = 2
%; interlocking_orientation = 22.5
%; ironing = 0
%; ironing_flowrate = 15%
%; ironing_spacing = 0.1
%; ironing_speed = 15
%; ironing_type = top
%; layer_gcode = 
%; layer_height = 0.3
%; machine_limits_usage = time_estimate_only
%; machine_max_acceleration_e = 10000,5000
%; machine_max_acceleration_extruding = 1500,1250
%; machine_max_acceleration_retracting = 1500,1250
%; machine_max_acceleration_travel = 1500,1250
%; machine_max_acceleration_x = 9000,1000
%; machine_max_acceleration_y = 9000,1000
%; machine_max_acceleration_z = 500,200
%; machine_max_feedrate_e = 120,120
%; machine_max_feedrate_x = 500,200
%; machine_max_feedrate_y = 500,200
%; machine_max_feedrate_z = 12,12
%; machine_max_jerk_e = 2.5,2.5
%; machine_max_jerk_x = 10,10
%; machine_max_jerk_y = 10,10
%; machine_max_jerk_z = 0.2,0.4
%; machine_max_junction_deviation = 0,0
%; machine_min_extruding_rate = 0,0
%; machine_min_travel_rate = 0,0
%; max_fan_speed = 100
%; max_layer_height = 0
%; max_print_height = 50
%; max_print_speed = 80
%; max_volumetric_extrusion_rate_slope_negative = 0
%; max_volumetric_extrusion_rate_slope_positive = 0
%; max_volumetric_speed = 0
%; min_bead_width = 85%
%; min_fan_speed = 35
%; min_feature_size = 25%
%; min_layer_height = 0.07
%; min_print_speed = 10
%; min_skirt_length = 0
%; mmu_segmented_region_interlocking_depth = 0
%; mmu_segmented_region_max_width = 0
%; multimaterial_purging = 140
%; notes = 
%; nozzle_diameter = 0.35
%; nozzle_high_flow = 0
%; only_one_perimeter_first_layer = 0
%; only_retract_when_crossing_perimeters = 0
%; ooze_prevention = 0
%; output_filename_format = [input_filename_base].gcode
%; over_bridge_speed = 0
%; overhang_fan_speed_0 = 0
%; overhang_fan_speed_1 = 0
%; overhang_fan_speed_2 = 0
%; overhang_fan_speed_3 = 0
%; overhang_speed_0 = 15
%; overhang_speed_1 = 15
%; overhang_speed_2 = 20
%; overhang_speed_3 = 25
%; overhangs = 1
%; parking_pos_retraction = 92
%; pause_print_gcode = M601
%; perimeter_acceleration = 0
%; perimeter_extruder = 1
%; perimeter_extrusion_width = 0.39
%; perimeter_generator = arachne
%; perimeter_speed = 60
%; perimeters = 1
%; physical_printer_settings_id = 
%; post_process = 
%; prefer_clockwise_movements = 0
%; print_settings_id = My Settings
%; printer_model = 
%; printer_notes = 
%; printer_settings_id = My Settings
%; printer_technology = FFF
%; printer_variant = 
%; printer_vendor = 
%; raft_contact_distance = 0.1
%; raft_expansion = 1.5
%; raft_first_layer_density = 90%
%; raft_first_layer_expansion = 3
%; raft_layers = 0
%; remaining_times = 0
%; resolution = 0
%; retract_before_travel = 2
%; retract_before_wipe = 0%
%; retract_layer_change = 0
%; retract_length = 2
%; retract_length_toolchange = 10
%; retract_lift = 0
%; retract_lift_above = 0
%; retract_lift_below = 0
%; retract_restart_extra = 0
%; retract_restart_extra_toolchange = 0
%; retract_speed = 40
%; scarf_seam_entire_loop = 0
%; scarf_seam_length = 20
%; scarf_seam_max_segment_length = 1
%; scarf_seam_on_inner_perimeters = 0
%; scarf_seam_only_on_smooth = 1
%; scarf_seam_placement = nowhere
%; scarf_seam_start_height = 0%
%; seam_gap_distance = 15%
%; seam_position = random
%; silent_mode = 1
%; single_extruder_multi_material = 0
%; single_extruder_multi_material_priming = 1
%; skirt_distance = 6
%; skirt_height = 1
%; skirts = 1
%; slice_closing_radius = 0.049
%; slicing_mode = regular
%; slowdown_below_layer_time = 5
%; small_perimeter_speed = 15
%; solid_infill_acceleration = 0
%; solid_infill_below_area = 70
%; solid_infill_every_layers = 0
%; solid_infill_extruder = 1
%; solid_infill_extrusion_width = 0.39
%; solid_infill_speed = 20
%; spiral_vase = 1
%; staggered_inner_seams = 0
%; standby_temperature_delta = -5
%; start_filament_gcode = "; Filament gcode\n"
%; start_gcode = G28 ; home all axes\nG1 Z5 F5000 ; lift nozzle\n
%; support_material = 0
%; support_material_angle = 0
%; support_material_auto = 1
%; support_material_bottom_contact_distance = 0
%; support_material_bottom_interface_layers = -1
%; support_material_buildplate_only = 0
%; support_material_closing_radius = 2
%; support_material_contact_distance = 0.2
%; support_material_enforce_layers = 0
%; support_material_extruder = 1
%; support_material_extrusion_width = 0.31
%; support_material_interface_contact_loops = 0
%; support_material_interface_extruder = 1
%; support_material_interface_layers = 3
%; support_material_interface_pattern = rectilinear
%; support_material_interface_spacing = 0
%; support_material_interface_speed = 100%
%; support_material_pattern = rectilinear
%; support_material_spacing = 2.5
%; support_material_speed = 60
%; support_material_style = grid
%; support_material_synchronize_layers = 0
%; support_material_threshold = 0
%; support_material_with_sheath = 1
%; support_material_xy_spacing = 50%
%; support_tree_angle = 40
%; support_tree_angle_slow = 25
%; support_tree_branch_diameter = 2
%; support_tree_branch_diameter_angle = 5
%; support_tree_branch_diameter_double_wall = 3
%; support_tree_branch_distance = 1
%; support_tree_tip_diameter = 0.8
%; support_tree_top_rate = 15%
%; temperature = 200
%; template_custom_gcode = 
%; thick_bridges = 1
%; thin_walls = 0
%; thumbnails = 
%; thumbnails_format = PNG
%; toolchange_gcode = 
%; top_fill_pattern = monotonic
%; top_infill_extrusion_width = 0.35
%; top_one_perimeter_type = none
%; top_solid_infill_acceleration = 0
%; top_solid_infill_speed = 15
%; top_solid_layers = 0
%; top_solid_min_thickness = 0
%; travel_acceleration = 0
%; travel_lift_before_obstacle = 0
%; travel_max_lift = 0
%; travel_ramping_lift = 0
%; travel_short_distance_acceleration = 0
%; travel_slope = 0
%; travel_speed = 130
%; travel_speed_z = 0
%; use_firmware_retraction = 0
%; use_relative_e_distances = 0
%; use_volumetric_e = 0
%; variable_layer_height = 1
%; wall_distribution_count = 1
%; wall_transition_angle = 10
%; wall_transition_filter_deviation = 25%
%; wall_transition_length = 100%
%; wipe = 0
%; wipe_into_infill = 0
%; wipe_into_objects = 0
%; wipe_tower = 0
%; wipe_tower_acceleration = 0
%; wipe_tower_bridging = 10
%; wipe_tower_brim_width = 2
%; wipe_tower_cone_angle = 0
%; wipe_tower_extra_flow = 100%
%; wipe_tower_extra_spacing = 100%
%; wipe_tower_extruder = 0
%; wipe_tower_no_sparse_layers = 0
%; wipe_tower_width = 60
%; wiping_volumes_matrix = 0
%; wiping_volumes_use_custom_matrix = 0
%; xy_size_compensation = 0
%; z_offset = 0
%; prusaslicer_config = end
%
%\end{verbatim}

\subsection{gcodepreviewtemplate.txt}

Throughout this document, examples of commands will be shown and then collected in \verb|gcodepreviewtemplate.txt| for easy copy-pasting (insert old computer joke about how many original Cobol programs have been written).

\lstset{firstnumber=1}%\thegcptmpl}
\begin{writecode}{w}{gcodepreviewtemplate.txt}{python}
#gcptemplate.txt --- this file will collect example usages of each 
#                    command with a brief commentary.

\end{writecode}
\addtocounter{gcptmpl}{3}

\section{gcodepreview}

This library for OpenPythonSCAD works by using Python code to persistently store and access variables which denote the machine position and describe the characteristics of tools, and to write out files while both modeling the motion of a 3-axis \textsc{cnc} machine (note that at least a 4\textsuperscript{th} additional axis may be worked up as a future option and supporting the work-around of two-sided (flip) machining by using an imported file as the Stock or preserving state and affording a second operation seems promising) and if desired, writing out \textsc{dxf} and/or G-code files (as opposed to the normal technique of rendering to a \textsc{3d} model and writing out an \textsc{stl} or \textsc{step} or other model format and using a traditional \textsc{cam} application). There are multiple modes for this, doing so may require loading up to two files:


\begin{itemize}
\item A Python file: gcodepreview.py (\texttt{gcpy}) --- this has
      variables in the traditional sense which are used for tracking machine position and so forth. 
      Note that where it is placed/loaded from will depend on whether it is imported into
      a Python file:\\
      \verb|import gcodepreview_standalone as gcp|\\ 
      or used in an OpenSCAD file:\\
      \verb|use <gcodepreview.py>|\\
      with an additional OpenSCAD module which allows accessing it and that there
      is an option for loading directly from the Github repository implemented in
      PythonSCAD
%\item A second Python file: \verb|gcp.py| which will import the class and then wrap it in procedural 
%      Python commands which may be used from OpenSCAD.
%\item An OpenSCAD file: pygcodepreview.scad (\texttt{pyscad}) --- which wraps the Python code 
%      in OpenSCAD (note that it too is included by \verb|use <pygcodepreview.scad>|)
\item An OpenSCAD file: gcodepreview.scad (\texttt{gcpscad}) --- which \verb|use|s the Python file 
      and which is \texttt{include}d allowing it to access OpenSCAD variables for branching   
\end{itemize}

\noindent Note that this architecture requires that many OpenSCAD modules are essentially ``Dispatchers'' (another term is ``Descriptors'') which pass information from one aspect of the environment to another, but in some instances it is expedient, or even will be necessary to re-write Python definitions in OpenSCAD rather than calling the matching Python function directly.

In earlier versions there were several possible ways to work with the \textsc{3d} models of the cuts, either directly displaying the returned \textsc{3d} model when explicitly called for after storing it in a variable or calling it up as a calculation (Python command \verb|ouput(<foo>)| or OpenSCAD returning a model, or calling an appropriate OpenSCAD command), however as-of v0.9 the tool movements are modeled as lists of \verb|hull()| operations which must be processed as such and are \verb|difference|d from the stock. The templates set up these options as noted, and ensure that \verb|True == true|.
%, and a set of commands are provided to output the stock, toolpaths, or part (toolpaths and rapids differenced from stock).

%\begin{itemize}
%\item \verb|generatepaths = true| --- this has the Python code collect toolpath cuts and rapid movements in variables which are then instantiated by appropriate commands/options (shown in the OpenSCAD template \verb|gcodepreview.scad|)
%\item \verb|generatepaths = false| --- this option affords the user control over how the model elements are handled (shown in the Python template \verb|gcodepreview.py|), one typical approach is to collect the toolpaths (and rapids) into variables and then subtract them from the stock for output
%\end{itemize}

%\noindent This behaviour is handled by the \DescribeVariable{generatepaths} Boolean. If set to \verb|True| then each toolpath/cut will be added to a \DescribeVariable{toolpaths} variable (identified as either \verb|self| or \verb|gcp| depending on the context) which then will be used in the command \DescribeRoutine{stockandtoolpaths}. If this variable is set to \verb|False|, then it will be the responsibility of the user to manage the return of the \textsc{3d} model by the module/routine.

\smallskip

\noindent\textsc{Python coding considerations:} Python style may be checked using a tool such as: \url{https://www.codewof.co.nz/style/python3/}. Not all conventions will necessarily be adhered to --- limiting line length in particular conflicts with the flexibility of Literate Programming. Note that \verb|numpydoc|-style docstrings are added where appropriate to help define the functionality of each defined module in Python. \url{https://numpydoc.readthedocs.io/en/latest/}.

\subsection{Cutviewer}

This problem space, showing the result of cutting stock using tooling in \textsc{3d} has a number of tools addressing it, Camotics (formerly OpenSCAM) is an opensource option. Many tools simply create a wireframe preview such as \url{https://ncviewer.com/}. Cutviewer is a notable commercial program which has a unique approach centered on G-code where specially formatted comments fill in the dimensions needed for showing the \textsc{3d} preview.

\subsubsection{Stock size and placement}

Setting the dimensions of the stock, and placing it in \textsc{3d} space relative to the origin must be done very early in the G-code file.

The CutViewer comments are in the form:

\begin{verbatim}
(STOCK/BLOCK, Length, Width, Height, Origin X, Origin Y, Origin Z)
\end{verbatim}

\includeimage{cutviewer_stocksize.png}

\subsubsection{Tool Shapes}

Cutviewer is unable to show tools which undercut, but other tool shapes are represented in a straight-forward and flexible fashion.

\label{para:normaltooling} Most tooling has quite standard shapes 
as described by their profile as defined in the \verb|toolmovement| command which simply defines/declares their shape and \verb|hull()|s them together:

  \noindent\includegraphics[width=\linewidth/3]{images/tool_square_201.png}%
           \includegraphics[width=\linewidth/3]{images/tool_ball_202.png}%
           \includegraphics[width=\linewidth/3]{images/tool_V_301.png}%

\begin{itemize}
\item Square (\#201 and 102) --- able to cut a flat bottom, perpendicular side and
                                 right angle, their simple and easily understood 
                                 geometry makes them a standard choice 
\item Ballnose (\#202 and 101) --- rounded, they are the standard choice for concave
                                   and organic shapes
\item V tooling (\#301, 302, 311 and 312) --- pointed at the tip, they are available in a
                                         variety of angles and diameters and may be
                                         used for decorative V carving, or for
                                         chamfering or cutting specific angles
\end{itemize}

Note that the module for creating movement of the tool will need to handle all of the different tool shapes, generating a list of \verb|hull()| or \verb|rotate_extrude| commands which describe the \textsc{3d} region which tool movement describes.

\paragraph{Tool/Mill (Square, radiused, ball-nose, and tapered-ball)}

The CutViewer values include:

\begin{verbatim}
TOOL/MILL, Diameter, Corner radius, Height, Taper Angle
\end{verbatim}

\includeimage{cutviewer_tool_mill.png}

\noindent Note that it is possible to use these definitions for a wide variety of tooling, e.g., a Carbide \textsc{3d} \#301 V tool being represented as:

\begin{verbatim}
(TOOL/MILL,0.10, 0.05, 6.35, 45.00)
\end{verbatim}

\paragraph{Corner Rounding, (roundover)} 

One notable tool option which cannot be supported using the Tool/Mill description is corner rounding/roundover tooling:

\begin{verbatim}
TOOL/CRMILL, Diameter1, Diameter2, Radius, Height, Length
\end{verbatim}

\includeimage{cutviewer_corner_round.png}

\paragraph{V shaped tooling (and variations)}

Cutviewer has multiple V shaped tooling definitions:

\begin{itemize}
\item ;TOOL/CHAMFER, Diameter, Point Angle, Height
\item ;TOOL/CHAMFER, Diameter, Point Angle, Height, Chamfer Length (note that this is the definition of a flat-bottomed V tool)
\item ;TOOL/DRILL, Diameter, Point Angle, Height
\item ;TOOL/CDRILL, D1, A1, L, D2, A2, H
\end{itemize}

\noindent Since such tooling may be represented (albeit with a slight compromise which arguably is a nod to the real world) using the Tool/Mill definition from above, it seems unlikely that such tooling definitions will be supported.

\subsection{Module Naming Convention}

\begin{quotation}
\emph{The beginning of wisdom is to call things by their right names.}

--- \textsc{confucius}
\end{quotation}

\noindent Naming modules requires that the conventions of G-code, the various file types which are written to, and the actions which the system takes are all taken into due consideration so as to arrive at a consistent scheme.

%The original implementation required three files and used a convention for prefacing commands with \verb|o| or \verb|p|, but this requirement was obviated in the full Python re-write. The current implentation depends upon the class being instantiated as \verb|gcp| as a sufficent differentation between the Python and the OpenSCAD versions of commands which will otherwise share the same name.

%Note that for certain implementations, where it is necessary for a module to coordinate between Python~and OpenSCAD, in certain cases it will be necessary for there to be three separate  versions: a Python definition for the manipulation of Python variables and any file routines, originally these were identified as \texttt{p}<foo>, but with the use of an object-oriented programming style and dot notation, since v0.7 they will be identified as \verb|gcp.foo| (where \verb|gcp| is the identifier used to import the class); which differentiates the twain sufficiently that the Python function name may be directly re-used (previously an \texttt{o}<foo> OpenSCAD module which will wrap up the Python function call, and lastly a <foo> OpenSCAD module which will be \texttt{<include>}d so as to be able to make use of OpenSCAD variables were required).

Number will be abbreviated as \verb|num| rather than \verb|no|, and the short form will be used internally for variable names, while the compleat word will be used in commands.

In some instances, \verb|the| will be used as a prefix.

Tool \#s where used will be the first argument where possible --- this makes it obvious if they are not used --- the negative consideration, that it then doesn't allow for a usage where a \textsc{default} tool is used is not an issue since the command \verb|currenttoolnumber()| may be used to access that number, and is arguably the preferred mechanism. An exception is when there are multiple tool \#s as when opening a file --- collecting them all at the end is a more straight-forward approach.

In natural languages such as English, there is an order to various parts of speech such as adjectives 
%(determiner, opinion/observation, size, age, shape, color, origin/nationality, material, purpose/qualifier) 
--- since various prefixes and suffixes will be used for module names, having a consistent ordering/usage will help in consistency and make expression clearer. The ordering should be: sequence (if necessary), action, function, parameter, filetype, and where possible a hierarchy of large/general to small/specific should be maintained.

\begin{outline}
\1 Both prefix and suffix
\2 \texttt{dxf} (action (write out to \textsc{dxf} file), filetype)
\1 Prefixes
\2 \texttt{generate} (Boolean) --- used to identify which types of actions will be done (note that in the interest of brevity the check for this will be deferred until the last possible moment, see below)
\2 \texttt{write} (action) --- used to write to files, will include a check for the matching \texttt{generate} command, which being true will cause the write to the file to actually transpire 
%\2 \texttt{begin} (sequence) --- note that sequencing may not be necessary, not having been used in the 0.7 re-write
%\2 \texttt{continue} (sequence)
%\2 \texttt{end} (sequence)
\2 \texttt{cut} (action --- create tool movement removing volume from \textsc{3d} object)
\2 \texttt{extrude} (action) --- \textsc{3d} printing equivalent to cut
%\2 \texttt{move} (action)
\2 \texttt{rapid} (action) --- create tool movement of \textsc{3d} object so as to show any collision or rubbing
\2 \texttt{open} (action (file))
\2 \texttt{close} (action (file))
\2 \texttt{set} (action/function) --- note that the matching \verb|get| is implicit in functions which return variables, e.g., \verb|xpos()|
\2 \texttt{current}
\1 Nouns (geometry/shapes)
\2 \texttt{arc}
\2 \texttt{line}
\2 \texttt{rectangle}
\2 \texttt{circle}
%\2 \texttt{Bézier} --- a possible future addition, will likely be rendered \verb|bezier|, or possibly \verb|curve| so as to match the nomenclature of Carbide Create
\1 Suffixes
\2 \texttt{feed} (parameter)
\2 \texttt{gcode/gc} (filetype)
\2 \texttt{pos} --- position
\2 \texttt{tool}
\2 \texttt{loop}
\2 \texttt{CC/CW}
\2 \texttt{number/num} --- note that \verb|num| is used internally for variable names, while \verb|number| will be used for module/function names, making it straight-forward to ensure that functions and variables have different names for purposes of scope
%\2 \texttt{polyline) (file (element))}
\end{outline}

\noindent Further note that commands which are implicitly for the generation of G-code, such as \verb|toolchange()| will omit \verb|gc| for the sake of conciseness.

In theory, this means that the basic \verb|cut...| and associated commands exist (or potentially exist) in the following forms and have matching versions which may be used when programming in Python or OpenSCAD:

\begin{center}
\noindent\begin{tabular}{lllllll}\toprule
& \multicolumn{3}{c}{line} & \multicolumn{3}{c}{arc}
\\\cmidrule(lr){2-4}\cmidrule(lr){5-7}
      & \multicolumn{1}{c}{cut}& \multicolumn{1}{c}{dxf}& \multicolumn{1}{c}{gcode}& \multicolumn{1}{c}{cut}& \multicolumn{1}{c}{dxf}& \multicolumn{1}{c}{gcode}\\\midrule
cut   & cutline\hphantom{dxf}  &                        &  cutlinegc               & cutarc\hphantom{dxf}   &                        & cutarcgc            \\
dxf   & cutlinedxf             & dxfline\hphantom{gc}   &                          & cutarcdxf              & dxfarc\hphantom{gc}    &                     \\
gcode & cutlinegc              & \hphantom{dxflinegc}   & linegc\hphantom{cut}     & cutarcgc               & \hphantom{dxfarcgc}    & arcgc\hphantom{cut} \\\cmidrule(ll){2-4}\cmidrule(ll){5-7}
& \multicolumn{3}{c}{cutlinedxfgc}                                         & \multicolumn{3}{c}{cutarcdxfgc}\\\bottomrule
\end{tabular}
\end{center}

\noindent Note that certain commands (\verb|dxflinegc|, \verb|dxfarcgc|, \verb|linegc|, \verb|arcgc|) are either redundant or unlikely to be needed, and will most likely not be implemented (it seems contradictory that one would write out a move command to a G-code file without making that cut in the \textsc{3d} preview). Note that there may be additional versions as required for the convenience of notation or cutting, in particular, a set of \verb|cutarc|<quadrant><direction>\verb|gc| commands was warranted during the initial development of \verb|arc|-related commands.

The gcode and dxf columns and the matter of having specific commands which encompass those file types is tied up in having the internal variables \DescribeVariable{generategcode}, \DescribeVariable{generatedxf} and implementations, and a strong argument could be made that this should simply be handled by \verb|if...then| structures using those variables. The addition of a \DescribeVariable{generatecut} variable adds the necessary symmetry. Note that an early option to output a separate file for each tool used has since been deprecated and will eventually be removed. In its place there is a mechanism where each colour is offset by the stock dimensions multiplied by the colour number, so that they are arrayed on a diagonal --- when opened each such set of objects may then be easily selected and moved to the appropriate layer, then aligned against the stock.

A further consideration is that when processing G-code it is typical for a given command to be minimal and only include the axis of motion for the end-position, so for each of the above which is likely to appear in a \verb|.nc/.gcode| file, it will be necessary to have a matching command for the combinatorial possibilities, hence:

\begin{center}
\noindent\begin{tabular}{ll}\toprule
cutlineXYZ  & cutlineXYZwithfeed\\
cutlineXY   & cutlineXYwithfeed\\
cutlineXZ   & cutlineXZwithfeed\\
cutlineYZ   & cutlineYZwithfeed\\
cutlineX    & cutlineXwithfeed\\
cutlineY    & cutlineYwithfeed\\
cutlineZ    & cutlineZwithfeed\\\bottomrule
\end{tabular}
\end{center}

Principles for naming modules (and variables):

\begin{itemize}
\item minimize use of underscores (for convenience sake, underscores are not used for index entries)
\item identify which aspect of the project structure is being worked with (\texttt{cut}(ting), 
      \texttt{dxf}, \texttt{gcode}, \texttt{tool}, etc.) note the \verb|gcodepreview| class which will 
      normally be imported as \verb|gcp| so that module \verb|<foo>| will be called as
      \verb|gcp.<foo>| from Python and by the same \verb|<foo>| in OpenSCAD
\end{itemize}

%the use of \texttt{o}(penscad) and \texttt{p}(ython) as prefixes, though the latter is  not necessary for definitions within 

The following commands for various shapes either have been implemented (\verb|monospace|) or have not yet been implemented, but likely will need to be (regular type):

\begin{itemize}
\item rectangle
\subitem \texttt{cutrectangle}
\subitem \texttt{cutrectangleround}
\end{itemize}

%As noted above, PythonSCAD requires that the current toolpath be either returned or stored in a variable (which can then be subtracted from the stock).
% using OpenSCAD will instead have the toolpaths output in a structure which is differenced from the declared stock.

Another consideration is that all commands which write files will check to see if a given filetype is enabled or no, since that check is deferred to the last as noted above for the sake of conciseness.

There are multiple modes for programming PythonSCAD:

\begin{itemize}
\item Python --- in gcodepreview this allows writing out \verb|dxf| files and using mutable variables (this is done in current versions of this project)
\item OpenSCAD --- see: \url{https://openscad.org/documentation.html}
\item Programming in Python, calling Python from OpenSCAD using dispatchers/descriptors (this is done in current versions of this project) 
\item Programming in OpenSCAD with variables and calling Python --- this requires 3 files and was originally used in the project as written up at: \url{https://github.com/WillAdams/gcodepreview/blob/main/gcodepreview-openscad_0_6.pdf} (for further details see below, notably various commented out lines in the source \verb|.tex| file)
\item Programming in OpenSCAD and calling Python where all variables as variables are held in Python classes (this is the technique used up through v0.8)
%\item Programming in OpenSCAD with modules which wrap around Python definitions
\item Programming in Python and calling OpenSCAD --- \url{https://old.reddit.com/r/OpenPythonSCAD/comments/1heczmi/finally_using_scad_modules/}
\end{itemize}

For reference, structurally, when developing OpenSCAD commands which make use of Python variables this was rendered as:

\begin{verbatim}
The user-facing module is \DescribeRoutine{FOOBAR}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module FOOBAR(...) {
    oFOOBAR(...);
}

\end{writecode}
\addtocounter{gcpscad}{4}
 
which calls the internal OpenSCAD Module \DescribeSubroutine{FOOBAR}{oFOOBAR}

\begin{writecode}{a}{pygcodepreview.scad}{scad}
module oFOOBAR(...) {
    pFOOBAR(...);
 }
 
\end{writecode}
\addtocounter{pyscad}{4}

which in turn calls the internal Python definitioon \DescribeSubroutine{FOOBAR}{pFOOBAR}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
def pFOOBAR (...)
    ...
    
\end{writecode}
\addtocounter{gcpy}{3}
\end{verbatim}

Further note that this style of definition might not have been necessary for some later modules since they are in turn calling internal modules which already use this structure.

Lastly note that this style of programming was abandoned in favour of object-oriented dot notation for versions after v0.6 (see below) and that this technique was extended to class nested within another class.

\subsubsection{Parameters and Default Values}

Ideally, there would be \emph{no} hard-coded values --- every value used for calculation will be parameterized, and subject to control/modification. Fortunately, Python affords a feature which specifically addresses this, optional arguments with default values:

\noindent\url{https://stackoverflow.com/questions/9539921/how-do-i-define-a-function-with-optional-arguments}

In short, rather than hard-code numbers, for example in loops, they will be assigned as default values, and thus afford the user/programmer the option of changing them when the module is called. 

%See \DescribeVariable{stepsizearc} and \DescribeVariable{stepsizeroundover}.

\subsection{Implementation files and gcodepreview class}
 
Each file will begin with a comment indicating the file type and further notes/comments on usage where appropriate:

\begin{writecode}{w}{gcodepreview.py}{python}
#!/usr/bin/env python
#icon "C:\Program Files\PythonSCAD\bin\openscad.exe" --trust-python
#Currently tested with https://www.pythonscad.org/downloads/PythonSCAD_nolibfive-2025.06.04-x86-64-Installer.exe and Python 3.11
#gcodepreview (gcpversion)0.93, for use with PythonSCAD, 
#if using from PythonSCAD using OpenSCAD code, see gcodepreview.scad

import sys

# add math functions (sqrt)
import math

# getting openscad functions into namespace
#https://github.com/gsohler/openscad/issues/39
try:
    from openscad import *
except ModuleNotFoundError as e:
    print("OpenSCAD module not loaded.")
    
def pygcpversion():
    thegcpversion = 0.93
    return thegcpversion
 
\end{writecode}
\addtocounter{gcpy}{23}

The OpenSCAD file must \verb|use| the Python file (note that some test/example code is commented out):

\begin{writecode}{w}{gcodepreview.scad}{scad}
//!OpenSCAD
 
//gcodepreview version 0.8
//
//used via include <gcodepreview.scad>;
//

use <gcodepreview.py>

module gcpversion(){
echo(pygcpversion());
}

//function myfunc(var) = gcp.myfunc(var);
//
//function getvv() = gcp.getvv();
//
//module makecube(xdim, ydim, zdim){
//gcp.makecube(xdim, ydim, zdim);
//}
//
//module placecube(){
//gcp.placecube();
//}
//
//module instantiatecube(){
//gcp.instantiatecube();
//}
//
\end{writecode}
\addtocounter{gcpscad}{30}

If all functions are to be handled within Python, then they will need to be gathered into a class which contains them and which is initialized so as to define shared variables and initial program state, and then there will need to be objects/commands for each aspect of the program, each of which will utilise needed variables and will contain appropriate functionality. Note that they will be divided between mandatory and optional functions/variables/objects:

\begin{outline}
\1 Mandatory
   \2 gcodepreview (init)
      \3 generatecut, generatedxf, generategcode
   \2 stocksetup:
      \3 stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero, retract\-height
   \2 gcpfiles: 
      \3 basefilename
   \2 largesquaretool: 
      \3 large\_square\_tool\_num, toolradius, plunge, feed, speed
   \2 currenttoolnum
      \3 endmilltype
      \3 diameter
      \3 flute
      \3 shaftdiameter
      \3 shaftheight
      \3 shaftlength
      \3 toolnumber
      \3 cutcolor
      \3 rapidcolor
      \3 shaftcolor
\1 Optional
   \2 smallsquaretool: 
      \3small\_square\_tool\_num, small\_square\_ratio
   \2 largeballtool: 
      \3 large\_ball\_tool\_num, large\_ball\_ratio
   \2 largeVtool: 
      \3 large\_V\_tool\_num, large\_V\_ratio
   \2 smallballtool: 
      \3 small\_ball\_tool\_num, small\_ball\_ratio
   \2 smallVtool: 
      \3 small\_V\_tool\_num, small\_V\_ratio
   \2 DTtool: 
      \3 DT\_tool\_num, DT\_ratio
   \2 KHtool: 
      \3 KH\_tool\_num, KH\_ratio
   \2 Roundovertool: 
      \3 Roundover\_tool\_num, RO\_ratio
   \2 misctool: 
      \3 MISC\_tool\_num, MISC\_ratio
\end{outline}

The class which is defined is \DescribeRoutine{gcodepreview} which begins with the \DescribeRoutine{init} method which allows passing in and defining the variables which will be used by the other methods in this class. Part of this includes handling various definitions for Boolean values.

\lstset{firstnumber=\thegcptmpl}
\begin{writecode}{w}{gcodepreviewtemplate.txt}{python}
#gcptemplate.txt --- this file will collect example usages of each 
                     command with a brief commentary.
\end{writecode}
\addtocounter{gcptmpl}{94}

\subsubsection{init}

Initialization of the \texttt{gcodepreview} object requires handling a number of different cases, two of which are exclusive to each other. It must also take into account the possibility of being called from OpenSCAD

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
class gcodepreview:

    def __init__(self, 
                 cutorprint = "cut", #"cut", "print", "no_preview"
                 generategcode = False,
                 generatedxf = False,
                 gcpfa = 2,
                 gcpfs = 0.125,
                 steps = 10
                 ):
        """
        Initialize gcodepreview object.
    
        Parameters
        ----------
        cutorprint    : string
                        Enables creation of 3D model for cutting or printing.
        generategcode : boolean
                        Enables writing out G-code.
        generatedxf   : boolean
                        Enables writing out DXF file(s).
        
        Returns
        -------
        object
            The initialized gcodepreview object.
        """
        if cutorprint == "print":
            self.generatecut = False
            self.generateprint = True
            self.gcodefilext = ".gcode"
        elif cutorprint == "cut":
            self.generatecut = True
            self.generateprint = False
            self.gcodefilext = ".nc"
        else: # no_preview
            self.generatecut = False
            self.generateprint = False
        if generategcode == True:
            self.generategcode = True
        elif generategcode == 1:
            self.generategcode = True
        elif generategcode == 0:
            self.generategcode = False
        else:
            self.generategcode = generategcode
        if generatedxf == True:
            self.generatedxf = True
        elif generatedxf == 1:
            self.generatedxf = True
        elif generatedxf == 0:
            self.generatedxf = False
        else:
            self.generatedxf = generatedxf
# unless multiple dxfs are enabled, the check for them is of course False
        self.generatedxfs = False
# set up 3D previewing parameters
        fa = gcpfa
        fs = gcpfs
        self.steps = steps
# initialize the machine state
        self.mc = "Initialized"
        self.mpx = float(0)
        self.mpy = float(0)
        self.mpz = float(0)
        self.tpz = float(0)
# initialize the toolpath state
        self.retractheight = 5
# initialize the DEFAULT tool
        self.currenttoolnum = 102
        self.endmilltype = "square"
        self.diameter = 3.175
        self.flute = 12.7
        self.shaftdiameter = 3.175
        self.shaftheight = 12.7
        self.shaftlength = 19.5
        self.toolnumber = "100036"
        self.cutcolor = "green"
        self.rapidcolor = "orange"
        self.shaftcolor = "red"
# the command definesquaretool(3.175, 12.7, 20) is used in the toolchange command
        self.tooloutline = polygon( points=[[0,0],[3.175,0],[3.175,12.7],[0,12.7]] )
        self.toolprofile = polygon( points=[[0,0],[1.5875,0],[1.5875,12.7],[0,12.7]] )
        self.shaftoutline = polygon( points=[[0,12.7],[3.175,12.7],[3.175,25.4],[0,25.4]] )
        self.shaftprofile = polygon( points=[[0,12.7],[1.5875,12.7],[1.5875,25.4],[0,25.4]] )
        self.currenttoolshape = cylinder(h = self.flute, r = self.shaftdiameter/2)
        sh = cylinder(h = self.flute, r = self.shaftdiameter/2)
        self.currenttoolshaft = sh.translate([0,0,self.flute])
# debug mode requires a variable to track if it is on or off
        self.debugenable = False
# the variables for holding 3D models must be initialized as empty lists so as to ensure that only append or extend commands are used with them
        self.rapids = []
        self.toolpaths = []
        print("gcodepreview class initialized")

#    def myfunc(self, var):
#        self.vv = var * var
#        return self.vv
#
#    def getvv(self):
#        return self.vv
#        
#    def checkint(self):
#        return self.mc
#
#    def makecube(self, xdim, ydim, zdim):
#        self.c=cube([xdim, ydim, zdim])
#        
#    def placecube(self):
#        show(self.c)
#
#    def instantiatecube(self):
#        return self.c

\end{writecode}
\addtocounter{gcpy}{114}

%# in order to use linear/rotate extrude, it is necessary that the tool/shaft profile/outline be defined as a polygon

\subsubsection{Position and Variables}
 
In modeling the machine motion and G-code it will be necessary to have the machine track several variables for machine position, the current tool and its parameters, and the current depth in the current toolpath. This will be done using paired functions (which will set and return the  matching variable) and a matching variable.

\begin{samepage}
The first such variables are for \textsc{xyz} position:

\begin{itemize}
 \item \DescribeVariable{mpx}
 \item \DescribeVariable{mpy}
 \item \DescribeVariable{mpz}
\end{itemize}
\end{samepage}

%\begin{samepage}
\noindent Similarly, for some toolpaths it will be necessary to track the depth along the Z-axis as the toolpath is cut out, or the increment which a cut advances --- this is done using an internal variable, \DescribeVariable{tpzinc}.
% 
%\begin{itemize}
% \item \DescribeVariable{tpz} 
% \item \DescribeVariable{tpzinc}
%\end{itemize}
%\end{samepage}

\begin{samepage}

It will further be necessary to have a variable for the current tool:

\begin{itemize}
 \item \DescribeVariable{currenttoolnum}
\end{itemize}
\end{samepage}

\noindent Note that the \verb|currenttoolnum| variable should always be accessed and used for any specification of a tool, being read in whenever a tool is to be made use of, or a parameter or aspect of the tool needs to be used in a calculation. %(Which implies that the tool parameters in modules other than \verb|toolchange(tool_number, speed)|; should be removed.)

In early versions, the implicit union of the \textsc{3d} model of the tool was available and used where appropriate, but in v0.9, this was changed to using lists for concatenating the \verb|hull|ed shapes of tool movements, so the module, \DescribeRoutine{toolmovement} which given begin/end position returns the appropriate shape(s) as a list.

The \textsc{3d} model of the tool is stored in \DescribeVariable{currenttool}.

It will be necessary to have Python functions (\DescribeRoutine{xpos}, \DescribeRoutine{ypos}, and \DescribeRoutine{zpos}) which return the current values of the machine position in Cartesian coordinates: 

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def xpos(self):
        return self.mpx

    def ypos(self):
        return self.mpy

    def zpos(self):
        return self.mpz

\end{writecode}
\addtocounter{gcpy}{9}

Wrapping these in OpenSCAD functions allows use of this positional information from OpenSCAD:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
function xpos() = gcp.xpos();

function ypos() = gcp.ypos();

function zpos() = gcp.zpos();

\end{writecode}
\addtocounter{gcpscad}{6}

\noindent and in turn, functions which set the positions: 
\DescribeRoutine{setxpos}, 
\DescribeRoutine{setypos}, and
\DescribeRoutine{setzpos}.%, and

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setxpos(self, newxpos):
        self.mpx = newxpos

    def setypos(self, newypos):
        self.mpy = newypos

    def setzpos(self, newzpos):
        self.mpz = newzpos

\end{writecode}
\addtocounter{gcpy}{9}

\noindent Using the \verb|set...| routines will afford a single point of control if specific actions are found to be contingent on changes to these positions.
%and as noted above, there need to be matching OpenSCAD versions which will set: \DescribeRoutine{setxpos}, \DescribeRoutine{setypos}, and \DescribeRoutine{setzpos}. 
%Note that for routines where the variable is directly passed from OpenSCAD to Python it is possible to have OpenSCAD directly call the matching Python module with no need to use an intermediary OpenSCAD module.

%For each intended command it will be necessary to implement an appropriate aspect in each file. The Python file will manage the Python variables and handle things which can only be done in Python, while there will be two OpenSCAD files as noted above, one which calls the Python code (this will be \texttt{use}d), while the other will be able to access and use OpenSCAD variables, as well as implement Customizer options (this will be \texttt{include}d).

\subsubsection{Initial Modules}

Initializing the machine state requires zeroing out the three machine position variables:

\begin{itemize}
\item mpx
\item mpy
\item mpz
\end{itemize}

\noindent Rather than a specific command for this, the code will be in-lined where appropriate (note that if machine initialization becomes sufficiently complex to warrant it, then a suitable command will need to be coded). Note that the variables are declared in the \verb|__init__| of the class.

The \DescribeRoutine{toolmovement} class requires that the tool be defined in terms of \DescribeVariable{endmilltype}, \DescribeVariable{diameter}, \DescribeVariable{flute} (length), \DescribeVariable{ra} (radius or angle depending on context), and \DescribeVariable{tip}, and there is a mechanism which defines an internal tool number as described below. Currently though, the interface calls the \verb|toolchange| routine passing in a manufacturer tool number as an expedient/default/initial option.

There are two variables to record \DescribeRoutine{toolmovement}, \DescribeVariable{rapids} and \DescribeVariable{toolpaths}. Initialized as empty lists, toolmovements will be \verb|extend|ed to the lists, then for output, the lists will be expanded and subtracted from the stock separately so that rapids are colour-coded so that if there is an interaction with the stock at rapid speed it will be obvious. A similar method should be implemented for the shafts of tooling.

\paragraph{setupstock}

The first such setup subroutine is \DescribeSubroutine{setupstock}{gcodepreview} \DescribeRoutine{setupstock} which is appropriately enough, to set up the stock, and perform other initializations --- initially, the only thing done in Python was to set the value of the persistent (Python) variables (see \verb|initializemachinestate()| above), but the rewritten standalone version handles all necessary actions.

Since part of a class, it will be called as \DescribeRoutine{gcp.setupstock}. It requires that the user set parameters for stock dimensions and so forth, and will create comments in the G-code (if generating that file is enabled) which incorporate the stock dimensions and its position relative to the zero as set relative to the stock.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setupstock(self, stockXwidth,
                   stockYheight,
                   stockZthickness,
                   zeroheight,
                   stockzero,
                   retractheight):
        """
        Set up blank/stock for material and position/zero.
        
        Parameters
        ----------
        stockXwidth :   float
                        X extent/dimension
        stockYheight :  float
                        Y extent/dimension
        stockZthickness : boolean
                        Z extent/dimension
        zeroheight :    string
                        Top or Bottom, determines if Z extent will be positive or negative
        stockzero :     string
                        Lower-Left, Center-Left, Top-Left, Center, determines XY position of stock 
        retractheight : float
                        Distance which tool retracts above surface of stock.
        
        Returns
        -------
        none
        """
        self.stockXwidth = stockXwidth
        self.stockYheight = stockYheight
        self.stockZthickness = stockZthickness
        self.zeroheight = zeroheight
        self.stockzero = stockzero
        self.retractheight = retractheight 
        self.stock = cube([stockXwidth, stockYheight, stockZthickness]) 

\end{writecode}
\addtocounter{gcpy}{36}

\noindent A series of \verb|if| statements parse the \DescribeVariable{zeroheight} (Z-axis) and \DescribeVariable{stockzero} (X- and Y-axes) parameters so as to place the stock in place and suitable G-code comments are added for CutViewer.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.zeroheight == "Top":
            if self.stockzero == "Lower-Left":
                self.stock = self.stock.translate([0, 0, -self.stockZthickness])
                if self.generategcode == True:
                    self.writegc("(stockMin:0.00mm, 0.00mm, -", str(self.stockZthickness), "mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth), "mm, ", str(stockYheight), "mm, 0.00mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, 0.00, ", str(self.stockZthickness), ")")
            if self.stockzero == "Center-Left":
                self.stock = self.stock.translate([0, -stockYheight / 2, -stockZthickness])
                if self.generategcode == True:
                    self.writegc("(stockMin:0.00mm, -", str(self.stockYheight/2), "mm, -", str(self.stockZthickness), "mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth), "mm, ", str(self.stockYheight/2), "mm, 0.00mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, ", str(self.stockYheight/2), ", ", str(self.stockZthickness), ")");
            if self.stockzero == "Top-Left":
                self.stock = self.stock.translate([0, -self.stockYheight, -self.stockZthickness])
                if self.generategcode == True:
                    self.writegc("(stockMin:0.00mm, -", str(self.stockYheight), "mm, -", str(self.stockZthickness), "mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth), "mm, 0.00mm, 0.00mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, ", str(self.stockYheight), ", ", str(self.stockZthickness), ")")
            if self.stockzero == "Center":
                self.stock = self.stock.translate([-self.stockXwidth / 2, -self.stockYheight / 2, -self.stockZthickness])
                if self.generategcode == True:
                    self.writegc("(stockMin: -", str(self.stockXwidth/2), ", -", str(self.stockYheight/2), "mm, -", str(self.stockZthickness), "mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth/2), "mm, ", str(self.stockYheight/2), "mm, 0.00mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", ", str(self.stockXwidth/2), ", ", str(self.stockYheight/2), ", ", str(self.stockZthickness), ")")
        if self.zeroheight == "Bottom":
            if self.stockzero == "Lower-Left":
                 self.stock = self.stock.translate([0, 0, 0])
                 if self.generategcode == True:
                     self.writegc("(stockMin:0.00mm, 0.00mm, 0.00mm)")
                     self.writegc("(stockMax:", str(self.stockXwidth), "mm, ", str(self.stockYheight), "mm, ", str(self.stockZthickness), "mm)")
                     self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, 0.00, 0.00)")
            if self.stockzero == "Center-Left":
                self.stock = self.stock.translate([0, -self.stockYheight / 2, 0])
                if self.generategcode == True:
                    self.writegc("(stockMin:0.00mm, -", str(self.stockYheight/2), "mm, 0.00mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth), "mm, ", str(self.stockYheight/2), "mm, -", str(self.stockZthickness), "mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, ", str(self.stockYheight/2), ", 0.00mm)");
            if self.stockzero == "Top-Left":
                self.stock = self.stock.translate([0, -self.stockYheight, 0])
                if self.generategcode == True:
                    self.writegc("(stockMin:0.00mm, -", str(self.stockYheight), "mm, 0.00mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth), "mm, 0.00mm, ", str(self.stockZthickness), "mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", 0.00, ", str(self.stockYheight), ", 0.00)")
            if self.stockzero == "Center":
                self.stock = self.stock.translate([-self.stockXwidth / 2, -self.stockYheight / 2, 0])
                if self.generategcode == True:
                    self.writegc("(stockMin: -", str(self.stockXwidth/2), ", -", str(self.stockYheight/2), "mm, 0.00mm)")
                    self.writegc("(stockMax:", str(self.stockXwidth/2), "mm, ", str(self.stockYheight/2), "mm, ", str(self.stockZthickness), "mm)")
                    self.writegc("(STOCK/BLOCK, ", str(self.stockXwidth), ", ", str(self.stockYheight), ", ", str(self.stockZthickness), ", ", str(self.stockXwidth/2), ", ", str(self.stockYheight/2), ", 0.00)")
        if self.generategcode == True:
            self.writegc("G90");
            self.writegc("G21");

\end{writecode}
\addtocounter{gcpy}{54}

Note that while the \#102 is declared as a default tool, while it was originally necessary to call a tool change after invoking \verb|setupstock|, in the 2024.09.03 version of PythonSCAD this requirement went away when an update which interfered with persistently setting a variable directly was fixed.

%        self.stock = c.translate([0,0,-stockZthickness])
%Note that the stock will need to be translated using a suitable command as determined by an if statement for the zeroheight variable.

\newglossaryentry{setupstock}
{
    name=setupstock, 
    description={setupstock(200, 100, 8.35, "Top", "Lower-left", 8.35)}
}

\noindent The \gls{setupstock} command is required if working with a \textsc{3d} project, creating the block of stock which the following toolpath commands will cut away. Note that since Python in OpenPythonSCAD defers output of the \textsc{3d} model, it is possible to define it once, then set up all the specifics for each possible positioning of the stock in terms of origin.

The OpenSCAD version is simply a descriptor:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module setupstock(stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero, retractheight) {
    gcp.setupstock(stockXwidth, stockYheight, stockZthickness, zeroheight, stockzero, retractheight);
}

\end{writecode}
\addtocounter{gcpscad}{4}

\paragraph{setupcuttingarea}

If processing G-code, the parameters passed in are necessarily different, and there is of course, no need to write out G-code. 

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setupcuttingarea(self, sizeX, sizeY, sizeZ, extentleft, extentfb, extentd):
#        self.initializemachinestate() 
        c=cube([sizeX,sizeY,sizeZ])
        c = c.translate([extentleft,extentfb,extentd])
        self.stock = c
        self.toolpaths = []
        return c
        
\end{writecode}
\addtocounter{gcpy}{8}

\paragraph{debug}

Rather than endlessly add and then comment out \verb|print()| commands, it is easier to have a variable for this, and a command which wraps the command which checks for that:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def debug(self, *args: any, sep: str = " ", end: str = "\n", **print_kwargs) -> None:
        """
        Print debug output if enabled.

        Accepts the same arguments as built-in print (except file is supported via print_kwargs).
        """
        if not self.debugenable:
            return
        # Build the message and print under a lock to avoid interleaving in multithreaded apps
        self.prefix = "DEBUG: "
        msg = self.prefix + sep.join(map(str, args))
        with self._lock:
            print(msg, end=end, **print_kwargs)
        
\end{writecode}
\addtocounter{gcpy}{13}

\noindent Note that it will be necessary to manually use commands such as:

\lstset{firstnumber=\thegcptmpl}
\begin{writecode}{w}{gcodepreviewtemplate.txt}{python}
self.debugenable = True

testvariable = 1

self.outputdebugnote("Current value of testvariable is: ", testvariable)

\end{writecode}
\addtocounter{gcptmpl}{6}

\subsubsection{Adjustments and Additions}

For certain projects and toolpaths it will be helpful to shift the stock, and to add additional pieces to the project.

Shifting the stock is simple:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def shiftstock(self, shiftX, shiftY, shiftZ):
         self.stock = self.stock.translate([shiftX, shiftY, shiftZ])
        
\end{writecode}
\addtocounter{gcpy}{3}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module shiftstock(shiftX, shiftY, shiftZ) {
    gcp.shiftstock(shiftX, shiftY, shiftZ);
}

\end{writecode}
\addtocounter{gcpscad}{4}

\noindent adding stock is similar, but adds the requirement that it include options for shifting the stock:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def addtostock(self, stockXwidth, stockYheight, stockZthickness, 
                         shiftX = 0, 
                         shiftY = 0, 
                         shiftZ = 0):
         addedpart = cube([stockXwidth, stockYheight, stockZthickness])
         addedpart = addedpart.translate([shiftX, shiftY, shiftZ])
         self.stock = self.stock.union(addedpart)
        
\end{writecode}
\addtocounter{gcpy}{8}

\noindent the OpenSCAD module is a descriptor as expected:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module addtostock(stockXwidth, stockYheight, stockZthickness, shiftX, shiftY, shiftZ) {
    gcp.addtostock(stockXwidth, stockYheight, stockZthickness, shiftX, shiftY, shiftZ);
}

\end{writecode}
\addtocounter{gcpscad}{4}

\subsection{Tools and Shapes and Changes}

Originally, it was necessary to return a shape so that modules which use a \verb|<variable>.union| command would function as expected even when the \textsc{3d} model created is stored in a variable.

Due to stack limits in OpenSCAD for the CSG tree, instead, the shapes will be stored in two variables (\DescribeVariable{rapids}, \DescribeVariable{toolpaths}) as lists processed/created using a command \DescribeRoutine{toolmovement} which will subsume all tool related functionality. As other routines need access to information about the current tool, appropriate routines will allow its variables and the specifics of the current tool to be queried. 

It will be necessary to describe the tool in four different fashions:

\begin{itemize}
\item variables --- a full set of variables is required to allow defining a shape and to determine the appropriate fashion in which to treat each tool at need
\subitem tooltype = "mill"
\subitem diameter = first
\subitem cornerradius = second
\subitem height = third
\subitem taperangle 
\subitem length
\item profile --- the profile is a definition of the tool from the centerline to the outer edge which is used when necessary to \verb|rotate_extrude()| the design
\item outline --- the outline is the entire definition of the tool shape which is used when \verb|rotate_extrude|ing an arc (which will also require a \textsc{3d} version of the rotated tool profile at each end)
\item shape --- originally the program used the tool shape and \verb|hull()|ed it from beginning to end of a movement --- having the shape pre-made allows it to be \verb|union()|ed at need.
\end{itemize}

The base/entry functionality has the instance being defined in terms of a basic set of variables (one of which is overloaded to serve multiple purposes, depending on the type of endmill).

Note that it will also be necessary to write out a tool description compatible with the program CutViewer as a G-code comment so that it may be used as a \textsc{3d} previewer for the G-code for tool changes in G-code. Several forms are available as described below.

%Programming the \textsc{3d} shape depends on sufficiently complex trigonometry, that arguably, it would be simpler to simply draw the outline and profile:
%
%\includeimage{carbidecreate_tool_outline_profile_example.png}
%
%\noindent saving the outline and profile as svg files using the tool number appending the file description in a folder such as:
%
%\begin{verbatim}
%C:\Users\willa\OneDrive\Documents\OpenSCAD\libraries\gcodepreview\tools
%\end{verbatim}

\subsubsection{Numbering for Tools}

Currently, the numbering scheme used is that of the various manufacturers of the tools, or descriptive short-hand numbers created for tools which lack such a designation (with a disclosure that the author is a Carbide \textsc{3d} employee).

Creating any numbering scheme is like most things in life, a trade-off, balancing length and expressiveness/compleatness against simplicity and usability. The software application Carbide Create (as released by an employer of the main author) has a limit of six digits, which seems a reasonable length from a complexity/simplicity standpoint, but also potentially reasonably expressible.

It will be desirable to track the following characteristics and measurements, apportioned over the digits as follows:

\begin{equation*}
\overbrace{\mathrm{endmill\ type}}^1
\overbrace{\mathrm{radius/angle}}^{2-3}
\overbrace{\mathrm{cutting\ diameter (and\ tip\ radius\ for\ tapered\ ball\ nose)}}^{4-5}
\overbrace{\mathrm{cutting\ flute\ length}}^6
\end{equation*}

\begin{outline}
\1 1st digit: endmill type:
\2 0 - manufacturer number 
\2 1 - square (incl. ``O''-flute)
\2 2 - ball
\2 3 - V
\2 4 - bowl
\2 5 - tapered ball
\2 6 - roundover
\2 7 - thread-cutting
\2 8 - dovetail
\2 9 - other (e.g., user-defined, or unsupported tools, keyhole, lollipop, \&c.)

\1 2nd and 3rd digits shape radius (ball/roundover) or angle (V), 2nd and 3rd digit together 10--99 indicate measurement in tenth of a millimeter. 2nd digit:
\2 0 - Imperial (00 indicates n/a or square) 
\2 any other value for both the 2nd and 3rd digits together indicate a metric measurement or an angle in degrees

\1 3rd digit (if 2nd is 0 indicating Imperial)
\2 1 - 1/32\textsuperscript{nd}
\2 2 - 1/16
\2 3 - 1/8
\2 4 - 1/4
\2 5 - 5/16
\2 6 - 3/8
\2 7 - 1/2
\2 8 - 3/4
\2 9 - >1$^{\prime\prime}$ or other

\1 4th and 5th digits cutting diameter as 2nd and 3rd above except 4th digit indicates tip radius for tapered ball nose and such tooling is only represented in Imperial measure:

\1 4th digit (tapered ball nose)
\2 1 - 0.01 in (this is the 0.254mm of the \#501 and 502)
\2 2 - 0.015625 in (1/64th)
\2 3 - 0.0295
\2 4 - 0.03125 in (1/32nd)
\2 5 - 0.0335
\2 6 - 0.0354
\2 7 - 0.0625 in (1/16th)
\2 8 - 0.125 in (1/8th)
\2 9 - 0.25 in (1/4)

\1 6th digit cutting flute length:
\2 0 - other
\2 1 - calculate based on V angle
\2 2 - 1/16
\2 3 - 1/8
\2 4 - 1/4
\2 5 - 5/16
\2 6 - 1/2
\2 7  - 3/4
\2 8 - ``long reach'' or greater than 3/4$^{\prime\prime}$
\2 9 - calculate based on radius

\1 or 6th digit tip diameter for roundover tooling (added to cutting diameter to arrive at actual cutting diameter --- note that these values are the same as for the tip radius of the \#501 and 502)
\2 1 - 0.01 in 
\2 2 - 0.015625 in (1/64th)
\2 3 - 0.0295
\2 4 - 0.03125 in (1/32nd)
\2 5 - 0.0335
\2 6 - 0.0354
\2 7 - 0.0625 in (1/16th)
\2 8 - 0.125 in (1/8th)
\2 9 - 0.25 in (1/4)

\end{outline}
%\end{figure}

Using this technique to create tool numbers for Carbide \textsc{3d} tooling we arrive at:

\begin{itemize}
\item Square
\subitem \#122 == 100012
\subitem \#112 == 100024
\subitem \#102 == 100036 (also \#274 and \#326 (Amana 46200-K))
\subitem \#201 == 100047 (also \#251 and \#322 (Amana 46202-K))
\subitem \#205 == 100048
\subitem \#251 == 100047 (also \#201 and \#322 (Amana 46202-K))
\subitem \#274 == 100036 (also \#102 and \#326 (Amana 46200-K))
\subitem \#278 == 100047
\subitem \#282 == 100204
\subitem \#322 == 100047 (also \#201 and \#251)
\subitem \#324 == 100048 (Amana 46170-K)
\subitem \#326 == 100036 (also \#102 and \#274)

\item Ball
\subitem \#121 == 201012
\subitem \#111 == 202024
\subitem \#101 == 203036
\subitem \#202 == 204047
\subitem \#325 == 204048 (Amana 46376-K)

\item V
\subitem \#301 == 390074
\subitem \#302 == 360071
\subitem \#327 == 360098 (Amana RC-1148)

\item Tapered Ball Nose
\subitem \#501 == 530131
\subitem \#502 == 540131
\end{itemize}

(note that some dimensions were rounded off/approximated)

Extending that to the non-Carbide \textsc{3d} tooling thus implemented:

\begin{itemize}
\item V
\subitem \#390

\item Dovetail
\subitem 814 == 814071
\subitem 45828 == 808071

\item Keyhole Tool
\subitem 374 == 906043
\subitem 375 == 906053
\subitem 376 == 907040
\subitem 378 == 907050

\item Roundover Tool
\subitem 56142 == 602032
\subitem 56125 == 603042
\subitem 1568 == 603032
\subitem 1570 
\subitem 1572 == 604042
\subitem 1574

%\item Tapered Ball Nose
%\subitem 204 == 2
%\subitem 304 == 2
%
\item Threadmill
\subitem 648

\item Bowl bit
\subitem 45981
\subitem 45982
\subitem 1370
\subitem 1372

\end{itemize}

Tools which do not have calculated numbers filled in are not supported by the system as currently defined in an unambiguous fashion (instead filling in the manufacturer's tool number padded with zeros is hard-coded). Notable limitations:

\begin{itemize}
\item No way to indicate flute geometry beyond O-flute (which distinction will probably be removed)
\item Lack of precision for metric tooling/limited support for Imperial sizes, notably, the dimensions used are scaled for smaller tooling and are not suited to typically larger scale tooling such as bowl bits
\item No way to indicate several fairly common shapes including keyhole, lollipop, and flat-bottomed V/chamfer tools (except of course for using 9\#\#\#\#\#)
\end{itemize}

A further consideration is that it is not possible to represent tools unambiguously, so that given a tool definition it is possible to derive the manufacturer's tool number, \emph{e.g.}, given a hypothetical command/instruction:

\begin{verbatim}
        self.currenttoolshape = self.toolshapes("square", 6.35, 19.05)
\end{verbatim}

\noindent it could be viewed as representing any of three different tools (Carbide \textsc{3d} \#201 (upcut), \#251 (downcut), and \#322 (Amana 46202-K downcut)), it is worth noting that \#205E is differentiated due to its longer flute length as-is \#324 (Amana 46170-K compression), though the fact of its compression cutting geometry is not recorded. Affording some sort of hinting to the user may be warranted, or a mechanism to allow specifying a given manufacturer tool \# as part of setting up a job.

A more likely scheme is that manufacturer tool numbers will continue to be used to identify tooling, the generated number will be used internally, then the saved manufacturer number will be exported to the G-code file, or used when generating a DXF filename for a given set of tool movements.

%The class \verb|toolshapes| as its first function, defines the correct toolnumber for the current tool based on the parameters which are used when the current invocation of the class is made. A separate macro will allow setting the current tool using this numbering system, as well as by using various manufacturer tool numbers --- it will probably be most expedient to write out the latter numbers into G-code files, which may result in this system only being used internally as a reference and cross-check mechanism.

%\subsubsection{A Class and 3D Shapes for Tools}
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    class toolshapes:
%    
%        def __init__(self, 
%                     endmilltype, 
%                     diameter, 
%                     flute,
%                     ra = 0,  #radius or angle
%                     tip = 0, #tip radius
%                     ):
%            self.endmilltype = endmilltype
%            self.diameter = diameter
%            self.flute = flute
%            self.radius = ra
%            self.angle = ra
%            self.tip = tip
%#            
%            self.digit_second = 0
%            self.digit_third = 0
%            self.digit_fourth = 0
%            self.digit_fifth = 0
%            self.digit_sixth = 0
%            if self.endmilltype == "O-flute":
%                self.digit_first = 0
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%                if self.diameter == 2.0:
%                    self.digit_fourth = 2
%                    self.digit_fifth = 0
%#                    
%                if self.flute == 1.5875:
%                    self.digit_sixth = 2
%                if self.flute == 3.175:
%                    self.digit_sixth = 3
%                if self.flute == 6.35:
%                    self.digit_sixth = 4
%                if self.flute == 7.9375:
%                    self.digit_sixth = 5
%                if self.flute == 8:
%                    self.digit_sixth = 5
%                if self.flute == 12.7:
%                    self.digit_sixth = 6
%                if self.flute == 19.05:
%                    self.digit_sixth = 7
%                if self.flute > 19.05:
%                    self.digit_sixth = 8
%
%            if self.endmilltype == "square":
%                self.digit_first = 1
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%#                    
%                if self.flute == 1.5875:
%                    self.digit_sixth = 2
%                if self.flute == 3.175:
%                    self.digit_sixth = 3
%                if self.flute == 6.35:
%                    self.digit_sixth = 4
%                if self.flute == 7.9375:
%                    self.digit_sixth = 5
%                if self.flute == 8:
%                    self.digit_sixth = 5
%                if self.flute == 12.7:
%                    self.digit_sixth = 6
%                if self.flute == 19.05:
%                    self.digit_sixth = 7
%                if self.flute > 19.05:
%                    self.digit_sixth = 8
%
%            if self.endmilltype == "ball":
%                self.digit_first = 2
%                if self.diameter == 0.79375:
%                    self.digit_third = 1
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_third = 2
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_third = 3
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_third = 4
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_third = 5
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_third = 5
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_third = 6
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_third = 7
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_third = 8
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_third = 9
%                    self.digit_fifth = 9
%#
%                if self.flute == 1.5875:
%                    self.digit_sixth = 2
%                if self.flute == 3.175:
%                    self.digit_sixth = 3
%                if self.flute == 6.35:
%                    self.digit_sixth = 4
%                if self.flute == 7.9375:
%                    self.digit_sixth = 5
%                if self.flute == 8:
%                    self.digit_sixth = 5
%                if self.flute == 12.7:
%                    self.digit_sixth = 6
%                if self.flute == 19.05:
%                    self.digit_sixth = 7
%                if self.flute > 19.05:
%                    self.digit_sixth = 8
%
%            if self.endmilltype == "V":
%                self.digit_first = 3
%                if self.angle == 30:
%                    self.digit_second = 3
%                    self.digit_third = 0
%                if self.angle == 45:
%                    self.digit_second = 4
%                    self.digit_third = 5
%                if self.angle == 60:
%                    self.digit_second = 6
%                    self.digit_third = 0
%                if self.angle == 90:
%                    self.digit_second = 9
%                    self.digit_third = 0
%#
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%#
%                self.digit_sixth = 1
%                if self.flute == 1.5875:
%                    self.digit_sixth = 2
%                if self.flute == 3.175:
%                    self.digit_sixth = 3
%                if self.flute == 6.35:
%                    self.digit_sixth = 4
%                if self.flute == 7.9375:
%                    self.digit_sixth = 5
%                if self.flute == 8:
%                    self.digit_sixth = 5
%                if self.flute == 12.7:
%                    self.digit_sixth = 6
%                if self.flute == 19.05:
%                    self.digit_sixth = 7
%                if self.flute > 19.05:
%                    self.digit_sixth = 8
%#
%            if self.endmilltype == "bowl":
%                self.digit_first = 4
%                #45981
%                if diameter == 12.7 and flute == 12.7 and ra == 3.175:
%                    self.digit_second = 4
%                    self.digit_third = 5
%                    self.digit_fourth = 9
%                    self.digit_fifth = 8
%                    self.digit_sixth = 1
%                #45982
%                if diameter == 19.5 and flute == 15.875 and ra == 6.35:
%                    self.digit_second = 4
%                    self.digit_third = 5
%                    self.digit_fourth = 9
%                    self.digit_fifth = 8
%                    self.digit_sixth = 2
%                #1370
%                if diameter == 11.1125 and flute == 8 and ra == 3.175:
%                    self.digit_second = 0
%                    self.digit_third = 1
%                    self.digit_fourth = 3
%                    self.digit_fifth = 7
%                    self.digit_sixth = 0
%                #1372/45981
%                if diameter == 19.5 and flute == 15.875 and ra == 6.35:
%                    self.digit_second = 0
%                    self.digit_third = 1
%                    self.digit_fourth = 3
%                    self.digit_fifth = 7
%                    self.digit_sixth = 2
%#
%            if self.endmilltype == "tapered ball":
%                self.tipradius = tip
%                self.digit_first = 5
%                if self.angle == 20:
%                    self.digit_second = 2
%                    self.digit_third = 0
%                if self.angle == 30:
%                    self.digit_second = 3
%                    self.digit_third = 0
%                if self.angle == 40:
%                    self.digit_second = 4
%                    self.digit_third = 0
%                if self.angle == 45:
%                    self.digit_second = 4
%                    self.digit_third = 5
%                if self.angle == 60:
%                    self.digit_second = 6
%                    self.digit_third = 0
%                if self.angle == 90:
%                    self.digit_second = 9
%                    self.digit_third = 0
%                    
%                if self.tipradius == 0.254:
%                    self.digit_fourth = 1
%                #2 - 0.015625 in (1/64th)
%                if self.tipradius == 0.396875:
%                    self.digit_fourth = 2
%                #3 - 0.0295
%                if self.tipradius == 0.7493:
%                    self.digit_fourth = 3
%                #4 - 0.03125 in (1/32nd)
%                if self.tipradius == 0.79375:
%                    self.digit_fourth = 4
%                #5 - 0.0335
%                if self.tipradius == 0.8509:
%                    self.digit_fourth = 5
%                #6 - 0.0354
%                if self.tipradius == 0.89916:
%                    self.digit_fourth = 6
%                #7 - 0.0625 in (1/16th)
%                if self.tipradius == 1.5875:
%                    self.digit_fourth = 7
%                #8 - 0.125 in (1/8th)
%                if self.tipradius == 3.175:
%                    self.digit_fourth = 8
%                #9 - 0.25 in (1/4)
%                if self.tipradius == 6.35:
%                    self.digit_fourth = 9
%
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%
%                self.digit_sixth = 1
%#
%            if self.endmilltype == "roundover":
%                self.tipradius = tip
%                self.digit_first = 6
%                if self.radius == 0.79375:
%                    self.digit_third = 1
%                if self.radius == 1.5875:
%                    self.digit_third = 2
%                if self.radius == 3.175:
%                    self.digit_third = 3
%                if self.radius == 6.35:
%                    self.digit_third = 4
%                if self.radius == 7.9375:
%                    self.digit_third = 5
%                if self.radius == 8:
%                    self.digit_third = 5
%                if self.radius == 9.525:
%                    self.digit_third = 6
%                if self.radius == 12.7:
%                    self.digit_third = 7
%                if self.radius == 19.05:
%                    self.digit_third = 8
%                if self.radius > 19.05:
%                    self.digit_third = 9
%
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%
%                if self.tipradius == 0.254:
%                    self.digit_sixth = 1
%                #2 - 0.015625 in (1/64th)
%                if self.tipradius == 0.396875:
%                    self.digit_sixth = 2
%                #3 - 0.0295
%                if self.tipradius == 0.7493:
%                    self.digit_sixth = 3
%                #4 - 0.03125 in (1/32nd)
%                if self.tipradius == 0.79375:
%                    self.digit_sixth = 4
%                #5 - 0.0335
%                if self.tipradius == 0.8509:
%                    self.digit_sixth = 5
%                #6 - 0.0354
%                if self.tipradius == 0.89916:
%                    self.digit_sixth = 6
%                #7 - 0.0625 in (1/16th)
%                if self.tipradius == 1.5875:
%                    self.digit_sixth = 7
%                #8 - 0.125 in (1/8th)
%                if self.tipradius == 3.175:
%                    self.digit_sixth = 8
%                #9 - 0.25 in (1/4)
%                if self.tipradius == 6.35:
%                    self.digit_sixth = 9
%#
%            if self.endmilltype == "thread-cutting":
%                self.digit_first = 7
%#
%            if self.endmilltype == "dovetail":
%                self.digit_first = 8
%                if self.angle == 8:
%                    self.digit_second = 0
%                    self.digit_third = 8
%                if self.angle == 14:
%                    self.digit_second = 1
%                    self.digit_third = 4
%                if self.diameter == 0.79375:
%                    self.digit_fifth = 1
%                if self.diameter == 1.5875:
%                    self.digit_fifth = 2
%                if self.diameter == 3.175:
%                    self.digit_fifth = 3
%                if self.diameter == 6.35:
%                    self.digit_fifth = 4
%                if self.diameter == 7.9375:
%                    self.digit_fifth = 5
%                if self.diameter == 8:
%                    self.digit_fifth = 5
%                if self.diameter == 9.525:
%                    self.digit_fifth = 6
%                if self.diameter == 12.7:
%                    self.digit_fifth = 7
%                if self.diameter == 19.05:
%                    self.digit_fifth = 8
%                if self.diameter > 19.05:
%                    self.digit_fifth = 9
%                self.digit_sixth = 1
%#
%            if self.endmilltype == "other":
%                self.digit_first = 9
%#
%            if self.endmilltype == "keyhole":
%                self.digit_first = 9
%                if self.diameter == 0.79375:
%                    self.digit_third = 1
%                if self.diameter == 1.5875:
%                    self.digit_third = 2
%                if self.diameter == 3.175:
%                    self.digit_third = 3
%                if self.diameter == 6.35:
%                    self.digit_third = 4
%                if self.diameter == 7.9375:
%                    self.digit_third = 5
%                if self.diameter == 8:
%                    self.digit_third = 5
%                if self.diameter == 9.525:
%                    self.digit_third = 6
%                if self.diameter == 12.7:
%                    self.digit_third = 7
%                if self.diameter == 19.05:
%                    self.digit_third = 8
%                if self.diameter > 19.05:
%                    self.digit_third = 9
%#
%                if self.radius == 0.79375:
%                    self.digit_fifth = 1
%                if self.radius == 1.5875:
%                    self.digit_fifth = 2
%                if self.radius == 3.175:
%                    self.digit_fifth = 3
%                if self.radius == 6.35:
%                    self.digit_fifth = 4
%                if self.radius == 7.9375:
%                    self.digit_fifth = 5
%                if self.radius == 8:
%                    self.digit_fifth = 5
%                if self.radius == 9.525:
%                    self.digit_fifth = 6
%                if self.radius == 12.7:
%                    self.digit_fifth = 7
%                if self.radius == 19.05:
%                    self.digit_fifth = 8
%                if self.radius > 19.05:
%                    self.digit_fifth = 9
%#
%                if self.flute == 1.5875:
%                    self.digit_sixth = 2
%                if self.flute == 3.175:
%                    self.digit_sixth = 3
%                if self.flute == 6.35:
%                    self.digit_sixth = 4
%                if self.flute == 7.9375:
%                    self.digit_sixth = 5
%                if self.flute == 8:
%                    self.digit_sixth = 5
%                if self.flute == 12.7:
%                    self.digit_sixth = 6
%                if self.flute == 19.05:
%                    self.digit_sixth = 7
%                if self.flute > 19.05:
%                    self.digit_sixth = 8
%
%            self.toolnumber = str(self.digit_first) + str(self.digit_second) + str(self.digit_third) + str(self.digit_fourth) + str(self.digit_fifth) + str(self.digit_sixth)
%
%\end{writecode}
%\addtocounter{gcpy}{557}

%Similarly Python functions and variables will be used in: \DescribeRoutine{currenttoolnumber} (note that it is important to use a different name for the module than for the the matching variable \DescribeVariable{currenttoolnum}), however, while \DescribeRoutine{settool} was used to set the current tool, this will instead be handled in the \verb|toolshapes| class which now manages the functionality needed for tools:

%#    def settool(self, tn):
%##        global currenttoolnum
%#        self.currenttoolnum = tn
%
%#        global currenttoolnum
%#        return self.currenttoolnum
%
%#    def currentroundovertoolnumber(self):
%#        global Roundover_tool_num
%#        return self.Roundover_tool_num
%
%
%\newglossaryentry{settool}
%{
%    name=settool, 
%    description={settool(102)}
%}
%
%The \gls{settool} command will normally be set using one of the variables as defined in the template, and the \verb|gcodepreview| object is currently hard-coded to use the tool numbers which Carbide \textsc{3d} uses for their tooling.

%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%        def toolshape_information(self):
%            print(f"Tool #: {self.toolnumber}")
%
%        def toolshape_toolnumber(self):
%            return(self.toolnumber)
%
%        def manufacturer_toolnumber(self):
%            if self.toolnumber == "100012":
%                return(122)
%            if self.toolnumber == "100024":
%                return(112)
%            if self.toolnumber == "100036":
%                return(102)#/326
%            if self.toolnumber == "100047":
%                return(201)#/251/322 (Amana 46202-K)
%            if self.toolnumber == "100048":
%                return(324)
%            if self.toolnumber == "100048":
%                return(205)
%            if self.toolnumber == "201012":
%                return(121)
%            if self.toolnumber == "202024":
%                return(111)
%            if self.toolnumber == "203036":
%                return(101)
%            if self.toolnumber == "204047":
%                return(202)
%            if self.toolnumber == "204048":
%                return(325)# (Amana 46376-K)
%            if self.toolnumber == "390074":
%                return(301)
%            if self.toolnumber == "360071":
%                return(302)
%            if self.toolnumber == "360098":
%                return(327)# (Amana RC-1148)
%            if self.toolnumber == "000204":
%                return(282)
%            if self.toolnumber == "000036":
%                return(274)
%            if self.toolnumber == "000047":
%                return(278)
%            if self.toolnumber == "530131":
%                return(501)
%            if self.toolnumber == "540131":
%                return(502)
%            if self.toolnumber == "814071":
%                return(814)
%            if self.toolnumber == "808071":
%                return(45828)
%            if self.toolnumber == "906043":
%                return(374)
%            if self.toolnumber == "906053":
%                return(375)
%            if self.toolnumber == "907040":
%                return(376)
%            if self.toolnumber == "907050":
%                return(378)
%            if self.toolnumber == "602032":
%                return(56142)
%            if self.toolnumber == "603042":
%                return(56125)
%            if self.toolnumber == "603032":
%                return(1568)
%            if self.toolnumber == "600002":
%                return(1570)
%            if self.toolnumber == "604042":
%                return(1572)
%            if self.toolnumber == "600062":
%                return(1574)
%#            if self.toolnumber == "445981":
%#                return(45981)
%            if self.toolnumber == "445982":
%                return(45982)
%            if self.toolnumber == "401370":
%                return(1370)
%            if self.toolnumber == "401372":
%                return(1372)#45981 (see above)
%

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def currenttoolnumber(self):
        return(self.currenttoolnum)

\end{writecode}
\addtocounter{gcpy}{3}

The \DescribeRoutine{toolchange} command will need to set several variables.

Mandatory variables include:

\begin{itemize}
\item endmilltype
\subitem O-flute
\subitem square
\subitem ball
\subitem V
\subitem keyhole
\subitem dovetail
\subitem roundover
\subitem tapered ball
%\subitm bowl
\item diameter
\item flute
\end{itemize}

\noindent and depending on the tool geometry, several additional variables will be necessary (usually derived from \verb|self.ra|):

\begin{itemize}
\item radius
\item angle
\end{itemize}

\noindent an optional setting of a \verb|toolnumber| may be useful in the future.

\paragraph{toolchange}

This command accepts a \DescribeVariable{tool number} and assigns its characteristics as parameters. It then applies the appropriate commands for a \label{subsubsec:toolchange} \DescribeRoutine{toolchange}. Note that it is expected that this code will be updated as needed when new tooling is introduced as additional modules which require specific tooling are added. 

Note that the comments written out in G-code correspond to those used by the G-code previewing tool CutViewer (which is unfortunately, no longer readily available). Similarly, the G-code previewing functionality in this library expects that such comments will be in place so as to model the stock.

A further concern is that early versions often passed the tool into a module using a parameter. That ceased to be necessary in the 2024.09.03 version of PythonSCAD, and all modules should read the tool \# from \verb|currenttoolnumber()|. %Note that this variable has changed names from the original \verb|currenttool| which is now used to store the current tool \emph{shape} (or \textsc{3d} model).

%It is possible that rather than hard-coding the tool definitions, a future update will instead read them in from an external file --- the \texttt{.csv} format used for tool libraries in Carbide Create seems a likely candidate and worth exploring.

Note that there are many varieties of tooling and not all will be directly supported, and that at need, additional tool shape support may be added under \verb|misc|.
 
The original implementation created the model for the tool at the current position, and a duplicate at the end position, wrapping the twain for each end of a given movement in a \verb|hull()| command and then applying a \verb|union|. This approach will not work within Python, so it will be necessary to instead assign and select the tool as part of the \verb|toolmovement| command.

There are two separate commands for handling a tool being changed, the first sets the parameters which describe the tool and may be used to effect the change of a tool either in a G-code file or when making a \textsc{3D} file, \DescribeVariable{settoolparameters} and a second version which processes a toolchange when presented with a tool number, \DescribeVariable{toolchange} (it may be that the latter will be set up to call the former).

\subparagraph{settoolparameters}

Not currently used, this command is intended for a state where tools are defined in a vendor-neutral fashion.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def settoolparameters(self, tooltype, first, second, third, fourth, length = 0):
        if tooltype == "mill":
            diameter = first
            cornerradius = second
            height = third
            taperangle = fourth
            if cornerradius == 0:
#M6T122 (TOOL/MILL,0.80, 0.00, 1.59, 0.00)
#M6T112 (TOOL/MILL,1.59, 0.00, 6.35, 0.00)
#M6T102 (TOOL/MILL,3.17, 0.00, 12.70, 0.00)
#M6T201 (TOOL/MILL,6.35, 0.00, 19.05, 0.00)
#M6T205 (TOOL/MILL,6.35, 0.00, 25.40, 0.00)
#M6T251 (TOOL/MILL,6.35, 0.00, 19.05, 0.00)
#M6T322 (TOOL/MILL,6.35, 0.00, 19.05, 0.00)
#M6T324 (TOOL/MILL,6.35, 0.00, 22.22, 0.00)
#M6T326 (TOOL/MILL,3.17, 0.00, 12.70, 0.00)
#M6T602 (TOOL/MILL,25.40, 0.00, 9.91, 0.00)
#M6T603 (TOOL/MILL,25.40, 0.00, 9.91, 0.00)
#M6T274 (TOOL/MILL,3.17, 0.00, 12.70, 0.00)
#M6T278 (TOOL/MILL,6.35, 0.00, 19.05, 0.00)
#M6T282 (TOOL/MILL,2.00, 0.00, 6.35, 0.00)
                self.endmilltype = "square"
                self.diameter = diameter
                self.flute = height
                self.shaftdiameter = diameter
                self.shaftheight = height
                self.shaftlength = height
#
            elif cornerradius > 0 and taperangle == 0:
#M6T121 (TOOL/MILL,0.80, 0.40, 1.59, 0.00)
#M6T111 (TOOL/MILL,1.59, 0.79, 6.35, 0.00)
#M6T101 (TOOL/MILL,3.17, 1.59, 12.70, 0.00)
#M6T202 (TOOL/MILL,6.35, 3.17, 19.05, 0.00)
#M6T325 (TOOL/MILL,6.35, 3.17, 25.40, 0.00)
                self.endmilltype = "ball"
                self.diameter = diameter
                self.flute = height
                self.shaftdiameter = diameter
                self.shaftheight = height
                self.shaftlength = height
#
            elif taperangle > 0:
#M6T301 (TOOL/MILL,0.10, 0.05, 6.35, 45.00)
#M6T302 (TOOL/MILL,0.10, 0.05, 6.35, 30.00)
#M6T327 (TOOL/MILL,0.10, 0.05, 23.39, 30.00)
                self.endmilltype = "V"
                self.diameter = Tan(taperangle / 2) * height
                self.flute = height
                self.angle = taperangle
                self.shaftdiameter = Tan(taperangle / 2) * height 
                self.shaftheight = height
                self.shaftlength = height
#
        elif tooltype == "chamfer":
            tipdiameter = first
            radius = second
            height = third
            taperangle = fourth

\end{writecode}
\addtocounter{gcpy}{59}

\subparagraph{toolchange}

The Python definition for \DescribeRoutine{toolchange} requires the tool number (used to write out the G-code comment description for CutViewer and also expects the speed for the current tool since this is passed into the G-code tool change command as part of the spindle on command. A simple \verb|if|--\verb|then| structure, the variables necessary for defining the toolshape are (re)defined each time the command is called so that they may be used by the command \DescribeRoutine{toolmovement} for actually modeling the shapes and the path and the resultant material removal.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def toolchange(self, tool_number, speed = 10000):
        self.currenttoolnum = tool_number

        if (self.generategcode == True):
            self.writegc("(Toolpath)")
            self.writegc("M05")

\end{writecode}
\addtocounter{gcpy}{7}

\subparagraph{Square (including O-flute)}

The simplest sort of tool, they are defined as a cylinder.

%TODO REVIEW variables for shaft length and so forth and correct as necessary
%TODO defineshaft COMMANDS NEED TO BE UPDATED to have 45 degree angle

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if (tool_number == 102) or (tool_number == 100036): #102/326 == 100036
            self.writegc("(TOOL/MILL, 3.175, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 3.175
            self.flute = 12.7
            self.shaftdiameter = 3.175
            self.shaftheight = 12.7
            self.shaftlength = 19.5
\end{writecode}
\addtocounter{gcpy}{8}

The outline definitions for linear/rotate extrude are the same for this tool as in the default tool definition in \verb|__init__|, but the commands \verb|definesquaretool| and \verb|defineshaft| are used:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = 10003
        elif (tool_number == 201) or (tool_number == 100047): #201/251/322 (Amana 46202-K) == 100047
            self.writegc("(TOOL/MILL, 6.35, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 6.35
            self.flute = 19.05
            self.shaftdiameter = 6.35
            self.shaftheight = 19.05
            self.shaftlength = 20.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100047"
        elif (tool_number == 112) or (tool_number == 100024): #112 == 100024
            self.writegc("(TOOL/MILL, 1.5875, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 1.5875
            self.flute = 6.35
            self.shaftdiameter = 3.175
            self.shaftheight = 6.35
            self.shaftlength = 12.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100024"
        elif (tool_number == 122) or (tool_number == 100012): #122 == 100012
            self.writegc("(TOOL/MILL, 0.79375, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 0.79375
            self.flute = 1.5875
            self.shaftdiameter = 3.175
            self.shaftheight = 1.5875
            self.shaftlength = 12.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100012"
        elif (tool_number == 324): #324 (Amana 46170-K) == 100048
            self.writegc("(TOOL/MILL, 6.35, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 6.35
            self.flute = 22.225
            self.shaftdiameter = 6.35
            self.shaftheight = 22.225
            self.shaftlength = 20.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100048"
        elif (tool_number == 205) or (tool_number == 100048): #205 == 100048
            self.writegc("(TOOL/MILL, 6.35, 0.00, 0.00, 0.00)")
            self.endmilltype = "square"
            self.diameter = 6.35
            self.flute = 25.4
            self.shaftdiameter = 6.35
            self.shaftheight = 25.4
            self.shaftlength = 20.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            defineKeyholetool(self.diameter, self.flute, self.shaftdiameter, self.shaftheight, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "100048"
#
\end{writecode}
\addtocounter{gcpy}{60}

The former distinction betwixt Square and O-flute tooling has been removed from the current version.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 282) or (tool_number == 100204): #282 == 000204
            self.writegc("(TOOL/MILL, 2.0, 0.00, 0.00, 0.00)")
            self.endmilltype = "O-flute"
            self.diameter = 2.0
            self.flute = 6.35
            self.shaftdiameter = 6.35
            self.shaftheight = 6.35
            self.shaftlength = 12.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100204"
        elif (tool_number == 274) or (tool_number == 100036): #274 == 000036
            self.writegc("(TOOL/MILL, 3.175, 0.00, 0.00, 0.00)")
            self.endmilltype = "O-flute"
            self.diameter = 3.175
            self.flute = 12.7
            self.shaftdiameter = 3.175
            self.shaftheight = 12.7
            self.shaftlength = 20.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100036"
        elif (tool_number == 278) or (tool_number == 100047): #278 == 000047
            self.writegc("(TOOL/MILL, 6.35, 0.00, 0.00, 0.00)")
            self.endmilltype = "O-flute"
            self.diameter = 6.35
            self.flute = 19.05
            self.shaftdiameter = 3.175
            self.shaftheight = 19.05
            self.shaftlength = 20.0
            self.definesquaretool(self.diameter, self.shaftheight, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "100047"
#
\end{writecode}
\addtocounter{gcpy}{34}

\subparagraph{Ball-nose (including tapered-ball)}

The \verb|elif|s continue with ball-nose and tapered-ball tooling which are defined as one would expect by spheres and cylinders. Note that the Cutviewer definition of a the measurement point of a tool being at the center is not yet set up --- potentially it opens up greatly simplified toolpath calculations and may be implemented in a future version.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 202) or (tool_number == 204047): #202 == 204047
            self.writegc("(TOOL/MILL, 6.35, 3.175, 0.00, 0.00)")
            self.endmilltype = "ball"
            self.diameter = 6.35
            self.flute = 19.05
            self.shaftdiameter = 6.35
            self.shaftheight = 19.05
            self.shaftlength = 20.0
            self.defineballnosetool(self.diameter, self.flute, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "204047"
        elif (tool_number == 101) or (tool_number == 203036): #101 == 203036
            self.writegc("(TOOL/MILL, 3.175, 1.5875, 0.00, 0.00)")
            self.endmilltype = "ball"
            self.diameter = 3.175
            self.flute = 12.7
            self.shaftdiameter = 3.175
            self.shaftheight = 12.7
            self.shaftlength = 20.0
            self.defineballnosetool(self.diameter, self.flute, self.shaftlength)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "203036"
        elif (tool_number == 111) or (tool_number == 202024): #111 == 202024
            self.writegc("(TOOL/MILL, 1.5875, 0.79375, 0.00, 0.00)")
            self.endmilltype = "ball"
            self.diameter = 1.5875
            self.flute = 6.35
            self.shaftdiameter = 3.175
            self.shaftheight = 6.35
            self.shaftlength = 20.0
            self.defineballnosetool(self.diameter, self.flute, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "202024"
        elif (tool_number == 121) or (tool_number == 201012): #121 == 201012
            self.writegc("(TOOL/MILL, 3.175, 0.79375, 0.00, 0.00)")
            self.endmilltype = "ball"
            self.diameter = 0.79375
            self.flute = 1.5875
            self.shaftdiameter = 3.175
            self.shaftheight = 1.5875
            self.shaftlength = 20.0
            self.defineballnosetool(self.diameter, self.flute, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "201012"
        elif (tool_number == 325) or (tool_number == 204048): #325 (Amana 46376-K) == 204048
            self.writegc("(TOOL/MILL, 6.35, 3.175, 0.00, 0.00)")
            self.endmilltype = "ball"
            self.diameter = 6.35
            self.flute = 25.4
            self.shaftdiameter = 6.35
            self.shaftheight = 25.4
            self.shaftlength = 20.0
            self.defineballnosetool(self.diameter, self.flute, self.shaftlength, (self.shaftdiameter - self.diameter)/2)
            self.defineshaft(self.diameter, self.shaftdiameter, self.flute, 0, self.shaftlength)
            self.toolnumber = "204048"
#
\end{writecode}
\addtocounter{gcpy}{56}

\subparagraph{V}

Note that one V tool is described as an Engraver in Carbide Create. While CutViewer has specialty Tool/chamfer and Tool/drill parameters, it is possible to describe a V tool as a Tool/mill (using a very small tip radius).

%It is possible to describe a flat-bottomed V tool using Tool/chamfer.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 301) or (tool_number == 390074): #301 == 390074
            self.writegc("(TOOL/MILL, 0.10, 0.05, 6.35, 45.00)")
            self.endmilltype = "V"
            self.diameter = 12.7
            self.flute = 6.35
            self.angle = 90
            self.shaftdiameter = 6.35
            self.shaftheight = 6.35
            self.shaftlength = 20.0
            self.defineVtool(self.diameter, self.flute, self.shaftlength, self.shaftdiameter)
            self.toolnumber = "390074"
        elif (tool_number == 302) or (tool_number == 360071): #302 == 360071
            self.writegc("(TOOL/MILL, 0.10, 0.05, 6.35, 30.00)")
            self.endmilltype = "V"
            self.diameter = 12.7
            self.flute = 11.067
            self.angle = 60
            self.shaftdiameter = 6.35
            self.shaftheight = 11.067
            self.shaftlength = 20.0
            self.defineVtool(self.diameter, self.flute, self.shaftlength, self.shaftdiameter)
            self.toolnumber = "360071"
        elif (tool_number == 390) or (tool_number == 390032): #390 == 390032
            self.writegc("(TOOL/MILL, 0.03, 0.00, 1.5875, 45.00)")
            self.endmilltype = "V"
            self.diameter = 3.175
            self.flute = 1.5875
            self.angle = 90
            self.shaftdiameter = 3.175
            self.shaftheight = 1.5875
            self.shaftlength = 20.0
            self.defineVtool(self.diameter, self.flute, self.shaftlength, self.shaftdiameter)
            self.toolnumber = "390032"
        elif (tool_number == 327) or (tool_number == 360098): #327 (Amana RC-1148) == 360098
            self.writegc("(TOOL/MILL, 0.03, 0.00, 13.4874, 30.00)")
            self.endmilltype = "V"
            self.diameter = 25.4
            self.flute = 22.134
            self.angle = 60
            self.shaftdiameter = 6.35
            self.shaftheight = 22.134
            self.shaftlength = 20.0
            self.defineVtool(self.diameter, self.flute, self.shaftlength, self.shaftdiameter)
            self.toolnumber = "360098"
        elif (tool_number == 323) or (tool_number == 330041): #323 == 330041 30 degree V Amana, 45771-K
            self.writegc("(TOOL/MILL, 0.10, 0.05, 11.18, 15.00)")
            self.endmilltype = "V"
            self.diameter = 6.35
            self.flute = 11.849
            self.angle = 30
            self.shaftdiameter = 6.35
            self.shaftheight = 11.849
            self.shaftlength = 20.0
            self.defineVtool(self.diameter, self.flute, self.shaftlength, self.shaftdiameter)
            self.toolnumber = "330041"
#
\end{writecode}
\addtocounter{gcpy}{56}

\subparagraph{Keyhole}

Keyhole tooling will primarily be used with a dedicated toolpath.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 374) or (tool_number == 906043): #374 == 906043
            self.writegc("(TOOL/MILL, 9.53, 0.00, 3.17, 0.00)")
            self.endmilltype = "keyhole"
            self.diameter = 9.525
            self.flute = 3.175
            self.radius = 6.35
            self.shaftdiameter = 6.35
            self.shaftheight = 3.175
            self.shaftlength = 20.0
            self.defineKeyholetool(self.diameter, self.flute, self.shaftdiameter, self.shaftheight, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "906043"
        elif (tool_number == 375) or (tool_number == 906053): #375 == 906053 
            self.writegc("(TOOL/MILL, 9.53, 0.00, 3.17, 0.00)")
            self.endmilltype = "keyhole"
            self.diameter = 9.525
            self.flute = 3.175
            self.radius = 8
            self.shaftdiameter = 6.35
            self.shaftheight = 3.175
            self.shaftlength = 20.0
            self.defineKeyholetool(self.diameter, self.flute, self.shaftdiameter, self.shaftheight, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "906053"
        elif (tool_number == 376) or (tool_number == 907040): #376 == 907040
            self.writegc("(TOOL/MILL, 12.7, 0.00, 4.77, 0.00)")
            self.endmilltype = "keyhole"
            self.diameter = 12.7
            self.flute = 4.7625
            self.radius = 6.35
            self.shaftdiameter = 6.35
            self.shaftheight = 4.7625
            self.shaftlength = 20.0
            self.defineKeyholetool(self.diameter, self.flute, self.shaftdiameter, self.shaftheight, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "907040"
        elif (tool_number == 378) or (tool_number == 907050): #378 == 907050
            self.writegc("(TOOL/MILL, 12.7, 0.00, 4.77, 0.00)")
            self.endmilltype = "keyhole"
            self.diameter = 12.7
            self.flute = 4.7625
            self.radius = 8
            self.shaftdiameter = 6.35
            self.shaftheight = 4.7625
            self.shaftlength = 20.0
            self.defineKeyholetool(self.diameter, self.flute, self.shaftdiameter, self.shaftheight, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "907050"
#
\end{writecode}
\addtocounter{gcpy}{45}

\subparagraph{Bowl}

This geometry is also useful for square endmills with a radius. 

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 45981): #45981 == 445981
#Amana Carbide Tipped Bowl & Tray 1/8 Radius x 1/2 Dia x 1/2 x 1/4 Inch Shank
            self.writegc("(TOOL/MILL,0.03, 0.00, 10.00, 30.00)")
            self.writegc("(TOOL/MILL, 15.875, 6.35, 19.05, 0.00)")
            self.endmilltype = "bowl"
            self.diameter = 12.7
            self.flute = 12.7
            self.radius = 3.175
            self.shaftdiameter = 6.35
            self.shaftheight = 12.7
            self.shaftlength = 20.0
            self.definebowltool(self.diameter, self.flute, self.radius, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "445981"
        elif (tool_number == 45982):#0.507/2, 4.509
            self.writegc("(TOOL/MILL, 15.875, 6.35, 19.05, 0.00)")
            self.endmilltype = "bowl"
            self.diameter = 19.05
            self.flute = 15.875
            self.radius = 6.35
            self.shaftdiameter = 6.35
            self.shaftheight = 15.875
            self.shaftlength = 20.0
            self.definebowltool(self.diameter, self.flute, self.radius, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "445982"
        elif (tool_number == 1370): #1370 == 401370
#Whiteside Bowl & Tray Bit 1/4"SH, 1/8"R, 7/16"CD (5/16" cutting flute length)
            self.writegc("(TOOL/MILL, 11.1125, 8, 3.175, 0.00)")
            self.endmilltype = "bowl"
            self.diameter = 11.1125
            self.flute = 8
            self.radius = 3.175
            self.shaftdiameter = 6.35
            self.shaftheight = 8
            self.shaftlength = 20.0
            self.definebowltool(self.diameter, self.flute, self.radius, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "401370"
        elif (tool_number == 1372): #1372/45982 == 401372
#Whiteside Bowl & Tray Bit 1/4"SH, 1/4"R, 3/4"CD (5/8" cutting flute length)
#Amana Carbide Tipped Bowl & Tray 1/4 Radius x 3/4 Dia x 5/8 x 1/4 Inch Shank
            self.writegc("(TOOL/MILL, 19.5, 15.875, 6.35, 0.00)")
            self.endmilltype = "bowl"
            self.diameter = 19.5
            self.flute = 15.875
            self.radius = 6.35
            self.shaftdiameter = 6.35
            self.shaftheight = 15.875
            self.shaftlength = 20.0
            self.definebowltool(self.diameter, self.flute, self.radius, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "401372"
#
\end{writecode}
\addtocounter{gcpy}{50}

\subparagraph{Tapered ball nose}

One vendor which provides such tooling is Precise Bits: \url{https://www.precisebits.com/products/carbidebits/taperedcarve250b2f.asp&filter=7}, but unfortunately, their tool numbering is ambiguous, the version of each major number (204 and 304) for their $1/4^{\prime\prime}$ shank tooling which is sufficiently popular to also be offered in a ZRN coating could be used. Similarly, the \#501 and \#502 PCB engravers from Carbide \textsc{3d} are supported.

Outlines and profiles for these tools are stored in \textsc{svg} files:

\begin{verbatim}
501_outline.svg
501_profile.svg
501_shaft_outline.svg
501_shaft_profile.svg
502_outline.svg
502_profile.svg
502_shaft_outline.svg
502_shaft_profile.svg
\end{verbatim}

\noindent which are then imported into the appropriate variables when a tool is loaded.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 501) or (tool_number == 530131): #501 == 530131
            self.writegc("(TOOL/MILL,0.03, 0.00, 10.00, 30.00)")
#            self.currenttoolshape = self.toolshapes("tapered ball", 3.175, 5.561, 30, 0.254)
            self.tooloutline = osimport("501_outline.svg")
            self.toolprofile = osimport("501_profile.svg")
            self.endmilltype = "tapered ball"
            self.diameter = 3.175
            self.flute = 5.561
            self.angle = 30
            self.tip = 0.254
            self.shaftdiameter = 3.175
            self.shaftheight = 5.561
            self.shaftlength = 10.0
            self.toolnumber = "530131"
        elif (tool_number == 502) or (tool_number == 540131): #502 == 540131
            self.writegc("(TOOL/MILL,0.03, 0.00, 10.00, 20.00)")
#            self.currenttoolshape = self.toolshapes("tapered ball", 3.175, 4.117, 40, 0.254)
            self.endmilltype = "tapered ball"
            self.diameter = 3.175
            self.flute = 4.117
            self.angle = 40
            self.tip = 0.254
            self.shaftdiameter = 3.175
            self.shaftheight = 4.117
            self.shaftlength = 10.0
            self.toolnumber = "540131"
#        elif (tool_number == 204):#
#            self.writegc("()")
#            self.currenttoolshape = self.tapered_ball(1.5875, 6.35, 38.1, 3.6)
#        elif (tool_number == 304):#
#            self.writegc("()")
#            self.currenttoolshape = self.tapered_ball(3.175, 6.35, 38.1, 2.4)
#
\end{writecode}
\addtocounter{gcpy}{33}

%TEMPLATE FOR TOOL OUTLINE DEFINITIONS
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def defineSHAPEtool(self, diameter, flute, shaft):
%
%        self.tooloutline = 
%#
%
%        self.toolprofile = 
%
%#
%        self.shaftprofile = 
%#
%
%        self.currenttoolshape = rotate_extrude(self.toolprofile)
%#
%        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 
%\end{writecode}
%\addtocounter{gcpy}{20}

\subparagraph{Roundover (cove tooling)}

Note that the parameters will need to incorporate the tip diameter into the overall diameter. 

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 56125) or (tool_number == 603042):#0.508/2, 1.531 56125 == 603042
            self.writegc("(TOOL/CRMILL, 0.508, 6.35, 3.175, 7.9375, 3.175)")
            self.endmilltype = "roundover"
            self.tipdiameter = 0.508
            self.diameter = 6.35 - self.tipdiameter
            self.flute = 8 - self.tipdiameter
            self.radius = 3.175 - self.tipdiameter/2
            self.shaftdiameter = 6.35
            self.shaftheight = 8
            self.shaftlength = 10.0
            self.defineRoundovertool(self.diameter, self.tipdiameter, self.flute, self.radius, self.shaftdiameter, self.shaftlength)
            self.toolnumber = "603042"
        elif (tool_number == 56142) or (tool_number == 602032):#0.508/2, 2.921 56142 == 602032
            self.writegc("(TOOL/CRMILL, 0.508, 3.571875, 1.5875, 5.55625, 1.5875)")
            self.endmilltype = "roundover"
            self.tip = 0.508
            self.diameter = 3.175 - self.tip
            self.flute = 4.7625 - self.tip
            self.radius = 1.5875 - self.tip/2
            self.shaftdiameter = 3.175
            self.shaftheight = 4.7625
            self.shaftlength = 10.0
            self.toolnumber = "602032"
#        elif (tool_number == 312):#1.524/2, 3.175
#            self.writegc("(TOOL/CRMILL, Diameter1, Diameter2, Radius, Height, Length)")
#        elif (tool_number == 1568):#0.507/2, 4.509 1568 == 603032
##FIX            self.writegc("(TOOL/CRMILL, 0.17018, 9.525, 4.7625, 12.7, 4.7625)")
##            self.currenttoolshape = self.toolshapes("roundover", 3.175, 6.35, 3.175, 0.396875)
#            self.endmilltype = "roundover"
#            self.diameter = 3.175
#            self.flute = 6.35
#            self.radius = 3.175
#            self.tip = 0.396875
#            self.toolnumber = "603032"
##https://www.amanatool.com/45982-carbide-tipped-bowl-tray-1-4-radius-x-3-4-dia-x-5-8-x-1-4-inch-shank.html 
#        elif (tool_number == 1570):#0.507/2, 4.509 1570 == 600002 ?!?
#            self.writegc("(TOOL/CRMILL, 0.17018, 9.525, 4.7625, 12.7, 4.7625)")
##            self.currenttoolshape = self.toolshapes("roundover", 4.7625, 9.525, 4.7625, 0.396875)
#            self.endmilltype = "roundover"
#            self.diameter = 4.7625
#            self.flute = 9.525
#            self.radius = 4.7625
#            self.tip = 0.396875
#            self.toolnumber = "600002"
#        elif (tool_number == 1572): #1572 = 604042
##FIX            self.writegc("(TOOL/CRMILL, 0.17018, 9.525, 4.7625, 12.7, 4.7625)")
##            self.currenttoolshape = self.toolshapes("roundover", 6.35, 12.7, 6.35, 0.396875)
#            self.endmilltype = "roundover"
#            self.diameter = 6.35
#            self.flute = 12.7
#            self.radius = 6.35
#            self.tip = 0.396875
#            self.toolnumber = "604042"
#        elif (tool_number == 1574): #1574 == 600062
##FIX            self.writegc("(TOOL/CRMILL, 0.17018, 9.525, 4.7625, 12.7, 4.7625)")
##            self.currenttoolshape = self.toolshapes("roundover", 9.525, 19.5, 9.515, 0.396875)
#            self.endmilltype = "roundover"
#            self.diameter = 9.525
#            self.flute = 19.5
#            self.radius = 9.515
#            self.tip = 0.396875
#            self.toolnumber = "600062"
#
\end{writecode}
\addtocounter{gcpy}{63}

\subparagraph{Dovetails}

Unfortunately, tools which support undercuts such as dovetails are not supported by many CAM tools including Carbide Create and CutViewer (CAMotics will work for such tooling, at least dovetails which may be defined as "stub" endmills with a bottom diameter greater than upper diameter).

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        elif (tool_number == 814) or (tool_number == 814071): #814 == 814071
#Item 18J1607, 1/2" 14° Dovetail Bit, 8mm shank
            self.writegc("(TOOL/MILL, 12.7, 6.367, 12.7, 0.00)")
        #    dt_bottomdiameter, dt_topdiameter, dt_height, dt_angle)
        #    https://www.leevalley.com/en-us/shop/tools/power-tool-accessories/router-bits/30172-dovetail-bits?item=18J1607
#            self.currenttoolshape = self.toolshapes("dovetail", 12.7, 12.7, 14)
            self.endmilltype = "dovetail"
            self.diameter = 12.7
            self.flute = 12.7
            self.angle = 14
            self.toolnumber = "814071"
        elif (tool_number == 808079) or (tool_number == 808071): #45828 == 808071
            self.writegc("(TOOL/MILL, 12.7, 6.816, 20.95, 0.00)")
        #    http://www.amanatool.com/45828-carbide-tipped-dovetail-8-deg-x-1-2-dia-x-825-x-1-4-inch-shank.html
#            self.currenttoolshape = self.toolshapes("dovetail", 12.7, 20.955, 8)
            self.endmilltype = "dovetail"
            self.diameter = 12.7
            self.flute = 20.955
            self.angle = 8
            self.toolnumber = "808071"
#
\end{writecode}
\addtocounter{gcpy}{21}

%\paragraph{flat-bottomed V (chamfer)}

%#        elif (tool_number == 13921):#
%            self.writegc("()")
%#            self.currenttoolshape = self.flat_V(6.35, 31.75, 12.7, 45)



Each tool must be modeled in \textsc{3d} using OpenSCAD commands, but it will also be necessary to have a consistent structure for managing the various shapes and aspects of shapes. 

While tool shapes were initially handled as geometric shapes stored in Python variables, processing them as such after the fashion of OpenSCAD required the use of \verb|union()| commands and assigning a small initial object (usually a primitive placed at the origin) so that the union could take place. This has the result of creating a nested union structure in the \textsc{csg} tree which can quickly become so deeply nested that it exceeds the limits set in PythonSCAD.

As was discussed in the PythonSCAD Google Group (\url{https://groups.google.com/g/pythonscad/c/rtiYa38W8tY}), if a list is used instead, then the contents of the list are added all at once at a single level when processed.

An example file which shows this concept:

\begin{verbatim}
from openscad import *
fn=200

box = cube([40,40,40])

features = []

features.append(cube([36,36,40]) + [2,2,2])
features.append(cylinder(d=20,h=5) + [20,20,-1])
features.append(cylinder(d=3,h=10) ^ [[5,35],[5,35], -1])

part = difference(box, features)

show(part)

\end{verbatim}

As per usual, the OpenSCAD command is simply a dispatcher:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module toolchange(tool_number, speed){
    gcp.toolchange(tool_number, speed);
}

\end{writecode}
\addtocounter{gcpscad}{4}

\noindent For example:

\begin{verbatim}
toolchange(small_square_tool_num, speed);
\end{verbatim}

\noindent (the assumption is that all speed rates in a file will be the same, so as to account for the most frequent use case of a trim router with speed controlled by a dial setting and feed rates/ratios being calculated to provide the correct chipload at that setting.)

\subparagraph{closing G-code}

With the tools delineated, the module is closed out and the toolchange information written into the G-code as well as the command to start the spindle at the specified speed.

One possible feature for the G-code for tool changes would be to have the various ratios available and then to apply the appropriate one. Directly applying them in the file generated by the user is sufficiently straight-forward that this expedient option seems a needless complexity unless a compelling reason comes up.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        self.writegc("M6T", str(tool_number))
#        if (self.endmilltype == "square"):
#            speed = speed * 
        self.writegc("M03S", str(speed))
\end{writecode}
\addtocounter{gcpy}{4}

\subsubsection{Laser support}

Two possible options for supporting a laser present themselves: color-coded \textsc{dxf}s or direct G-code support. An example file for the latter:

\url{https://lasergrbl.com/test-file-and-samples/depth-of-focus-test/}

\begin{verbatim}
M3 S0
S0 
G0X0Y16
S1000 
G1X100F1200
S0 
M5 S0
M3 S0
S0 
G0X0Y12
S1000 
G1X100F1000
S0 
M5 S0
M3 S0
S0 
G0X0Y8
S1000 
G1X100F800
S0 
M5 S0
M3 S0
S0 
G0X0Y4
S1000 
G1X100F600
S0 
M5 S0
M3 S0
S0 
G0X0Y0
S1000 
G1X100F400
S0 
M5 S0
\end{verbatim}

\subsection{Shapes and tool movement}

With all the scaffolding in place, it is possible to model the tool and \verb|hull()| between copies of the \textsc{3d} model of the tool, or a cross-section of it for both \DescribeRoutine{cut...} and \DescribeRoutine{rapid...} operations.

Alternately, describing tools in terms of outline will allow using \verb|linear/rotate_extrude| to be used which requires a description of the tools as profiles/outlines, but which matches the \verb|G0|/\verb|G1| and \verb|G2|/\verb|G3| G-code commands.

The majority of commands will be more general, focusing on tooling which is generally supported by this library, moving in lines and arcs so as to describe shapes which lend themselves to representation with those tools and which match up with both toolpaths and supported geometry in Carbide Create, and the usage requirements of the typical user.

This structure has the notable advantage that if a tool shape is represented as a list and always handled thus, then representing complex shapes which need to be represented in discrete elements/parts becomes a natural thing to do and the program architecture is simpler since all possible shapes may be handled by the same code/logic with no need to identify different shapes and handle them differently.

Note that it will be preferable to use \verb|extend| if the variable to be added contains a list rather than \verb|append| since the former will flatten out the list and add the individual elements, so that a list remains a list of elements rather than becoming a list of lists and elements, except that there will be at least two elements to each tool model list:

\begin{itemize}
\item cutting \emph{tool} shape (note that this may be either a single model, or a list of discrete slices of the tool shape)
\item \emph{shaft}
\end{itemize}

\noindent and when a cut is made by hulling each element from the cut begin position to its end position, this will be done using different colors so that the shaft rubbing may be identified on the \textsc{3d} surface of the preview of the cut.

\subsubsection{Tooling for Undercutting Toolpaths}

There are several notable candidates for under\-cutting tooling. \label{para:undercuttooling} 

\begin{itemize}
\item Keyhole tools --- intended to cut slots for retaining hardware used for picture
                        hanging, they may be used to create slots for other purposes
                        Note that it will be necessary to model these thrice, once for
                        the actual keyhole cutting, second for the fluted portion of
                        the shaft, and then the shaft should be modeled for collision
                        \url{https://assetssc.leevalley.com/en-gb/shop/tools/power-tool-accessories/router-bits/30113-keyhole-router-bits} 
\item Dovetail cutters --- used for the joinery of the same name, they cut a large
                           area at the bottom which slants up to a narrower region
                           at a defined angle
\item Lollipop cutters --- normally used for \textsc{3d} work, as their name suggests
                           they are essentially a (cutting) ball on a narrow stick
                           (the tool shaft), they are mentioned here only for
                           compleatness' sake and are not (at this time) implemented
\item Threadmill --- used for cutting threads, normally a single form geometry is
                     used on a CNC.
\end{itemize}

\subsubsection{Generalized commands and cuts}

The first consideration is a naming convention which will allow a generalized set of associated commands to be defined. The initial version will only create OpenSCAD commands for \textsc{3d} modeling and write out matching DXF files. At a later time this will be extended with G-code support.

There are three different movements in G-code which will need to be handled. Rapid commands will be used for \textsc{g0} movements and will not appear in \textsc{dxf}s but will appear in G-code files, while straight line cut (\textsc{g1}) and arc (\textsc{g2/g3}) commands may appear in both G-code and \textsc{dxf} files, depending on the specific command invoked. 

\subsubsection{Movement and color}

The first command which must be defined is \DescribeRoutine{toolmovement} which is used as the core of the other commands, affording a \textsc{3d} model of the tool moving in a straight line. A matching \DescribeRoutine{shaftmovement} command will allow modeling collision of the shaft with the stock should it occur. This differentiation raises the matter of color representation. Using a different color for the shape of the endmill when cutting and for rapid movements will similarly allow identifying instances of the tool crashing through stock at rapid speed.

%TODO add support for extrusion colour

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setcolor(self, 
                  cutcolor = "green",
                  rapidcolor = "orange",
                  shaftcolor = "red"):
        self.cutcolor = cutcolor
        self.rapidcolor = rapidcolor
        self.shaftcolor = shaftcolor

\end{writecode}
\addtocounter{gcpy}{8}

The possible colors are those of Web colors (\url{https://en.wikipedia.org/wiki/Web_colors}), while \textsc{dxf} has its own set of colors based on numbers (see table) and applying a Venn diagram and removing problematic extremes we arrive at the third column above as black and white are potentially inconsistent/confusing since at least one \textsc{cad} program toggles them based on light/dark mode being applied to its interface.

\begin{table}[h!]
\centering
\caption{Colors in OpenSCAD and \textsc{dxf}}
\label{tab:example}
\begin{tabular}{lll}
\toprule
\textbf{Web Colors (OpenSCAD)} & \textbf{\textsc{DXF}} & \textbf{Both} \\
\midrule
Black    & "Black" (0)                        \\
Red      & "Red" (1)           & Red          \\ 
Yellow   & "Yellow" (2)        & Yellow       \\  
Green    & "Green" (3)         & Green        \\
         & "Cyan" (4)                    \\
Blue     & "Blue" (5)          & Blue         \\
         & "Magenta" (6)                 \\
White    & "White" (7)                        \\
Gray     & "Dark Gray" (8)     & (Dark) Gray  \\
         & "Light Gray" (9)                   \\
%l_gray 
%\item brown
%\item l_blue
%\item l_green
%\item l_cyan
%\item l_red
%\item l_magenta
Silver \\
Maroon \\
Olive \\
Lime \\
Aqua \\
Teal \\
Navy \\
Fuchsia \\
Purple \\
\bottomrule
\end{tabular}
{\par\noindent\centering{(note that the names are not case-sensitive)}\par
\vspace*{\baselineskip}}
\end{table}

Most tools are easily implemented with concise \textsc{3d} descriptions which may be connected with a simple \texttt{hull} operation. Note that extending the normal case to a pair of such operations, one for the shaft, the other for the cutting shape will markedly simplify the code, and will make it possible to color-code the shaft which may afford indication of instances of it rubbing against the stock.

Note that the variables \verb|self.rapids| and \verb|self.toolpaths| are used to hold the list of accumulated \textsc{3d} models of the rapid motions and cuts as elements in lists so that they may be \verb|difference|d from the stock.

%In order to manage the various options when cutting it will be necessary to have a command where the actual cut is made, passing in the shape used for the cut as a parameter. Since the \textsc{3d} aspect of \verb|rapid| and \verb|cut| operations are fundamentally the same, the command \DescribeRoutine{rcs} which returns the \verb|hull| of the begin (the current machine position as accessed by the \verb|x/y/zpos()| commands and end positioning (provided as arguments \verb|ex|, \verb|ey|, and \verb|ez|) of the tool shape/cross-section will be defined for the common aspects:

\paragraph{toolmovement}

The \verb|toolmovement| command incorporates the color variables to indicate cutting and differentiate rapid movements and the tool shaft.

Diagramming this is quite straight-forward --- there is simply a movement made from the current position to the end. If we start at the origin, \verb|X0|, \verb|Y0|, \verb|Z0|, then it is simply a straight-line movement (rapid)/cut (possibly a partial cut in the instance of a keyhole or roundover tool), and no variables change value.

The code for diagramming this is quite straight-forward. A BlockSCAD implementation is available at: \url{https://www.blockscad3d.com/community/projects/1894400}, and the OpenSCAD version is only a little more complex (adding code to ensure positioning):

\includeimage{gcp_statemachine_0_0_0_50_25_-10.png}%

%TODO change self.step to steps to facilitate updating on fly based on size of tool

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def toolmovement(self, bx, by, bz, ex, ey, ez, step = 0):
        tslist = []
        if step > 0:
            steps = step
        else:
            steps = self.steps
#
\end{writecode}
\addtocounter{gcpy}{7}
 
\subparagraph{Square (including O-flute)}

The \DescribeRoutine{endmill square} is a simple cylinder:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "square":
            ts = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2), h=self.flute, center = False)
            tslist.append(hull(ts.translate([bx, by, bz]), ts.translate([ex, ey, ez])))
            return tslist
#
#        if self.endmilltype == "O-flute":
#            ts = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2), h=self.flute, center = False)
#            tslist.append(hull(ts.translate([bx, by, bz]), ts.translate([ex, ey, ez])))
#            return tslist
#
\end{writecode}
\addtocounter{gcpy}{10}

\subparagraph{Ball nose (including tapered ball nose)}

The \DescribeRoutine{ballnose} is modeled as a hemisphere joined with a cylinder:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "ball":
            b = sphere(r=(self.diameter / 2))
            s = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2), h=self.flute, center=False)
            bs = union(b, s)
            bs = bs.translate([0, 0, (self.diameter / 2)])
            tslist.append(hull(bs.translate([bx, by, bz]), bs.translate([ex, ey, ez])))
            return tslist
#
\end{writecode}
\addtocounter{gcpy}{8}

\subparagraph{bowl} 

The bowl tool is modeled as a series of cylinders stacked on top of each other and \verb|hull()|ed together:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "bowl":
            inner = cylinder(r1 = self.diameter/2 - self.radius, r2 = self.diameter/2 - self.radius, h = self.flute)
            outer = cylinder(r1 = self.diameter/2, r2 = self.diameter/2, h = self.flute - self.radius)
            outer = outer.translate([0,0, self.radius])
            slices = hull(outer, inner)
#    slices = cylinder(r1 = 0.0001, r2 = 0.0001, h = 0.0001, center=False)
            for i in range(1, 90 - self.steps, self.steps):
                slice = cylinder(r1 = self.diameter / 2 - self.radius + self.radius * Sin(i), r2 = self.diameter / 2 - self.radius + self.radius * Sin(i+self.steps), h = self.radius/90, center=False)
                slices = hull(slices, slice.translate([0, 0, self.radius - self.radius * Cos(i+self.steps)]))
            tslist.append(hull(slices.translate([bx, by, bz]), slices.translate([ex, ey, ez])))
            return tslist
#
\end{writecode}
\addtocounter{gcpy}{12}

\subparagraph{V}

The \DescribeRoutine{endmill v} is modeled as a cylinder with a zero width base and a second cylinder for the shaft (note that Python's \verb|math| defaults to radians, hence the need to convert from degrees if using it, but fortunately, trigonometric commands have been added to OpenPythonSCAD (\verb|Sin|, \verb|Cos|, \verb|Tan|, \verb|Atan|)):

% Below lines were updated since 2025-06-04 has trigonometric functions
%        es_v_angle = math.radians(es_v_angle)
%
%        v = cylinder(r1=0, r2=(es_diameter / 2), h=((es_diameter / 2) / math.tan((es_v_angle / 2))), center=False)

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "V":
            v = cylinder(r1=0, r2=(self.diameter / 2), h=((self.diameter / 2) / Tan((self.angle / 2))), center=False)
#                s = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2), h=self.flute, center=False)
#                sh = s.translate([0, 0, ((self.diameter / 2) / Tan((self.angle / 2)))])
            tslist.append(hull(v.translate([bx, by, bz]), v.translate([ex, ey, ez])))
            return tslist

\end{writecode}
\addtocounter{gcpy}{7}

\subparagraph{Keyhole}

Keyhole toolpaths (see: subsection~\ref{subsec:keyholetoolpaths} are intended for use with tooling which projects beyond the narrower shaft and so will cut usefully underneath the visible surface. Also described as ``undercut'' tooling, but see below.

\includeimage{keyhole_router_bits.pdf}%

%The \DescribeRoutine{keyhole} is modeled in two parts, first the cutting base:
%
%\noindent and a second call for an additional cylinder for the shaft will be necessary:
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def keyhole_shaft(self, es_diameter, es_flute_length):
%        return cylinder(r1=(es_diameter / 2), r2=(es_diameter / 2), h=es_flute_length, center=False)
%
%\end{writecode}
%\addtocounter{gcpy}{3}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "keyhole":
            kh = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2), h=self.flute, center=False)
            sh = (cylinder(r1=(self.radius / 2), r2=(self.radius / 2), h=self.flute*2, center=False))
            tslist.append(hull(kh.translate([bx, by, bz]), kh.translate([ex, ey, ez])))
            tslist.append(hull(sh.translate([bx, by, bz]), sh.translate([ex, ey, ez])))
            return tslist

\end{writecode}
\addtocounter{gcpy}{7}

%\paragraph{bowl}
%
%\begin{verbatim}
%//!OpenSCAD
%
%module bowl_tool(radius, diameter, height) {
%  union(){
%    // chain hull
%    for (i = [1 : abs(1) : 90 - 1]) {
%      hull() {
%      translate([0, 0, (radius - radius * cos(i))]){
%        cylinder(r1=((diameter / 2 - radius) + radius * sin(i)), r2=((diameter / 2 - radius) + radius * sin((i + 1))), h=(radius / 90), center=false);
%      }
%      translate([0, 0, (radius - radius * cos((i + 1)))]){
%        cylinder(r1=((diameter / 2 - radius) + radius * sin((i + 1))), r2=((diameter / 2 - radius) + radius * sin(((i + 1) + 1))), h=(radius / 90), center=false);
%      }
%      }  // end hull (in loop)
%     } // end loop
%
%    translate([0, 0, radius]){
%      cylinder(r1=(diameter / 2), r2=(diameter / 2), h=(height - radius), center=false);
%    }
%    cylinder(r1=(diameter / 2 - radius), r2=(diameter / 2 - radius), h=height, center=false);
%  }
%}
%
%bowl_tool(6.35, 19.05, 15.875);
%\end{verbatim}

\subparagraph{Tapered ball nose}

The tapered ball nose tool is modeled as a sphere at the tip and a pair of cylinders, where one (a cone) describes the taper, while the other represents the shaft.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "tapered ball":
            b = sphere(r=(self.tip / 2))
            s = cylinder(r1=(self.tip / 2), r2=(self.diameter / 2), h=self.flute, center=False)
            bshape = union(b, s)
            tslist.append(hull(bshape.translate([bx, by, bz]), bshape.translate([ex, ey, ez])))
            return tslist

\end{writecode}
\addtocounter{gcpy}{7}

%\paragraph{Thread mills}
%
%\label{subpara:threadmills}The implementation of arcs cutting along the Z-axis raises the 
%possibility of cutting threads using a \DescribeRoutine{threadmill}. 
%See: \url{https://community.carbide3d.com/t/thread-milling-in-metal-on-the-shapeoko-3/5332}.
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%        if self.endmilltype == "thread-cutting":
%            btm = cylinder(r1=(minor_diameter / 2), r2=(major_diameter / 2), h=cut_height, center = False)
%            top = cylinder(r1=(major_diameter / 2), r2=(minor_diameter / 2), h=cut_height, center = False)
%            top = top.translate([0, 0, cut_height/2])
%            tm = [btm, top]
%            tslist.extend(tm)
%
%\end{writecode}
%\addtocounter{gcpy}{12}

%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def threadmill(self, minor_diameter, major_diameter, cut_height):
%        btm = cylinder(r1=(minor_diameter / 2), r2=(major_diameter / 2), h=cut_height, center = False)
%        top = cylinder(r1=(major_diameter / 2), r2=(minor_diameter / 2), h=cut_height, center = False)
%        top = top.translate([0, 0, cut_height/2])
%        tm = btm.union(top)
%        return tm
%
%    def threadmill_shaft(self, diameter, cut_height, height):
%        shaft = cylinder(r1=(diameter / 2), r2=(diameter / 2), h=height, center = False)
%        shaft = shaft.translate([0, 0, cut_height/2])
%        return shaft
%
%\end{writecode}
%\addtocounter{gcpy}{12}


\subparagraph{Dovetails}

\label{subpara:dovetails}The \DescribeRoutine{dovetail} is modeled as a cylinder with the differing bottom and top diameters determining the angle (though \verb|dt_angle| is still required as a parameter)

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "dovetail":
            dt = cylinder(r1=(self.diameter / 2), r2=(self.diameter / 2) - self.flute * Tan(self.angle), h= self.flute, center=False)
            tslist.append(hull(dt.translate([bx, by, bz]), dt.translate([ex, ey, ez])))
            return tslist
        if self.endmilltype == "other":
            tslist = []
#    def dovetail(self, dt_bottomdiameter, dt_topdiameter, dt_height, dt_angle):
#        return cylinder(r1=(dt_bottomdiameter / 2), r2=(dt_topdiameter / 2), h= dt_height, center=False)

\end{writecode}
\addtocounter{gcpy}{9}


\paragraph{Concave toolshapes}
\label{para:concavetoolshapes} 
While normal tooling may be represented with a one (or more) \texttt{hull} operation(s) betwixt two \textsc{3d} toolshapes (or six in the instance of keyhole tools), concave tooling such as roundover/radius tooling require multiple sections or even slices of the tool shape to be modeled separately which are then \texttt{hull}ed together. Something of this can be seen in the manual work-around for previewing them: \url{https://community.carbide3d.com/t/using-unsupported-tooling-in-carbide-create-roundover-cove-radius-bits/43723}.

Because it is necessary to divide the tooling into vertical slices and call the hull operation for each slice the tool definitions have to be called separately in the \verb|cut...| modules, or integrated at the lowest level.

\subparagraph{Roundover tooling}

\label{para:roundover} It is not possible to represent all tools using tool changes as coded above which require using a \texttt{hull} operation between \textsc{3d} representations of the tools at the beginning and end points. Tooling which cannot be so represented will be implemented separately below, see paragraph~\ref{para:concavetoolshapes} --- \DescribeRoutine{roundover} tooling will need to generate a list of slices of the tool shape \verb|hull|ed together.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        if self.endmilltype == "roundover":
            shaft = cylinder(self.steps, self.tip/2, self.tip/2)
            toolpath = hull(shaft.translate([bx, by, bz]), shaft.translate([ex, ey, ez]))
            shaft = cylinder(self.flute, self.diameter/2 + self.tip/2, self.diameter/2 + self.tip/2)
            toolpath = toolpath.union(hull(shaft.translate([bx, by, bz + self.radius]), shaft.translate([ex, ey, ez + self.radius])))
            tslist = [toolpath]
            slice = cylinder(0.0001, 0.0001, 0.0001)
            slices = slice
            for i in range(1, 90 - self.steps, self.steps):
                dx = self.radius*Cos(i)
                dxx = self.radius*Cos(i + self.steps)
                dzz = self.radius*Sin(i)
                dz = self.radius*Sin(i + self.steps)
                dh = dz - dzz
                slice = cylinder(r1 = self.tip/2+self.radius-dx, r2 = self.tip/2+self.radius-dxx, h = dh)
                slices = slices.union(hull(slice.translate([bx, by, bz+dz]), slice.translate([ex, ey, ez+dz])))
                tslist.append(slices)
            return tslist

\end{writecode}
\addtocounter{gcpy}{19}

%\paragraph{flat V}
%
%The \DescribeRoutine{flat V} tool is modeled as a cylinder with two different diameters, forming a truncated cone.
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def flat_V(self, es_tip, es_diameter, es_flute_length, es_angle):
%        c = cylinder(r1=(es_tip / 2), r2=(es_diameter / 2), h=es_flute_length, center=False)
%        return c
%
%\end{writecode}
%\addtocounter{gcpy}{4}

\noindent Note that this routine does \emph{not} alter the machine position variables since it may be called multiple times for a given toolpath, \emph{e.g.,} for arcs. This command will then be called in the definitions for \verb|rapid| and \verb|cutline| which only differ in which variable the \textsc{3d} model list is \verb|union|ed with.

A similar routine will be used to handle the \DescribeRoutine{shaftmovement}.

\paragraph{shaftmovement} The \DescribeRoutine{shaftmovement} command uses variables defined as part of the tool definition to determine the Z-axis position of the cylinder used to represent the shaft and its diameter and height:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def shaftmovement(self, bx, by, bz, ex, ey, ez):
        tslist = []
        ts = cylinder(r1=(self.shaftdiameter / 2), r2=(self.shaftdiameter / 2), h=self.shaftlength, center = False)
        ts = ts.translate([0, 0, self.shaftheight])
        tslist.append(hull(ts.translate([bx, by, bz]), ts.translate([ex, ey, ez])))
        return tslist

\end{writecode}
\addtocounter{gcpy}{7}

\paragraph{tool outlines}

Defining the tools as outlines which may be scaled to different sizes and \verb|rotate_extrude|d requires a series of modules which must define:

\begin{itemize}
\item self.tooloutline --- the entire outline of the tool used for \verb|rotate_extrude| when cutting an arc (or a line if \verb|linear_extrude| is used)
\item self.toolprofile --- the profile of one half of the tool suited to creating a \textsc{3d} model using \verb|rotate_extrude|
\item self.shaftoutline
\item self.shaftprofile
\item self.currenttoolshape
\item self.currenttoolshaft
\end{itemize}

Note that when defining tooling it is expedient to use a mix of the \textsc{2d} and \textsc{3d} systems.

The various \verb|self.<toolparameters>| are defined in \verb|toolchange| and may be used at need.

An expedient option would seem to be slicing the \textsc{3d} model and hulling slices from the begin/end positions, but that may result in distortions for certain tool geometries (\emph{e.g.,} keyhole tooling).

There are several possible options for handling outlines and models --- a hybrid approach governed by \verb|if| branches will allow optimization of the resultant CSG commands. 

\begin{itemize}
\item simple shape and straight move --- \textsc{3d} models of the tool at the begin and end points of the move are \verb|hull|ed 
\item complex shape and straight move --- \textsc{3d} models of the tool at the begin and end points of the move are connected by a \verb|linear_extrude|
\item any shape and arc move --- \textsc{3d} models of the tool at the begin and end points of the move are connected by a \verb|rotate_extrude|
\end{itemize}

Similarly for the tool profiles and outlines and \textsc{3d} shapes:

\begin{itemize}
\item \verb|polygon| --- defining the shape in terms of point positions (note the PythonSCAD has an option for rounding which may be used for some shapes)
\item \textsc{2d} --- defining the shape using rectangles or polygons and circles and Boolean operations
\item \textsc{svg} --- drawing up the outlines and profiles in a vector drawing tool so that they may be imported as \textsc{svg} files allows any shape to be imported. Filenames would be mapped to the tool numbering scheme.
\end{itemize}

\subparagraph{defineshaft}

A separate command for defining the shaft is expedient, and allows handling the case of the cutting diameter and the shaft diameter being different, and by including both diameters as arguments, allows the transition, if not abrupt, to be modeled. The parameters:

\begin{itemize}
\item toolingdiameter
\item shaftdiameter
\item flute
\item transition
\item shaft
\end{itemize}

\noindent are obvious except for \verb|shaft| --- rather than the \textsc{o.a.l.}, this is the expected length of the tool as measured from the specified \verb|flute| and \verb|transition| lengths to the bottom of the collet. In the absence of a specified length, the flute length (assuming no transition) should be a workable approximation. 

%TODO Implement angle on shaft

Frequently, tools will have different diameters for cutting end and shaft --- when the former is smaller, the angle typically seems to be 60 degrees --- since this should \emph{not} be used for modeling, the expedient solution is to use an easily drawn angle which is obtuse enough to be obvious, so 45 degrees will be used.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def defineshaft(self, toolingdiameter, shaftdiameter, flute, transition, shaft):
        if shaftdiameter == 0:
            self.shaftoutline = polygon(points=[[0, flute], [diameter, flute], [diameter, shaft],[0, shaft]])
            self.shaftprofile = polygon(points=[[0, flute], [diameter/2 ,flute], [diameter/2, shaft], [0, shaft]])
            sh = cylinder(h = shaft, r = diameter/2)
            self.currenttoolshaft = sh.translate([0,0,flute])
        if shaftdiameter > 0:
            self.shaftoutline = polygon(points=[
                [shaftdiameter / 2 - toolingdiameter / 2, flute],
                [0, flute + transition],
                [0, flute + transition + shaft],
                [shaftdiameter, flute + transition + shaft],
                [shaftdiameter, flute + transition],
                [shaftdiameter / 2 + toolingdiameter / 2, flute],
                ] )
            self.shaftprofile = polygon( points= [
                [0, flute], 
                [0, flute + transition + shaft],
                [shaftdiameter/2, flute + transition + shaft],
                [shaftdiameter/2, flute + transition],
                [toolingdiameter/2, flute]
                ] )
            self.currenttoolshaft = rotate_extrude(self.shaftprofile)

\end{writecode}
\addtocounter{gcpy}{24}

\subparagraph{Square (including O-flute)}

The simplest sort of tooling, which is easily defined using a polygon and cylinder.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def definesquaretool(self, diameter, flute, shaft, offset = 0):
        self.tooloutline = polygon( points=[[0 + offset,0],[diameter + offset,0],[diameter + offset,flute],[0 + offset,flute]] )
        self.toolprofile = polygon( points=[[0,0],[diameter/2,0],[diameter/2,flute],[0,flute]] )
        self.currenttoolshape = cylinder(h = flute, r = diameter/2)
        sh = cylinder(h = flute, r = diameter/2)

\end{writecode}
\addtocounter{gcpy}{6}

\subparagraph{Ball-nose (including tapered-ball)}

Defined using \textsc{2d} and \textsc{3d} primitives which are unioned together, this allows the shape of the tool to be influenced by the variables \verb|fa/fs/fn|.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def defineballnosetool(self, diameter, flute, shaft, offset = 0):
        s = square([diameter,flute - diameter/2])
        sh = s.translate([0 + offset, diameter/2])
        c = circle(d=diameter)
        b = c.translate([diameter/2 + offset, diameter/2])
        self.tooloutline = union(sh, b)
#
        s = square([diameter/2,flute - diameter/2])
        sh = s.translate([0, diameter/2])
        c = circle(d=diameter)
        b = c.translate([0, diameter/2])
        bn = union(sh, b)
#        bns = bn.translate([0, diameter/2])
        thein = square([diameter/2,flute])
#        theins = thein.translate([diameter/2, 0])
        self.toolprofile = intersection(thein, bn)
#
        self.shaftprofile = polygon( points=[[0,flute],[diameter/2,flute],[diameter/2,shaft],[0,shaft]] )
#
#        b = self.toolprofile
#        bn = b.translate([-diameter/2, 0])
        self.currenttoolshape = rotate_extrude(self.toolprofile)
#
        self.currenttoolshaft = sh.translate([0,0,flute])

\end{writecode}
\addtocounter{gcpy}{25}

\subparagraph{V tool outline}

V shaped tooling often has the V cutting flutes attached to a cylindrical shaft.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def defineVtool(self, diameter, flute, shaft, shaftdiameter = 0):
        self.tooloutline = polygon([[diameter/2, 0], [diameter, flute], [0, flute]])
#

        self.toolprofile = polygon([[0, 0], [diameter/2, flute], [0, flute]])

#
        if shaftdiameter == 0:
            shaftdiameter = diameter
        self.shaftprofile = polygon([[0, flute], [shaftdiameter/2, flute], [shaftdiameter/2, flute + shaft], [0, flute + shaft]])

#
        self.currenttoolshape = rotate_extrude(self.toolprofile)
#
        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 

\end{writecode}
\addtocounter{gcpy}{16}

\subparagraph{Keyhole outline}

Keyhole outlines will require two cutting surfaces, since it is usual for the shaft to have cutting flutes for clearing the narrow region as part of their functionality.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def defineKeyholetool(self, diameter, flute, narrowdiameter, narrowflute, shaftdiameter, shaftlength):

        self.tooloutline = polygon([[0, 0], [diameter, 0], [diameter, flute], [diameter/2 + narrowdiameter/2, flute], [diameter/2 + narrowdiameter/2, flute + narrowflute], [diameter/2 - narrowdiameter/2, flute + narrowflute], [diameter/2 - narrowdiameter/2, flute], [0, flute]])
#

        self.toolprofile = polygon([[0, 0], [diameter/2, 0], [diameter/2, flute], [narrowdiameter/2, flute], [narrowdiameter/2, flute + narrowflute], [0, flute + narrowflute]])
#
        self.shaftprofile = polygon([[0, flute + narrowflute], [narrowdiameter/2, flute + narrowflute], [shaftdiameter/2, flute + narrowflute + shaftlength], [0, flute + narrowflute + shaftlength]])

#
        self.currenttoolshape = rotate_extrude(self.toolprofile)
#
        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 

\end{writecode}
\addtocounter{gcpy}{14}

\subparagraph{Bowl outline}

Bowl tooling is done using \verb|polygon()| with the third value added so as to cause the rounding of the radius.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def definebowltool(self, diameter, flute, radius, shaftdiameter, shaftlength):
#        self.tooloutline = 
#
        self.toolprofile = polygon([[0,0], [diameter/2, 0, radius], [diameter/2, radius], [diameter/2, flute], [0, flute]])
#
        self.shaftprofile = polygon([[0,flute], [shaftdiameter/2,flute], [shaftdiameter/2, flute + shaftlength], [0, flute + shaftlength]])
#
        self.currenttoolshape = rotate_extrude(self.toolprofile)
#
        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 

\end{writecode}
\addtocounter{gcpy}{11}

\subparagraph{Tapered ball nose}

Creating outlines for Tapered ball nose tooling will require that the arc and tangent for the angle and rounding be calculated out if programmed, or instead, they may be drawn.

%TEMPLATE FOR TOOL OUTLINE DEFINITIONS
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def defineSHAPEtool(self, diameter, flute, shaft):
%
%        self.tooloutline = 
%#
%
%        self.toolprofile = 
%
%#
%        self.shaftprofile = 
%#
%
%        self.currenttoolshape = rotate_extrude(self.toolprofile)
%#
%        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 
%\end{writecode}
%\addtocounter{gcpy}{20}

\subparagraph{Roundover (cove tooling)}

The \verb|polygon()| command does not afford an option for coves, so it will be necessary to over-draw the geometry, then remove the cove if programming, or, to simply draw the outline.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def defineRoundovertool(self, diameter, tipdiameter, flute, radius, shaftdiameter, shaftlength):
#            self.tip = 0.508
#            self.diameter = 6.35 - self.tip
#            self.flute = 8 - self.tip
#            self.radius = 3.175 - self.tip/2
#            self.shaftdiameter = 6.35
#            self.shaftheight = 8
#            self.shaftlength = 10.0
#        print(diameter)
#        print(tipdiameter)
#        print(flute)
#        print(radius)
#        print(shaftdiameter)
#        print(shaftlength)         
#        self.tooloutline = 
#
        self.toolprofile = polygon([[0,0], [tipdiameter/2, 0], [diameter/2, flute], [0, flute]])
#
        self.shaftprofile = polygon([[0,flute], [shaftdiameter/2,flute], [shaftdiameter/2, flute + shaftlength], [0, flute + shaftlength]])
#
        self.currenttoolshape = rotate_extrude(self.toolprofile)
#
        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 

\end{writecode}
\addtocounter{gcpy}{24}

%TEMPLATE FOR TOOL OUTLINE DEFINITIONS
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def defineSHAPEtool(self, diameter, flute, shaft):
%
%        self.tooloutline = 
%#
%
%        self.toolprofile = 
%
%#
%        self.shaftprofile = 
%#
%
%        self.currenttoolshape = rotate_extrude(self.toolprofile)
%#
%        self.currenttoolshaft = rotate_extrude(self.shaftprofile) 
%\end{writecode}
%\addtocounter{gcpy}{20}

\paragraph{rapid and cut (lines)}

A matching pair of commands is made for these, and \DescribeRoutine{rapid} is used as the basis for a series of commands which match typical usages of \verb|G0|.

Note the addition of a Laser mode which simulates the tool having been turned off before making a rapid movement --- likely further changes will be required.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def rapid(self, ex, ey, ez, laser = 0):
#        print(self.rapidcolor)
        if self.generateprint == True:
            laser = 1
        if laser == 0:
            tm = self.toolmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
            tm = color(tm, self.shaftcolor)
            ts = self.shaftmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
            ts = color(ts, self.rapidcolor)
            self.toolpaths.extend([tm, ts])
        self.setxpos(ex)
        self.setypos(ey)
        self.setzpos(ez)

    def cutline(self, ex, ey, ez):
#        print(self.cutcolor)
#        print(ex, ey, ez)
        tm = self.toolmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
        tm = color(tm, self.cutcolor)
        ts = self.shaftmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
        ts = color(ts, self.rapidcolor)
        self.setxpos(ex)
        self.setypos(ey)
        self.setzpos(ez)
        if self.generatecut == True:
            self.toolpaths.extend([tm, ts])

\end{writecode}
\addtocounter{gcpy}{27}

It is then possible to add specific \verb|rapid...| commands to match typical usages of G-code. The first command needs to be a move to/from the safe Z height. In G-code this would be:

\begin{verbatim}
(Move to safe Z to avoid workholding)
G53G0Z-5.000
\end{verbatim}

\noindent but in the \textsc{3d} model, since we do not know how tall the Z-axis is, we simply move to safe height and use that as a starting point:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def movetosafeZ(self):
        rapid = self.rapid(self.xpos(), self.ypos(), self.retractheight)
#        if self.generatepaths == True:
#            rapid = self.rapid(self.xpos(), self.ypos(), self.retractheight)
#            self.rapids = self.rapids.union(rapid)
#        else:
#  if (generategcode == true) {
#  //    writecomment("PREPOSITION FOR RAPID PLUNGE");Z25.650
#  //G1Z24.663F381.0, "F", str(plunge)
#        if self.generatepaths == False:
#            return rapid
#        else:
#            return cube([0.001, 0.001, 0.001])
        return rapid

    def rapidXYZ(self, ex, ey, ez):
        rapid = self.rapid(ex, ey, ez)
#        if self.generatepaths == False:
        return rapid

    def rapidXY(self, ex, ey):
        rapid = self.rapid(ex, ey, self.zpos())
#        if self.generatepaths == True:
#            self.rapids = self.rapids.union(rapid)
#        else:
#        if self.generatepaths == False:
        return rapid

    def rapidXZ(self, ex, ez):
        rapid = self.rapid(ex, self.ypos(), ez)
#        if self.generatepaths == False:
        return rapid

    def rapidYZ(self, ey, ez):
        rapid = self.rapid(self.xpos(), ey, ez)
#        if self.generatepaths == False:
        return rapid

    def rapidX(self, ex):
        rapid = self.rapid(ex, self.ypos(), self.zpos())
#        if self.generatepaths == False:
        return rapid

    def rapidY(self, ey):
        rapid = self.rapid(self.xpos(), ey, self.zpos())
#        if self.generatepaths == False:
        return rapid

    def rapidZ(self, ez):
        rapid = [self.rapid(self.xpos(), self.ypos(), ez)]
#        if self.generatepaths == True:
#            self.rapids = self.rapids.union(rapid)
#        else:
#        if self.generatepaths == False:
        return rapid

\end{writecode}
\addtocounter{gcpy}{56}

Note that rather than re-create the matching OpenSCAD commands as descriptors, due to the issue of redirection and return values and the possibility for errors it is more expedient to simply re-create the matching command (at least for the rapids):

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module movetosafeZ(){
    gcp.rapid(gcp.xpos(), gcp.ypos(), retractheight);
}

module rapid(ex, ey, ez) {
    gcp.rapid(ex, ey, ez);
}

module rapidXY(ex, ey) {
    gcp.rapid(ex, ey, gcp.zpos());
}

module rapidXZ(ex, ez) {
    gcp.rapid(ex, gcp.zpos(), ez);
}

module rapidZ(ez) {
    gcp.rapid(gcp.xpos(), gcp.ypos(), ez);
}

\end{writecode}
\addtocounter{gcpscad}{20}

Similarly, there is a series of \verb|cutline...| commands as predicted above.

The Python commands \DescribeRoutine{cut...} add the \verb|currenttool| to the \verb|toolpath| \verb|hull|ed together at the current position and the end position of the move. For \DescribeRoutine{cutline}, this is a straight-forward connection of the current (beginning) and ending coordinates:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def moveatfeedrate(self, ex, ey, ez, f):
        self.writegc("G01 X", str(ex), " Y", str(ey), " Z", str(ez), " F", str(f))
        self.feedrate = f
        return self.cutline(ex, ey, ez)

    def cutlinedxf(self, ex, ey, ez):
        self.dxfline(self.currenttoolnumber(), self.xpos(), self.ypos(), ex, ey)
        self.cutline(ex, ey, ez)

    def cutlinedxfgc(self, ex, ey, ez):
        self.dxfline(self.currenttoolnumber(), self.xpos(), self.ypos(), ex, ey)
        self.writegc("G01 X", str(ex), " Y", str(ey), " Z", str(ez))
        self.cutline(ex, ey, ez)

    def cutvertexdxf(self, ex, ey, ez):
        self.addvertex(self.currenttoolnumber(), ex, ey)
        self.writegc("G01 X", str(ex), " Y", str(ey), " Z", str(ez))
        self.cutline(ex, ey, ez)

    def cutlineXYZwithfeed(self, ex, ey, ez, feed):
        return self.cutline(ex, ey, ez)

    def cutlineXYZ(self, ex, ey, ez):
        return self.cutline(ex, ey, ez)

    def cutlineXYwithfeed(self, ex, ey, feed):
        return self.cutline(ex, ey, self.zpos())

    def cutlineXY(self, ex, ey):
        return self.cutline(ex, ey, self.zpos())

    def cutlineXZwithfeed(self, ex, ez, feed):
        return self.cutline(ex, self.ypos(), ez)

    def cutlineXZ(self, ex, ez):
        return self.cutline(ex, self.ypos(), ez)

    def cutlineXwithfeed(self, ex, feed):
        return self.cutline(ex, self.ypos(), self.zpos())

    def cutlineX(self, ex):
        return self.cutline(ex, self.ypos(), self.zpos())

    def cutlineYZ(self, ey, ez):
        return self.cutline(self.xpos(), ey, ez)

    def cutlineYwithfeed(self, ey, feed):
        return self.cutline(self.xpos(), ey, self.zpos())

    def cutlineY(self, ey):
        return self.cutline(self.xpos(), ey, self.zpos())

    def cutlineZgcfeed(self, ez, feed):
        self.writegc("G01 Z", str(ez), "F", str(feed))
        return self.cutline(self.xpos(), self.ypos(), ez)

    def cutlineZwithfeed(self, ez, feed):
        return self.cutline(self.xpos(), self.ypos(), ez)

    def cutlineZ(self, ez):
        return self.cutline(self.xpos(), self.ypos(), ez)

\end{writecode}
\addtocounter{gcpy}{62}

%CODE TO RESTORE
%
%\begin{verbatim}
%#        global toolpath
%#        global toolpaths
%#        print("cutline tool #", self.currenttoolnumber())
%        if (self.currenttoolnumber() == 56142):
%#                print("cutline tool internal #", self.currenttoolnumber())
%            toolpath = self.cutroundovertool(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez, 0.508/2, 1.531)
%        elif (self.currenttoolnumber() == 56125):
%            toolpath = self.cutroundovertool(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez, 0.508/2, 2.921)
%#        elif (self.currenttoolnumber() == 312):
%#            toolpath = self.cutroundovertool(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez, 1.524/2, 3.175)
%        elif (self.currenttoolnumber() == 1570):
%            toolpath = self.cutroundovertool(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez, 0.507/2, 4.509)
%        elif (self.currenttoolnumber() == 374):
%#            self.writegc("(TOOL/MILL, 9.53, 0.00, 3.17, 0.00)")
%            shaft = cylinder(9.525, 6.35/2, 6.35/2)
%            shaftend = shaft
%            shaftbegin = shaft.translate([self.xpos(), self.ypos(), self.zpos()])
%            shaftpath = hull(shaftbegin, shaftend.translate([ex, ey, ez]))
%            start = cylinder(3.175, 9.525/2, 9.525/2)
%            end = start
%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%            cutpath = hull(start, end.translate([ex, ey, ez]))
%            toolpath = union(shaftpath, cutpath)
%        elif (self.currenttoolnumber() == 375):
%#            self.writegc("(TOOL/MILL, 9.53, 0.00, 3.17, 0.00)")
%            shaft = cylinder(9.525, 8/2, 8/2)
%            shaftend = shaft
%            shaftbegin = shaft.translate([self.xpos(), self.ypos(), self.zpos()])
%            shaftpath = hull(shaftbegin, shaftend.translate([ex, ey, ez]))
%            start = cylinder(3.175, 9.525/2, 9.525/2)
%            end = start
%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%            cutpath = hull(start, end.translate([ex, ey, ez]))
%            toolpath = union(shaftpath, cutpath)
%        elif (self.currenttoolnumber() == 376):
%#            self.writegc("(TOOL/MILL, 12.7, 0.00, 4.77, 0.00)")
%            shaft = cylinder(9.525, 6.35/2, 6.35/2)
%            shaftend = shaft
%            shaftbegin = shaft.translate([self.xpos(), self.ypos(), self.zpos()])
%            shaftpath = hull(shaftbegin, shaftend.translate([ex, ey, ez]))
%            start = cylinder(3.175, 12.7/2, 12.7/2)
%            end = start
%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%            cutpath = hull(start, end.translate([ex, ey, ez]))
%            toolpath = union(shaftpath, cutpath)
%        elif (self.currenttoolnumber() == 378):
%#            self.writegc("(TOOL/MILL, 12.7, 0.00, 4.77, 0.00)")
%            shaft = cylinder(9.525, 8/2, 8/2)
%            shaftend = shaft
%            shaftbegin = shaft.translate([self.xpos(), self.ypos(), self.zpos()])
%            shaftpath = hull(shaftbegin, shaftend.translate([ex, ey, ez]))
%            start = cylinder(3.175, 12.7/2, 12.7/2)
%            end = start
%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%            cutpath = hull(start, end.translate([ex, ey, ez]))
%            toolpath = union(shaftpath, cutpath)
%        elif (self.currenttoolnumber() == 648):
%            shaft = self.threadmill_shaft(2.4, 0.75, 18)
%            shaftend = shaft
%            shaftbegin = shaft.translate([self.xpos(), self.ypos(), self.zpos()])
%            shaftpath = hull(shaftbegin, shaftend.translate([ex, ey, ez]))
%            start = self.threadmill(2.4, 4.8, 0.75)
%            end = start
%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%            cutpath = union(start, end.translate([ex, ey, ez]))
%            toolpath = union(shaftpath, cutpath)
%        else:
%%            start = self.currenttool()
%%            start = start.translate([self.xpos(), self.ypos(), self.zpos()])
%%            end = self.currenttool()
%%            toolpath = hull(start, end.translate([ex, ey, ez]))
%%        self.setxpos(ex)
%%        self.setypos(ey)
%%        self.setzpos(ez)
%%        if self.generatepaths == True:
%%            self.toolpaths = union([self.toolpaths, toolpath])
%%        else:
%%            return toolpath
%   
%    def cutlinedxfgcfeed(self, ex, ey, ez, feed):
%        self.dxfline(self.currenttoolnumber(), self.xpos(), self.ypos(), ex, ey)
%        self.writegc("G01 X", str(ex), " Y", str(ey), " Z", str(ez), " F", str(feed))
%#        if self.generatepaths == False:
%        return self.cutline(ex, ey, ez)
%
%
%\end{verbatim}

The matching OpenSCAD command is a descriptor:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module cutline(ex, ey, ez){
    gcp.cutline(ex, ey, ez);
}

module cutlinedxfgc(ex, ey, ez){
    gcp.cutlinedxfgc(ex, ey, ez);
}

module cutlineZgcfeed(ez, feed){
    gcp.cutlineZgcfeed(ez, feed);
}

\end{writecode}
\addtocounter{gcpscad}{12}      

\paragraph{Arcs}
 
A further consideration here is that G-code and \textsc{dxf} support arcs in addition to the lines already implemented. Implementing arcs wants at least the following options for quadrant and direction:
 
\begin{itemize}
\item cutarcCW --- cut a partial arc described in a clock-wise direction
\item cutarcCC --- counter-clock-wise
\item cutarcNWCW --- cut the upper-left quadrant of a circle moving clockwise
\item cutarcNWCC --- upper-left quadrant counter-clockwise
\item cutarcNECW
\item cutarcNECC
\item cutarcSECW
\item cutarcSECC
\item cutarcNECW
\item cutarcNECC
\item cutcircleCC --- while it won't matter for generating a \textsc{dxf}, when G-code is implemented direction of cut will be a consideration for that
\item cutcircleCW
\item cutcircleCCdxf
\item cutcircleCWdxf
\end{itemize}
 
It will be necessary to have two separate representations of arcs --- the G-code and \textsc{dxf} may be easily and directly supported with a single command, but representing the matching tool movement in OpenSCAD may be done in two different fashions. Originally, a series of short line movements which approximate the arc cutting in each direction and at changing Z-heights so as to allow for threading and similar operations was implemented, but instead representing the tool as an outline and using \verb|rotate_extrude| to model the movement of the tool's outline representation through the arc movement.

%Note that there are the following representations/interfaces for representing an arc:

%At this time, the current version of Carbide Create only imports circles in \textsc{dxf} as curves, any other example is converted into polylines --- unfortunately, the implementation of this is not such as would allow directly matching that representation. A work-around to import a \textsc{dxf} as curves is to convert the arc into a reasonable number of line segments so as to approximate the arc.
 
\begin{itemize}
\item G-code --- \textsc{g2} (clockwise) and \textsc{g3} (counter-clockwise) arcs may be specified, 
      and since the endpoint is the positional requirement, it is most likely best to use the offset 
      to the center (\textsc{i} and \textsc{j}), rather than the radius parameter (\textsc{k}) 
      \texttt{G2/3 ...} 
\item \textsc{dxf} --- \texttt{dxfarc(xcenter, ycenter, radius, anglebegin, endangle, tn)}
\item approximation of arc using lines (OpenSCAD) in both clock-wise and counter-clock-wise directions
% --- note that this may also be used 
%      in \textsc{dxf} so as to sidestep the question of how many line segments there would be
%      for a given arc representation 
\end{itemize}
 
Cutting the quadrant arcs greatly simplifies the calculation and interface for the modules. A full set of 8 will be necessary, then circles will have a pair of modules (one for each cut direction) made for them.
 
%At this time, despite what the module names imply (\texttt{cutarcNWCWdxf}, \&c.), only cutting and \textsc{dxf} generation is supported. Adding support for G-code will be done at a later time. Since these modules will ultimately support G-code, the interface will assume the stored \texttt{xpos} and \texttt{ypos} as the origin. 

Parameters which will need to be passed in are:
 
\begin{itemize}
% \item \texttt{tn}
 \item \texttt{ex} --- note that the matching origins (\verb|bx|, \verb|by|, \verb|bz|) as well as 
                       the (current) toolnumber are accessed using the appropriate commands for machine position
 \item \texttt{ey}
 \item \texttt{ez} --- allowing a different Z position will make possible threading and
                       similar helical toolpaths
\item \texttt{xcenter} --- the center position will be specified as an absolute
      position which will require calculating the offset when it is used for 
      G-code's \texttt{IJ}, for which \texttt{xctr/yctr} are suggested 
\item \texttt{ycenter}
\item \texttt{radius} --- while this could be calculated, passing it in as a parameter
      is both convenient and (potentially) could be used as a check on the other
      parameters
\item \texttt{tpzreldim} --- the relative depth (or increase in height) of the
      current cutting motion
\end{itemize}

There are two possibilities for arc movement:

\begin{itemize}
\item stepping through the arc and approximating with straight line movements
\item using \verb|rotate_extrude| to move an outline of the tool through the specified arc --- this has the added complexity of being limited to the range of the arc, requiring that the round profile of the tool be instantiated in \textsc{3d} at each end
\end{itemize}

Stepping through the arc manually is done by iterating through a loop: \DescribeRoutine{cutarcCW} (clockwise) or \DescribeRoutine{cutarcCC} (counterclockwise) to handle the drawing and processing of the \texttt{cutline()} toolpaths as short line segments which additionally affords a single point of control for adding additional features such as allowing the depth to  vary as one cuts along an arc (the line version is used rather than shape so as to capture the changing machine positions with each step through the loop). Note that the definition matches the \verb|DXF| definition of defining the center position with a matching radius, but it will be necessary to move the tool to the actual origin, and to calculate the end position when writing out a \verb|G2/G3| arc.

This brings to the fore the fact that at its heart, this program is simply graphing math in \textsc{3d} using tools (as presaged by the book series \emph{Make:Geometry/Trigonometry/Calculus}). This is clear in a depiction of the algorithm for the \verb|cutarcCC|/\verb|CW| commands, where the \verb|x| value is the \textsf{cos} of the \verb|radius| and the \verb|y| value the \textsf{sin}:

\includeimage{gcp_statemachine_arc_50_0_0_0_0_0.png}

The code for which makes this obvious:

\begin{verbatim}
/* [Machine Position] */
mpx = 0;
/* [Machine Position] */
mpy = 0;
/* [Machine Position] */
mpz = 0;

/* [Command Arguments] */
ex = 50;
/* [Command Arguments] */
ey = 25;
/* [Command Arguments] */
ez = -10;

/* [Tooling] */
currenttoolnum = 102;

machine_extents();

radius = 50;
$fa = 2;
$fs = 0.125;

plot_arc(radius, 0, 0, 0, radius, 0, 0, 0, radius, 0, 90, 5);

module plot_arc(bx, by, bz, ex, ey, ez, acx, acy, radius, barc, earc, inc){
for (i = [barc : inc : earc-inc]) {
  union(){
    hull()
    {
      translate([acx + cos(i)*radius, 
                 acy + sin(i)*radius, 
                 0]){
        sphere(r=0.5);
      }
      translate([acx + cos(i+inc)*radius, 
                 acy + sin(i+inc)*radius, 
                 0]){
        sphere(r=0.5);
      }
    }
      translate([acx + cos(i)*radius, 
                 acy + sin(i)*radius, 
                 0]){
      sphere(r=2);
    }
      translate([acx + cos(i+inc)*radius, 
                 acy + sin(i+inc)*radius, 
                 0]){
      sphere(r=2);
    }
  }
}
}

module machine_extents(){
translate([-200, -200, 20]){
  cube([0.001, 0.001, 0.001], center=true);
}
translate([200, 200, 20]){
  cube([0.001, 0.001, 0.001], center=true);
}
}

\end{verbatim}

%module plot_cut(bx, by, bz, ex, ey, ez) {
%  union(){
%    translate([bx, by, bz]){
%      sphere(r=5);
%    }
%    translate([ex, ey, ez]){
%      sphere(r=5);
%    }
%    hull(){
%      translate([bx, by, bz]){
%        sphere(r=1);
%      }
%      translate([ex, ey, ez]){
%        sphere(r=1);
%      }
%    }
%  }
%}

Note that it is necessary to move to the beginning cutting position before calling, and that it is necessary to pass in the relative change in Z position/depth. (Previous iterations calculated the increment of change outside the loop, but it is more workable to do so inside.)

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutarcCC(self, barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1):
        tpzinc = tpzreldim / (earc - barc)
        i = barc
        while i < earc: 
            self.cutline(xcenter + radius * Cos(i), ycenter + radius * Sin(i), self.zpos()+tpzinc)
            i += stepsizearc
#        self.setxpos(xcenter + radius * Cos(earc))
#        self.setypos(ycenter + radius * Sin(earc))

    def cutarcCW(self, barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1):
#        print(str(self.zpos()))
#        print(str(ez))
#        print(str(barc - earc))
#        tpzinc = ez - self.zpos() / (barc - earc)
#        print(str(tzinc))
#        global toolpath
#        print("Entering n toolpath")
        tpzinc = tpzreldim / (barc - earc)
#        cts = self.currenttoolshape
#        toolpath = cts
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
#        toolpath = []
        i = barc
        while i > earc: 
            self.cutline(xcenter + radius * Cos(i), ycenter + radius * Sin(i), self.zpos()+tpzinc)
#            self.setxpos(xcenter + radius * Cos(i))
#            self.setypos(ycenter + radius * Sin(i))
#            print(str(self.xpos()), str(self.ypos(), str(self.zpos())))
#            self.setzpos(self.zpos()+tpzinc)
            i += abs(stepsizearc) * -1
#        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, barc, earc)
#        if self.generatepaths == True:
#            print("Unioning n toolpath")
#            self.toolpaths = self.toolpaths.union(toolpath)
#        else:
        self.setxpos(xcenter + radius * Cos(earc))
        self.setypos(ycenter + radius * Sin(earc))
#        self.toolpaths.extend(toolpath)
#        if self.generatepaths == False:
#        return toolpath
#        else:
#            return cube([0.01, 0.01, 0.01])

\end{writecode}
\addtocounter{gcpy}{43}

Alternately, the command for using \verb|rotate_extrude| is quite straight-forward:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def extrudearcCC(self, barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1):
#        tm = self.toolmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
        tm = union(self.toolshape.translate(self.xpos(), self.ypos(), self.zpos()))
#                   self.toolshape.translate(),
#                   tooloutline.translate([r-3.175,0,0]).rotate_extrude(angle=ang2-ang1).rotz(ang1) + G3_center

        tm = color(tm, self.cutcolor)
        ts = self.shaftmovement(self.xpos(), self.ypos(), self.zpos(), ex, ey, ez)
        ts = color(ts, self.rapidcolor)
        self.setxpos(ex)
        self.setypos(ey)
        self.setzpos(ez)
        self.toolpaths.extend([tm, ts])

\end{writecode}
\addtocounter{gcpy}{14}

Note that it will be necessary to add versions which write out a matching DXF element:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutarcCWdxf(self, barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1):
        self.cutarcCW(barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1)
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, earc, barc)
#        if self.generatepaths == False:
#        return toolpath
#        else:
#            return cube([0.01, 0.01, 0.01])

    def cutarcCCdxf(self, barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1):
        self.cutarcCC(barc, earc, xcenter, ycenter, radius, tpzreldim, stepsizearc=1)
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, barc, earc)

\end{writecode}
\addtocounter{gcpy}{12}

Matching OpenSCAD modules are easily made:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module cutarcCC(barc, earc, xcenter, ycenter, radius, tpzreldim){
    gcp.cutarcCC(barc, earc, xcenter, ycenter, radius, tpzreldim);
}

module cutarcCW(barc, earc, xcenter, ycenter, radius, tpzreldim){
    gcp.cutarcCW(barc, earc, xcenter, ycenter, radius, tpzreldim);
}

\end{writecode}
\addtocounter{gcpscad}{8}

An alternate interface which matches how \textsc{g2/g3} arcs are programmed in G-code is a useful option:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutquarterCCNE(self, ex, ey, ez, radius):
        if self.zpos() == ez:
            tpzinc = 0
        else:
            tpzinc = (ez - self.zpos()) / 90
#        print("tpzinc ", tpzinc)
        i = 1
        while i < 91: 
            self.cutline(ex + radius * Cos(i), ey - radius + radius * Sin(i), self.zpos()+tpzinc)
            i += 1

    def cutquarterCCNW(self, ex, ey, ez, radius):
        if self.zpos() == ez:
            tpzinc = 0
        else:
            tpzinc = (ez - self.zpos()) / 90
#            tpzinc = (self.zpos() + ez) / 90
        self.debug("tpzinc ", tpzinc)
        i = 91
        while i < 181: 
            self.cutline(ex + radius + radius * Cos(i), ey + radius * Sin(i), self.zpos()+tpzinc)
            i += 1

    def cutquarterCCSW(self, ex, ey, ez, radius):
        if self.zpos() == ez:
            tpzinc = 0
        else:
            tpzinc = (ez - self.zpos()) / 90
#            tpzinc = (self.zpos() + ez) / 90
#        print("tpzinc ", tpzinc)
        i = 181
        while i < 271: 
            self.cutline(ex + radius * Cos(i), ey + radius + radius * Sin(i), self.zpos()+tpzinc)
            i += 1

    def cutquarterCCSE(self, ex, ey, ez, radius):
        if self.zpos() == ez:
            tpzinc = 0
        else:
            tpzinc = (ez - self.zpos()) / 90
#            tpzinc = (self.zpos() + ez) / 90
#        print("tpzinc ", tpzinc)
        i = 271
        while i < 361: 
            self.cutline(ex - radius + radius * Cos(i), ey + radius * Sin(i), self.zpos()+tpzinc)
            i += 1

    def cutquarterCCNEdxf(self, ex, ey, ez, radius):
        self.cutquarterCCNE(ex, ey, ez, radius)
        self.dxfarc(self.currenttoolnumber(), ex, ey - radius, radius,  0, 90)

    def cutquarterCCNWdxf(self, ex, ey, ez, radius):
        self.cutquarterCCNW(ex, ey, ez, radius)
        self.dxfarc(self.currenttoolnumber(), ex + radius, ey, radius, 90, 180)

    def cutquarterCCSWdxf(self, ex, ey, ez, radius):
        self.cutquarterCCSW(ex, ey, ez, radius)
        self.dxfarc(self.currenttoolnumber(), ex, ey + radius, radius, 180, 270)

    def cutquarterCCSEdxf(self, ex, ey, ez, radius):
        self.cutquarterCCSE(ex, ey, ez, radius)
        self.dxfarc(self.currenttoolnumber(), ex - radius, ey, radius, 270, 360)

\end{writecode}
\addtocounter{gcpy}{63}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module cutquarterCCNE(ex, ey, ez, radius){
     gcp.cutquarterCCNE(ex, ey, ez, radius);
}

module cutquarterCCNW(ex, ey, ez, radius){
     gcp.cutquarterCCNW(ex, ey, ez, radius);
}

module cutquarterCCSW(ex, ey, ez, radius){
    gcp.cutquarterCCSW(ex, ey, ez, radius);
}

module cutquarterCCSE(self, ex, ey, ez, radius){
    gcp.cutquarterCCSE(ex, ey, ez, radius);
}

module cutquarterCCNEdxf(ex, ey, ez, radius){
     gcp.cutquarterCCNEdxf(ex, ey, ez, radius);
}

module cutquarterCCNWdxf(ex, ey, ez, radius){
     gcp.cutquarterCCNWdxf(ex, ey, ez, radius);
}

module cutquarterCCSWdxf(ex, ey, ez, radius){
    gcp.cutquarterCCSWdxf(ex, ey, ez, radius);
}

module cutquarterCCSEdxf(self, ex, ey, ez, radius){
    gcp.cutquarterCCSEdxf(ex, ey, ez, radius);
}

\end{writecode}
\addtocounter{gcpscad}{32}

\subsubsection{tooldiameter}

It will also be necessary to be able to provide the diameter of the current tool. Arguably, this would be much easier using an object-oriented programming style/dot notation.

One aspect of tool parameters which will need to be supported is shapes which create different profiles based on how deeply the tool is cutting into the surface of the material at a given point. To accommodate this, it will be necessary to either track the thickness of uncut material at any given point, or, to specify the depth of cut as a parameter.

% which is what the initial version will implement.

The public-facing OpenSCAD code, \DescribeRoutine{tool diameter} simply calls the matching OpenSCAD module which wraps the Python code:
 
\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
function tool_diameter(td_tool, td_depth) = otool_diameter(td_tool, td_depth);

\end{writecode}
\addtocounter{gcpscad}{2}

\noindent the Python code, \DescribeRoutine{tool diameter} returns 
appropriate values based on the specified tool number and depth:
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def tool_diameter(self, ptd_tool, ptd_depth):
# Square 122, 112, 102, 201
        if ptd_tool == 122:
            return 0.79375
        if ptd_tool == 112:
            return 1.5875
        if ptd_tool == 102:
            return 3.175
        if ptd_tool == 201:
            return 6.35
# Ball 121, 111, 101, 202
        if ptd_tool == 122:
            if ptd_depth > 0.396875:
                return 0.79375
            else:
                return ptd_tool
        if ptd_tool == 112:
            if ptd_depth > 0.79375:
                return 1.5875
            else:
                return ptd_tool
        if ptd_tool == 101:
            if ptd_depth > 1.5875:
                return 3.175
            else:
                return ptd_tool
        if ptd_tool == 202:
            if ptd_depth > 3.175:
                return 6.35
            else:
                return ptd_tool
# V 301, 302, 390
        if ptd_tool == 301:
            return ptd_tool
        if ptd_tool == 302:
            return ptd_tool
        if ptd_tool == 390:
            return ptd_tool
# Keyhole
        if ptd_tool == 374:
            if ptd_depth < 3.175:
                return 9.525
            else:
                return 6.35
        if ptd_tool == 375:
            if ptd_depth < 3.175:
                return 9.525
            else:
                return 8
        if ptd_tool == 376:
            if ptd_depth < 4.7625:
                return 12.7
            else:
                return 6.35
        if ptd_tool == 378:
            if ptd_depth < 4.7625:
                return 12.7
            else:
                return 8
# Dovetail
        if ptd_tool == 814:
            if ptd_depth > 12.7:
                return 6.35
            else:
                return ptd_tool
        if ptd_tool == 808079:
            if ptd_depth > 20.95:
                return 6.816
            else:
                return ptd_tool
# Bowl Bit
#https://www.amanatool.com/45982-carbide-tipped-bowl-tray-1-4-radius-x-3-4-dia-x-5-8-x-1-4-inch-shank.html 
        if ptd_tool == 45982:
            if ptd_depth > 6.35:
                return 15.875
            else:
                return ptd_tool
# Tapered Ball Nose
        if ptd_tool == 204:
            if ptd_depth > 6.35:
                return ptd_tool
        if ptd_tool == 304:
            if ptd_depth > 6.35:
                return ptd_tool
            else:
                return ptd_tool

\end{writecode}
\addtocounter{gcpy}{87}

Since it is often necessary to utilise the radius of the tool, an additional command, \DescribeRoutine{tool radius} to return this value is worthwhile:
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def tool_radius(self, ptd_tool, ptd_depth):
        tr = self.tool_diameter(ptd_tool, ptd_depth)/2
        return tr

\end{writecode}
\addtocounter{gcpy}{4}
 
\noindent (Note that where values are not fully calculated values currently the passed in tool number (\verb|ptd tool|)is returned which will need to be replaced with code which calculates the appropriate values.)

\subsubsection{Feeds and Speeds}

There are several possibilities for handling feeds and speeds. Currently, base values for \DescribeVariable{feed}, \DescribeVariable{plunge}, and \DescribeVariable{speed} are used, which may then be adjusted using various \verb|<tooldescriptor>_ratio| values, as an acknowledgement of the likelihood of a trim router being used as a spindle, the assumption is that the \texttt{speed} will remain unchanged.

%One notable possibility for the future would be to load it from the .csv files used for User tool libraries in Carbide Create. Ideally, any use of such values in modules would be such that some other scheme could replace that usage with minimal editing and updating.

The tools which need to be calculated thus are those in addition to the \verb|large_square| tool:

\begin{itemize}
\item \verb|small_square_ratio|
\item \verb|small_ball_ratio|
\item \verb|large_ball_ratio|
\item \verb|small_V_ratio|
\item \verb|large_V_ratio|
\item \verb|KH_ratio|
\item \verb|DT_ratio|
\end{itemize}

\subsubsection{3D Printing}

Support for \textsc{3d} printing requires that there be G-code commands for non-mill/router aspects such as:

\begin{itemize}
\item fan(s) on/off
\item extruder(s)
\item Heater(s)
\item temperature(s)
\item accelerometers
\item load cells
\item Filament Sensor(s)
\item Filament Cutter(s)
\item Display Status
\subitem Message
\subitem Build Percentage
\subitem (Clear) Message
\item any additional commands such as ``Clean Nozzle''
\end{itemize}

\noindent Moreover, it will be necessary for all values to be adjusted for specific firmware, printer and filament type combinations. Probably the best beginning will be to create a simple file using a tested set of settings in a compatible slicer as a template and to adjust based on the values from such a file.

\paragraph{Sample 3D printing file}

\begin{verbatim}
M106 S0
M106 P2 S0
;TYPE:Custom
;;===== date: 20240520 =====================
;printer_model:Elegoo Centauri Carbon
;initial_filament:PLA
;curr_bed_type:Textured PEI Plate
M400 ; wait for buffer to clear
M220 S100 ;Set the feed speed to 100%
M221 S100 ;Set the flow rate to 100%
M104 S140
M140 S60
G90
G28 ;home
M729 ;Clean Nozzle
M190 S60


;=============turn on fans to prevent PLA jamming=================

    
    M106 P3 S255
    ;Prevent PLA from jamming


;enable_pressure_advance:false
;This value is called if pressure advance is enabled

M204 S5000 ;Call exterior wall print acceleration


G1 X128.5 Y-1.2 F20000
G1 Z0.3 F900
M73 P1 R0
M109 S210
M83
G92 E0 ;Reset Extruder
G1 F6000 
G1 X-1.2 E10.156 ;Draw the first line
G1 Y98.8 E7.934
M73 P7 R0
G1 X-0.5 Y100 E0.1
M73 P11 R0
G1 Y-0.3 E7.934
G1 X78.5 E6.284
M73 P15 R0
G1 F1680 
M73 P18 R0
G1 X98.5 E2
G1 F8400 
M73 P21 R0
G1 X118.5 E2
G1 F1680 
G1 X138.5 E2
G1 F8400 
M73 P24 R0
G1 X158.5 E2
G1 F8400 
M73 P25 R0
G1 X178.5 E2
;End PA test.


G3 I-1 J0 Z0.6 F1200.0 ;Move to side a little
M73 P27 R0
G1 F20000
G92 E0 ;Reset Extruder
;LAYER_COUNT:1
;LAYER:0
G90
G21
M83 ; use relative distances for extrusion
; filament start gcode
M106 P3 S200


;LAYER_CHANGE
;Z:0.2
;HEIGHT:0.2
;BEFORE_LAYER_CHANGE
;0.2
G92 E0

G1 E-.8 F1800
;LAYER:1

;_SET_FAN_SPEED_CHANGING_LAYER
SET_VELOCITY_LIMIT ACCEL=500
EXCLUDE_OBJECT_START NAME=Disc_id_0_copy_0
G1 X135.645 Y128.74 F30000
M73 P31 R0
G1 Z.6
G1 Z.2
G1 E.8 F1800
;TYPE:Outer wall
;WIDTH:0.499999
G1 F3000
G3 X128.198 Y121.357 I-7.146 J-.24 E1.19765
M73 P34 R0
G3 X130.232 Y121.573 I.058 J9.145 E.07407
G3 X135.591 Y127.663 I-1.733 J6.927 E.31169
M73 P35 R0
G1 X135.643 Y128.7 E.03754
G1 E-.728 F1800
;WIPE_START
G1 F30000
G1 X135.585 Y129.458 E-.0456
G1 X135.504 Y129.891 E-.0264
;WIPE_END
G1 X132.262 Y122.981 Z.6
M73 P36 R0
G1 X132.077 Y122.586 Z.6
G1 Z.2
M73 P37 R0
G1 E.8 F1800
;TYPE:Bottom surface
;WIDTH:0.505817
G1 F6300
G1 X133.335 Y123.844 E.06511
G3 X134.64 Y125.803 I-4.602 J4.479 E.08662
G1 X131.189 Y122.353 E.17854
M73 P38 R0
G1 X130.445 Y122.073 E.02909
G1 X130.192 Y122.01 E.00954
G1 X134.995 Y126.813 E.24849
M73 P39 R0
G3 X135.149 Y127.621 I-3.921 J1.166 E.03018
G1 X129.378 Y121.851 E.29858
M73 P40 R0
G2 X128.676 Y121.803 I-.554 J2.949 E.02582
G1 X135.204 Y128.331 E.33779
M73 P41 R0
G3 X135.19 Y128.972 I-3.173 J.251 E.02348
G1 X128.027 Y121.809 E.37065
M73 P42 R0
G2 X127.438 Y121.874 I.029 J2.945 E.02172
M73 P43 R0
G1 X135.124 Y129.56 E.39772
M73 P44 R0
G3 X135.017 Y130.108 I-2.76 J-.255 E.02045
G1 X126.89 Y121.981 E.42051
M73 P45 R0
G1 X126.387 Y122.133 E.01923
G1 X134.868 Y130.614 E.43887
M73 P46 R0
G3 X134.687 Y131.087 I-2.431 J-.66 E.01858
G1 X125.912 Y122.313 E.45404
M73 P47 R0
G2 X125.463 Y122.518 I.79 J2.324 E.01811
M73 P48 R0
G1 X134.481 Y131.536 E.46662
M73 P49 R0
G3 X134.252 Y131.962 I-2.22 J-.918 E.01772
G1 X125.038 Y122.748 E.47677
M73 P50 R0
G2 X124.646 Y123.01 I1.102 J2.07 E.01729
G1 X133.99 Y132.354 E.4835
M73 P52 R0
G3 X133.707 Y132.726 I-1.979 J-1.213 E.01712
G1 X124.273 Y123.292 E.48816
M73 P53 R0
G2 X123.918 Y123.592 I1.305 J1.903 E.01702
G1 X133.406 Y133.079 E.49092
M73 P54 R0
G1 X133.077 Y133.405 E.01694
G1 X123.595 Y123.923 E.49064
M73 P56 R0
G2 X123.291 Y124.274 I1.583 J1.677 E.01701
G1 X132.725 Y133.708 E.48813
M73 P57 R0
G3 X132.354 Y133.992 I-1.59 J-1.689 E.01711
G1 X123.006 Y124.643 E.48373
M73 P58 R0
G1 X122.75 Y125.042 E.01733
M73 P59 R0
G1 X131.959 Y134.251 E.47651
M73 P60 R0
G3 X131.534 Y134.481 I-1.349 J-1.984 E.0177
G1 X122.519 Y125.466 E.46649
M73 P61 R0
G2 X122.31 Y125.912 I2.1 J1.254 E.01805
G1 X131.087 Y134.688 E.45415
M73 P62 R0
G3 X130.615 Y134.871 I-1.138 J-2.244 E.01855
M73 P63 R0
G1 X122.127 Y126.383 E.43917
M73 P64 R0
G1 X121.985 Y126.896 E.01946
G1 X130.105 Y135.016 E.42016
M73 P65 R0
G3 X129.558 Y135.123 I-.806 J-2.651 E.02043
G1 X121.877 Y127.442 E.39747
M73 P66 R0
G2 X121.81 Y128.03 I2.87 J.626 E.02167
G1 X128.97 Y135.19 E.37051
M73 P68 R0
G3 X128.33 Y135.204 I-.391 J-3.158 E.02348
G1 X121.795 Y128.67 E.33813
M73 P69 R0
G2 X121.851 Y129.38 I3.542 J.078 E.02613
G1 X127.619 Y135.149 E.29847
M73 P70 R0
G3 X126.809 Y134.992 I.366 J-4.085 E.03026
G1 X122.009 Y130.193 E.24836
M73 P71 R0
G1 X122.057 Y130.392 E.00749
G1 X122.28 Y131.031 E.02476
G1 X122.356 Y131.195 E.00663
G1 X125.802 Y134.641 E.17832
M73 P72 R0
G3 X123.807 Y133.3 I2.526 J-5.915 E.0885
G1 X122.586 Y132.079 E.06316
M73 P73 R0
G1 E-.728 F1800
;WIPE_START
G1 F30000
G1 X123.435 Y132.928 E-.072
;WIPE_END
EXCLUDE_OBJECT_END NAME=Disc_id_0_copy_0
M106 S0
M106 P2 S0
;TYPE:Custom
; filament end gcode 
;===== date: 20250109 =====================
M400 ; wait for buffer to clear
M140 S0 ;Turn-off bed
M106 S255 ;Cooling nozzle
M83
G92 E0 ; zero the extruder
G2 I1 J0 Z0.7 E-1 F3000 ; lower z a little
M73 P74 R0
G90
G1 Z100 F20000 ; Move print head up 
M73 P94 R0
M204 S5000
M400
M83
G1 X202 F20000
M73 P95 R0
M400
G1 Y250 F20000
M73 P97 R0
G1 Y264.5 F1200
M73 P100 R0
M400
G92 E0
M104 S0 ;Turn-off hotend
M140 S0 ;Turn-off bed
M106 S0 ; turn off fan
M106 P2 S0 ; turn off remote part cooling fan
M106 P3 S0 ; turn off chamber cooling fan
M84 ;Disable all steppers

\end{verbatim}

The various commands for machine functionality are quite straight-forward, with each added as a descriptive module.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setfansoff(self):
        self.writegc("M106 S0")

    def setfanspeed(self, fan, speed):
        self.writegc("M106 P", fan, " S", speed)

    def pauseforclearbuffer(self):
        self.writegc("M400 ; wait for buffer to clear")

\end{writecode}
\addtocounter{gcpy}{9}

\paragraph{Feed and Speed ratio}

Note that certain commands will require setting values which will need to be tracked and used for calculations.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setfeedratio(self, feedratio):
        self.writegc("M220 S", feedratio)
        self.feedratio = feedratio

    def setspeedratio(self, speedratio):
        self.writegc("M221 S", speedratio)
        self.speedratio = speedratio

\end{writecode}
\addtocounter{gcpy}{8}

\paragraph{Time and Firmware for 3D printers}

The various G-code commands are specific to firmware implementations such as \url{https://www.klipper3d.org/G-Codes.html}

Where \textsc{cnc} operations normally only are concerned about time in the moment, and pausing until a given time has elapsed, \textsc{3d} operations, with their control of heating up filament, melting it, and extruding thin ribbons of it require a greater control over time and duration.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
#Set extruder temperature: M104 [T<index>] [S<temperature>]
    def setextrudertemperature(self, temperature):
        self.writegc("M104 S" + str(temperature))
        self.extrudertemperature = temperature

#Set extruder temperature and wait: M109 [T<index>] S<temperature>
#Note: M109 always waits for temperature to settle at requested value
    def setandwaitforextrudertemperature(self, temperature):
        self.writegc("M109 S" + str(temperature) + "; set temperature and wait for it to be reached")
        self.extrudertemperature = temperature

#Set bed temperature: M140 [S<temperature>]
    def setbedtemperature(self, temperature):
        self.writegc("M140 S" + str(temperature))
        self.bedtemperature = temperature

#Set bed temperature and wait: M190 S<temperature>
#Note: M190 always waits for temperature to settle at requested value
    def setandwaitforbedtemperature(self, temperature):
        self.writegc("M190 S" + str(temperature))
        self.bedtemperature = temperature

\end{writecode}
\addtocounter{gcpy}{26}

Certain commands are only needed for initialization, so may be grouped together in a single command:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def initializeforprinting(self, nozzlediameter = 0.4, filamentdiameter = 1.75, extrusionwidth = 0.6, layerheight = 0.2):
        self.writegc("G21  ; set units to millimeters")
        self.writegc("G90")
        self.writegc("M82  ; use absolute distances for extrusion")
        self.writegc("G28  ; home")
        self.writegc("M729 ; Clean Nozzle")
        self.nozzlediameter = nozzlediameter
        self.extrusionwidth = extrusionwidth
        self.layerheight = layerheight
        self.toolpaths = []
        self.feedrate = 0
        fr = filamentdiameter/2
        self.extrusion_normal_length = 1 / 3.14159 * (fr * fr)

\end{writecode}
\addtocounter{gcpy}{12}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def liftandprimenozzle(self, liftfeed = 5000, extrusionfeed = 2400): 
        self.writegc("G1 Z5 F" + str(liftfeed) + " ; lift nozzle")
        self.writegc("G92 E0")
        self.writegc("G1 E-2 F" + str(extrusionfeed))
        self.writegc("G92 E0")

#Set acceleration: M204 S<value> OR M204 P<value> T<value>
#Note: If S is not specified and both P and T are specified, then the acceleration is set to the minimum of P and T. If only one of P or T is specified, the command has no effect.
    def setacceleration(self, acceleration):
        self.writegc("M204 S", acceleration)
        self.acceleration = acceleration

#Use absolute/relative distances for extrusion: M82, M83
    def setextrusionabsolute(self, acceleration):
        self.writegc("M83")
        self.extrusionabsolute = true

\end{writecode}
\addtocounter{gcpy}{11}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
#Set build percentage: M73 P<percent>
    def setbuildpercentage(self, percent):
        self.writegc("M73 P", percent)
        self.percent = percent

\end{writecode}
\addtocounter{gcpy}{5}

The program \url{https://github.com/FullControlXYZ/fullcontrol/blob/master/models/hex_adapter.ipynb} suggests certain variables:

\begin{verbatim}
# printer/gcode parameters

design_name = 'hex_adapter'
nozzle_temp = 210
bed_temp = 40
print_speed = 1000
fan_percent = 100
printer_name='prusa_i3' # generic / ultimaker2plus / prusa_i3 / ender_3 / cr_10 / bambulab_x1 / toolchanger_T0
\end{verbatim}

Movement commands add an \verb|E| position aspect to the command which results in the Extruder advancing to that position so as to extrude a sufficient volume of filament to match the movement and the space which is intended to be filled. Modeling these in \textsc{3d} without the complexity of managing the entire \textsc{3d} model and tracking the elevation of the current position relative to the model at a given point in time will require that the user maintain the current layer thickness and ensure that if unsupported, the extruded plastic will be extruded with a fan speed and flow rate which will allow bridging from/to supported areas of the model.

Calculating the volume necessary/the amount extruded will require the nozzle size, the layer height, an estimate for how much the extruded filament will spread out/deform, and the diameter of the filament. Further potential complications include whether the first layer is being extruded (normally this is done at a quite slow speed to facilitate adhesion, which also serves as a chance to catch a problem at an early stage), or if a strand is an inside or outside wall or infill or bridging open space, if it is crossing an already extruded segment(?) and so forth.

\begin{verbatim}
; --- Start of G-code: Demonstration of Layer and Extrusion Concepts ---
G21 ; Set units to millimeters
G90 ; Use absolute positioning
M82 ; Set extruder to absolute mode
M104 S200 ; Set extruder temperature to 200°C
M140 S60 ; Set bed temperature to 60°C
M190 S60 ; Wait for bed to reach target temp
M109 S200 ; Wait for extruder to reach target temp
G28 ; Home all axes

; --- Initial test extrusion ---
G92 E0 ; Reset extruder position
G1 F100 E5 ; Extrude 5 mm of filament at low speed to prime the nozzle
; Purpose: Ensures clean flow and purges any residual filament

; --- First layer adhesion test ---
G1 Z0.2 ; Move nozzle to first layer height
G1 X10 Y10 F3000 ; Move to starting position
G1 F1800 ; Set slower speed for first layer
G1 E0.8 ; Slight retraction before starting
G1 X100 E10 ; Draw a line along X to test bed adhesion
; Comment: This line helps verify that the first layer sticks properly

; --- Outer wall generation ---
G1 Z0.2 ; Maintain layer height
G1 X100 Y100 E10 ; Move and extrude to start outer square
G1 X10 Y100 E10 ; 
G1 X10 Y10 E10 ;
G1 X100 Y10 E10 ;
; Outer walls: Typically printed first to preserve dimensional accuracy

; --- Cornering adjustment ---
G1 F1200 ; Reduce speed at corners
G1 X100 Y100 E0.5 ;
; Comment: Slower cornering helps prevent blobbing and maintains sharp edges

; --- Inner wall generation ---
G1 F1800 ; Resume regular speed
G1 X95 Y95 E8 ;
G1 X15 Y95 E8 ;
G1 X15 Y15 E8 ;
G1 X95 Y15 E8 ;
; Comment: Inner walls follow outer walls to enhance structural strength

; --- Understanding extrusion width ---
; Parameters: 
; - Nozzle = 0.4 mm
; - Layer height = 0.2 mm
; - Filament diameter = 1.75 mm

; Flow rate ~ (extrusion_width * layer_height) / (π * (filament_diameter/2)^2)
; Example calculation: (0.4 * 0.2) / ($\pi$ * (0.875)^2) ≈ 0.033 mm³/mm

; --- Smooth top layer strategy ---
G1 Z0.4 ; Move to top layer height
G1 X20 Y20 ;
G1 F1500 ;
G1 X90 E3 ; Lay down parallel top layer strokes
G1 X90 Y90 E3 ;
G1 X20 Y90 E3 ;
G1 X20 Y20 E3 ;
G1 F3000 ;
G1 X20 Y20 ;
G1 F1500 ;
G1 X90 E3 ; Repeat for second pass for smoothing
; Tip: Overlapping infill with slightly lower extrusion helps achieve a smooth finish

; --- Wrap up ---
G92 E0 ; Reset extruder
G1 E-2 F1800 ; Retract filament to prevent stringing
M104 S0 ; Turn off hotend
M140 S0 ; Turn off bed
G28 X0 ; Home X-axis
M84 ; Disable motors
; --- End of G-code demonstration ---
\end{verbatim}

3D printing requires control of the extruder, and matching volumetric calculations (or, more accurately, volumetric calculations which then determine the rate of extrusion).

Previewing in 3D/programming for 3D extrusion will likely want previewing not just the extruded shape, but also tracking the volume of material extruded and how it relates to the volume of the object being filled/the intersection of a just-extruded region with previously extruded material, and how large a void is left (presumably those two volumes would match up).

One concern is that G2/G3 support apparently is not common/guaranteed in \textsc{3d} printer firmwares:

\begin{quotation}
\emph{available if a gcode}\verb|_|\emph{arcs config section is enabled}
\end{quotation}

\noindent \url{https://www.klipper3d.org/G-Codes.html} While it is possible to separately control the feed rate of the extrusion, and the length of material extruded:

\begin{verbatim}
G1 F100 E5 ; Extrude 5 mm of filament at low speed to prime the nozzle
\end{verbatim}

The normal usage is to move at a preset Feed rate in terms of motion, and while that movement is being made, extrude a given length of material:

\begin{verbatim}
; --- First layer adhesion test ---
G1 Z0.2 ; Move nozzle to first layer height
G1 X10 Y10 F3000 ; Move to starting position
G1 F1800 ; Set slower speed for first layer
G1 E0.8 ; Slight retraction before starting
G1 X100 E10 ; Draw a line along X to test bed adhesion
; Comment: This line helps verify that the first layer sticks properly
\end{verbatim}

In theory, if one had a layer height equal to the diameter of the filament, and wanted to extrude a circular cross-section of filament, the value for \verb|E| would be equal to the distance traveled.

Apparently, the firmware control is limited so that the extrusion rate cannot be varied relative to the feed rate so that it is not possible to for example, decrease the speed/increase the extrusion rate, resulting in a trapezoidal extrusion.

Given all that, the idealized (normalized?) shape and dimensions of the extrusion would be controlled by:

\begin{itemize}
\item layer height (for height along Z)
\item extrusion rate (for width in X/Y)
\end{itemize}

\noindent which would be previewed as a rounded cross section, so it should work to create a preview by calculating the volume of material which is being extruded, then determining the volume of a circle of radius layer height/2, subtract that from the extruded volume, then determine what width of rectangle cross section would be necessary at the specified length to make up the difference.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
#Move (G0 or G1): G1 [X<pos>] [Y<pos>] [Z<pos>] [E<pos>] [F<speed>]
    def extrude(self, ex, ey, ez, extrusionwidth = 0, layerheight = 0, feedrate = 0):
        if extrusionwidth > 0:
            self.extrusionwidth = extrusionwidth
        if layerheight > 0:
            self.layerheight = layerheight
        if feedrate > 0:
            self.feedrate = feedrate
        if self.extrusionwidth == self.layerheight:
            c = sphere(self.layerheight/2)
        else:
            ew = self.extrusionwidth
            lh = self.layerheight
            i = circle(lh/2)
            j = i.translate([0,lh/2,0])
            k = intersection(j,square([lh,lh]))
            l = k.translate([ew/2-lh/2,0,0])
            m = union(l, square([ew/2-lh/2, lh]))
            c = rotate_extrude(m)
        c = c.translate([0,0,-self.layerheight])
        tslist = hull(c.translate([self.xpos(), self.ypos(),self.zpos()]), c.translate([ex, ey, ez]))
        self.toolpaths.append(tslist)
        #volume = π · r^2 · length 
        #       + extrusionwidth-layerheight · layerheight ·  length
        distance = math.dist([self.xpos(), self.ypos(), self.zpos()], [ex, ey, ez])
        print("Distance = ", distance)
        v = self.extrusionwidth-self.layerheight * self.layerheight * distance + 3.14159 * self.layerheight/2 * self.layerheight/2 * distance
        print("Volume = ",v)
        el = self.extrusion_normal_length * v
        print("Extrusion length = ",el)
        self.writegc("G01 X" + str(ex) + " Y" + str(ey) + " Z " + str(ez) + " E" + str(el) + " F" + str(self.feedrate))

\end{writecode}
\addtocounter{gcpy}{32}

The system Fullcontrolgcode \url{https://fullcontrolgcode.com/} affords a compleat system for programming a \textsc{3d} printer. The implementation \url{https://py2g.com/} as announced at: \url{https://old.reddit.com/r/FullControl/comments/1mjgta3/i_made_an_online_ide_for_fullcontrol_py2gcom/} affords a straight-forward usage from which the following typical example code is pulled:

\begin{verbatim}
# see https://py2g.com/customize/grid-bins for a bonus interactive UI to use with this sketch

# =============================================================================
# PARAMETERS
# =============================================================================
layer_height = 0.4
line_width   = 1.2
start_x, start_y = 10, 10
grid_unit    = 25
units_x, units_y, units_z = 4, 8, 0.5
outer_radius = 5
tolerance = 0.05

flow_rate = 1.02 # fill in the gaps

bin_type_outer = True # set True to create a bin container

print_speed = 40 # highest speed you'd want to go
max_flow = 8 # in mm3/s
max_print_speed = max_flow / (layer_height*line_width) # highest speed you can go
print_speed = min(print_speed,max_print_speed)

printer_name = 'generic'
printer_settings = {
    'primer':         'travel',
    'print_speed':    print_speed*60,
    'travel_speed':   20*60,
    'nozzle_temp':    210,
    'bed_temp':       50,
    'fan_percent':    100,
    'extrusion_width':  line_width,
    'extrusion_height': layer_height * flow_rate
}


# =============================================================================
# DERIVED DIMENSIONS
# =============================================================================
len_x = units_x * grid_unit
len_y = units_y * grid_unit
len_z = units_z * grid_unit

lim_left   = start_x  + line_width/2 + tolerance/2
lim_right  = start_x  + len_x  - line_width/2 - tolerance/2
lim_bottom = start_y  + line_width/2 + tolerance/2
lim_top    = start_y  + len_y  - line_width/2 - tolerance/2

# set up outer bin dimensions
if bin_type_outer:
    lim_left   -= line_width + tolerance
    lim_right  += line_width + tolerance
    lim_bottom -= line_width + tolerance
    lim_top    += line_width + tolerance
    outer_radius += line_width + tolerance
    # make outer edge come to the same height as inner bins
    len_z += layer_height*2 + tolerance

ilim_left = lim_left + line_width*2
ilim_right = lim_right - line_width*2
ilim_bottom = lim_bottom + line_width*2
ilim_top = lim_top - line_width*2

outer_left   = lim_left
outer_right  = lim_right
outer_bottom = lim_bottom
outer_top    = lim_top

# =============================================================================
# HELPERS: Rounded‐rectangle boundary‐finders
# =============================================================================
def find_boundary_x(y, going_right=True):
    if ilim_bottom + outer_radius <= y <= ilim_top - outer_radius:
        return ilim_right if going_right else ilim_left
    # bottom arc
    if y < ilim_bottom + outer_radius:
        cy = ilim_bottom + outer_radius
        dy = abs(y - cy)
        dx = math.sqrt(max(0, outer_radius**2 - dy**2))
        cx = (ilim_right - outer_radius) if going_right else (ilim_left + outer_radius)
        return cx + ( dx if going_right else -dx )
    # top arc
    if y > ilim_top - outer_radius:
        cy = ilim_top - outer_radius
        dy = abs(y - cy)
        dx = math.sqrt(max(0, outer_radius**2 - dy**2))
        cx = (ilim_right - outer_radius) if going_right else (ilim_left + outer_radius)
        return cx + ( dx if going_right else -dx )
    return ilim_right if going_right else ilim_left

def find_boundary_y(x, going_up=True):
    if ilim_left + outer_radius <= x <= ilim_right - outer_radius:
        return ilim_top if going_up else ilim_bottom
    # left arc
    if x < ilim_left + outer_radius:
        cx = ilim_left + outer_radius
        dx = abs(x - cx)
        dy = math.sqrt(max(0, outer_radius**2 - dx**2))
        cy = (ilim_top - outer_radius) if going_up else (ilim_bottom + outer_radius)
        return cy + ( dy if going_up else -dy )
    # right arc
    if x > ilim_right - outer_radius:
        cx = ilim_right - outer_radius
        dx = abs(x - cx)
        dy = math.sqrt(max(0, outer_radius**2 - dx**2))
        cy = (ilim_top - outer_radius) if going_up else (ilim_bottom + outer_radius)
        return cy + ( dy if going_up else -dy )
    return ilim_top if going_up else ilim_bottom

# =============================================================================
# BUILD STEPS
# =============================================================================
steps    = []
arc_segs = 16
r        = line_width/2


wall_taper = 1.4
if bin_type_outer:
    wall_taper = 0.4

# helper function to draw an outer wall
def add_rounded_rectangle_wall(zh, r, inset = 0):
    rect_left   = outer_left + inset
    rect_right  = outer_right - inset
    rect_bottom = outer_bottom + inset
    rect_top    = outer_top - inset
    corners = [
        fc.Point(x=rect_right - r, y=rect_bottom + r, z=zh),  # br
        fc.Point(x=rect_right - r, y=rect_top    - r, z=zh),  # tr
        fc.Point(x=rect_left  + r, y=rect_top    - r, z=zh),  # tl
        fc.Point(x=rect_left  + r, y=rect_bottom + r, z=zh)   # bl
    ]
    steps.append(fc.Point(x=rect_right - r, y=rect_bottom, z=zh))
    steps.extend(fc.arcXY(corners[0], r, -math.pi/2, +math.pi/2, arc_segs))
    steps.append(fc.Point(x=rect_right, y=rect_top - r, z=zh))
    steps.extend(fc.arcXY(corners[1], r,  0,           math.pi/2, arc_segs))
    steps.append(fc.Point(x=rect_left + r, y=rect_top, z=zh))
    steps.extend(fc.arcXY(corners[2], r,  math.pi/2,   math.pi/2, arc_segs))
    steps.append(fc.Point(x=rect_left, y=rect_bottom + r, z=zh))
    steps.extend(fc.arcXY(corners[3], r,  math.pi,      math.pi/2, arc_segs))

# turn extruder on
steps.append(fc.Extruder(on=True))

# -------------------------------------------------------------------------
# LAYER 1: HORIZONTAL ZIG-ZAG
# -------------------------------------------------------------------------
z = layer_height
y = ilim_bottom
dir_h = +1   # +1 = left→right, -1 = right→left

# prime at first point
x0 = find_boundary_x(y, going_right=(dir_h>0))
steps.append(fc.Point(x=x0, y=y, z=z))

while True:
    # travel to boundary
    xt = find_boundary_x(y, going_right=(dir_h>0))
    steps.append(fc.Point(x=xt, y=y, z=z))
    current_x = xt

    # next scan-line
    next_y = y + line_width
    if next_y > ilim_top:
        break

    # U-turn semicircle of radius r
    center = fc.Point(x=current_x, y=y + r, z=z)
    if dir_h > 0:
        # right edge: CCW half-circle from bottom to top
        steps.extend(fc.arcXY(center, r, -math.pi/2, +math.pi, arc_segs))
    else:
        # left edge:  CW half-circle from bottom to top
        steps.extend(fc.arcXY(center, r, -math.pi/2, -math.pi, arc_segs))

    y     = next_y
    dir_h = -dir_h

# outline the first layer
weld_offset = (wall_taper+0.5)*line_width
add_rounded_rectangle_wall(z, outer_radius - weld_offset, weld_offset)

# -------------------------------------------------------------------------
# LAYER 2: VERTICAL ZIG-ZAG
# -------------------------------------------------------------------------
z += layer_height
x = ilim_left
dir_v = +1   # +1 = bottom→top, -1 = top→bottom

# prime at first point
y0 = find_boundary_y(x, going_up=(dir_v>0))
steps.append(fc.Point(x=x, y=y0, z=z))

while True:
    # travel to boundary
    yt = find_boundary_y(x, going_up=(dir_v>0))
    steps.append(fc.Point(x=x, y=yt, z=z))
    current_y = yt

    # next scan-line
    next_x = x + line_width
    if next_x > ilim_right:
        break

    # U-turn semicircle of radius r
    center = fc.Point(x=x + r, y=current_y, z=z)
    if dir_v > 0:
        # top edge: CCW half-circle from left to right
        steps.extend(fc.arcXY(center, r, math.pi, -math.pi, arc_segs))
    else:
        # bottom edge:  CW half-circle from left to right
        steps.extend(fc.arcXY(center, r, math.pi, +math.pi, arc_segs))

    x     = next_x
    dir_v = -dir_v

# =============================================================================
# WALLS WITH ROUNDED CORNERS (remaining layers)
# =============================================================================

weld_offset = (wall_taper+1.5)*line_width
add_rounded_rectangle_wall(z, outer_radius - weld_offset, weld_offset)
weld_offset = (wall_taper+0.75)*line_width
add_rounded_rectangle_wall(z, outer_radius - weld_offset, weld_offset)

while z < len_z:
    if wall_taper > 0:
        wall_taper -= layer_height/2
        wall_taper = max(wall_taper,0)
    add_rounded_rectangle_wall(z, outer_radius, wall_taper*line_width)
    z += layer_height

# repeat final wall and then quick ironing pass to smooth the top
add_rounded_rectangle_wall(z, outer_radius)
add_rounded_rectangle_wall(z, outer_radius)
steps.append(fc.Extruder(on=False))
z += layer_height/10 # lift a bit
add_rounded_rectangle_wall(z, outer_radius)
z += layer_height/10 # lift a bit
add_rounded_rectangle_wall(z, outer_radius)
z += layer_height # lift off
add_rounded_rectangle_wall(z, outer_radius) # maybe unnecessary
steps.append(fc.Point(z=z+20)) # lift after complete
\end{verbatim}



\subsection{Difference of Stock, Rapids, and Toolpaths}

At the end of cutting it will be necessary to subtract the accumulated toolpaths and rapids from the stock. %If in OpenSCAD, the \textsc{3d} model is returned by each operation, causing it to be instantiated on the \textsc{3d} stage unless the Boolean \verb|generatepaths| is True.

For Python, the initial \textsc{3d} model is stored in the variable \verb|stock|:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def stockandtoolpaths(self, option = "stockandtoolpaths"):
        if option == "stock":
            show(self.stock)
        elif option == "toolpaths":
            show(self.toolpaths)
        elif option == "rapids":
            show(self.rapids)
        else:
            part = self.stock.difference(self.rapids)
            part = self.stock.difference(self.toolpaths)
            show(part)

\end{writecode}
\addtocounter{gcpy}{12}

A separate set of commands for showing the outline of the currently selected tool and/or its shaft is useful for checking that a tool outline definition is correctly formed.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def showtooloutline(self):
        to = union(self.tooloutline, self.shaftoutline)
        show(to)

    def showtoolprofile(self):
        to = union(self.toolprofile, self.shaftprofile)
        show(to)

    def showtoolshape(self):
        to = union(self.currenttoolshape, self.currenttoolshaft)
        show(to)

\end{writecode}
\addtocounter{gcpy}{12}

\noindent Note that because of the differences in behaviour between OpenPythonSCAD (the \verb|show()| command results in an explicit display of the requested element) and OpenSCAD (there is an implicit mechanism where the \textsc{3d} element which is returned is displayed), the most expedient mechanism is to have an explicit Python command which returns the \textsc{3d} model:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def returnstockandtoolpaths(self):
        part = self.stock.difference(self.toolpaths)
        return part

\end{writecode}
\addtocounter{gcpy}{4}

\noindent and then make use of that specific command for OpenSCAD:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module stockandtoolpaths(){
    gcp.returnstockandtoolpaths();
}

\end{writecode}
\addtocounter{gcpscad}{4}

\noindent forgoing the options of showing toolpaths and/or rapids separately.


\subsection{Output files}

The \verb|gcodepreview| class will write out \textsc{dxf} and/or G-code files.

%#basefilename = "export", 
%#                 generatepaths = False, 
%                 generategcode = False, 
%                 generatedxf = False, 
%#                 stockXwidth = 25, 
%#                 stockYheight = 25, 
%#                 stockZthickness = 1, 
%#                 zeroheight = "Top", 
%#                 stockzero = "Lower-left", 
%#                 retractheight = 6, 
%#                 currenttoolnum = 102, 
%#                 toolradius = 3.175, 
%#                 plunge = 100, 
%#                 feed = 400, 
%#                 speed = 10000

\subsubsection{Python and OpenSCAD File Handling}

The class \verb|gcodepreview| will need additional commands for opening files. The original implementation in {RapSCAD} used a command \DescribeSubroutine{gcodepreview}{writeln} --- fortunately, this command is easily re-created in Python, though it is made as a separate file for each sort of file which may be opened. Note that the \verb|dxf| commands will be wrapped up with \verb|if/elif| blocks which will write to additional file(s) based on tool number as set up above.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def writegc(self, *arguments):
        if self.generategcode == True:
            line_to_write = ""
            for element in arguments:
                line_to_write += element
            self.gc.write(line_to_write)
            self.gc.write("\n")

    def writedxf(self, toolnumber, *arguments):
#        global dxfclosed
        line_to_write = ""
        for element in arguments:
            line_to_write += element
        if self.generatedxf == True:
            if self.dxfclosed == False:
                self.dxf.write(line_to_write)
                self.dxf.write("\n")
        if self.generatedxfs == True:
            self.writedxfs(toolnumber, line_to_write)

    def writedxfs(self, toolnumber, line_to_write):
#        print("Processing writing toolnumber", toolnumber)
#        line_to_write = ""
#        for element in arguments:
#            line_to_write += element
        if (toolnumber == 0):
            return
        elif self.generatedxfs == True:
            if (self.large_square_tool_num == toolnumber):
                self.dxflgsq.write(line_to_write)
                self.dxflgsq.write("\n")
            if (self.small_square_tool_num == toolnumber):
                self.dxfsmsq.write(line_to_write)
                self.dxfsmsq.write("\n")
            if (self.large_ball_tool_num == toolnumber):
                self.dxflgbl.write(line_to_write)
                self.dxflgbl.write("\n")
            if (self.small_ball_tool_num == toolnumber):
                self.dxfsmbl.write(line_to_write)
                self.dxfsmbl.write("\n")
            if (self.large_V_tool_num == toolnumber):
                self.dxflgV.write(line_to_write)
                self.dxflgV.write("\n")
            if (self.small_V_tool_num == toolnumber):
                self.dxfsmV.write(line_to_write)
                self.dxfsmV.write("\n")
            if (self.DT_tool_num == toolnumber):
                self.dxfDT.write(line_to_write)
                self.dxfDT.write("\n")
            if (self.KH_tool_num == toolnumber):
                self.dxfKH.write(line_to_write)
                self.dxfKH.write("\n")
            if (self.Roundover_tool_num == toolnumber):
                self.dxfRt.write(line_to_write)
                self.dxfRt.write("\n")
            if (self.MISC_tool_num == toolnumber):
                self.dxfMt.write(line_to_write)
                self.dxfMt.write("\n")

\end{writecode}
\addtocounter{gcpy}{59}

\noindent which commands will accept a series of arguments and then write them out to a file object for the appropriate file. Note that the \textsc{dxf} files for specific tools will expect that the tool numbers be set in the matching variables from the template. Further note that while it is possible to use tools which are not so defined, the toolpaths will not be written into \textsc{dxf} files for any tool numbers which do not match the variables from the template (but will appear in the main \verb|.dxf|).
 
For writing to files it will be necessary to have commands for opening the files: \DescribeRoutine{opengcodefile} and \DescribeRoutine{opendxffile} which will set the associated defaults. There is a separate function for each type of file, and for \textsc{dxf}s, there are multiple file instances, one for each combination of different type and size of tool which it is expected a project will work with. Each such file will be suffixed with the tool number.

%\begin{itemize}
%\item \verb|opendxflgsqfile|
%\item \verb|opendxfsmsqfile|
%\item \verb|opendxflgblfile|
%\item \verb|opendxfsmblfile|
%\item \verb|opendxflgVfile|
%\item \verb|opendxfsmVfile|
%\end{itemize}
%
There will need to be matching OpenSCAD modules for the Python functions:

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module opendxffile(basefilename){
    gcp.opendxffile(basefilename);
}

module opendxffiles(Base_filename, large_square_tool_num, small_square_tool_num, large_ball_tool_num, small_ball_tool_num, large_V_tool_num, small_V_tool_num, DT_tool_num, KH_tool_num, Roundover_tool_num, MISC_tool_num) {
    gcp.opendxffiles(Base_filename, large_square_tool_num, small_square_tool_num, large_ball_tool_num, small_ball_tool_num, large_V_tool_num, small_V_tool_num, DT_tool_num, KH_tool_num, Roundover_tool_num, MISC_tool_num);
}

\end{writecode}
\addtocounter{gcpscad}{8}

With matching OpenSCAD commands: \DescribeRoutine{opengcodefile} for OpenSCAD:

%\DescribeRoutine{opensvgfile}
 
\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module opengcodefile(basefilename, currenttoolnum, toolradius, plunge, feed, speed) {
    gcp.opengcodefile(basefilename, currenttoolnum, toolradius, plunge, feed, speed);
}

\end{writecode}
\addtocounter{gcpscad}{4}

\noindent and Python:

%TODO opendxffile wants a "stagger" option which will cause all colour positions to be offset by being multiplied by colour number

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def opengcodefile(self, basefilename = "export", 
                      currenttoolnum = 102, 
                      toolradius = 3.175, 
                      plunge = 400, 
                      feed = 1600, 
                      speed = 10000
                      ):
        self.basefilename = basefilename
        self.currenttoolnum = currenttoolnum
        self.toolradius = toolradius
        self.plunge = plunge
        self.feed = feed
        self.speed = speed
        if self.generategcode == True:
            self.gcodefilename = basefilename + self.gcodefilext
            self.gc = open(self.gcodefilename, "w")
            self.writegc("(Design File: " + self.basefilename + ")")

    def opendxffile(self, basefilename = "export"): 
        self.basefilename = basefilename
#        global generatedxfs
#        global dxfclosed
        self.dxfclosed = False
        self.dxfcolor = "Black"
        if self.generatedxf == True:
            self.generatedxfs = False
            self.dxffilename = basefilename + ".dxf"
            self.dxf = open(self.dxffilename, "w")
            self.dxfpreamble(-1)

    def opendxffiles(self, basefilename = "export", 
                     large_square_tool_num = 0, 
                     small_square_tool_num = 0, 
                     large_ball_tool_num = 0, 
                     small_ball_tool_num = 0, 
                     large_V_tool_num = 0, 
                     small_V_tool_num = 0, 
                     DT_tool_num = 0, 
                     KH_tool_num = 0, 
                     Roundover_tool_num = 0, 
                     MISC_tool_num = 0):
#        global generatedxfs
        self.basefilename = basefilename
        self.generatedxfs = True
        self.large_square_tool_num = large_square_tool_num 
        self.small_square_tool_num = small_square_tool_num
        self.large_ball_tool_num = large_ball_tool_num
        self.small_ball_tool_num = small_ball_tool_num
        self.large_V_tool_num = large_V_tool_num
        self.small_V_tool_num = small_V_tool_num
        self.DT_tool_num = DT_tool_num
        self.KH_tool_num = KH_tool_num
        self.Roundover_tool_num = Roundover_tool_num
        self.MISC_tool_num = MISC_tool_num
        if self.generatedxf == True:
            if (large_square_tool_num > 0):
                self.dxflgsqfilename = basefilename + str(large_square_tool_num) + ".dxf"
#                print("Opening ", str(self.dxflgsqfilename))
                self.dxflgsq = open(self.dxflgsqfilename, "w")
            if (small_square_tool_num > 0):
#                print("Opening small square")
                self.dxfsmsqfilename = basefilename + str(small_square_tool_num) + ".dxf"
                self.dxfsmsq = open(self.dxfsmsqfilename, "w")
            if (large_ball_tool_num > 0):
#                print("Opening large ball")
                self.dxflgblfilename = basefilename + str(large_ball_tool_num) + ".dxf"
                self.dxflgbl = open(self.dxflgblfilename, "w")
            if (small_ball_tool_num > 0):
#                print("Opening small ball")
                self.dxfsmblfilename = basefilename + str(small_ball_tool_num) + ".dxf"
                self.dxfsmbl = open(self.dxfsmblfilename, "w")
            if (large_V_tool_num > 0):
#                print("Opening large V")
                self.dxflgVfilename = basefilename + str(large_V_tool_num) + ".dxf"
                self.dxflgV = open(self.dxflgVfilename, "w")
            if (small_V_tool_num > 0):
#                print("Opening small V")
                self.dxfsmVfilename = basefilename + str(small_V_tool_num) + ".dxf"
                self.dxfsmV = open(self.dxfsmVfilename, "w")
            if (DT_tool_num > 0):
#                print("Opening DT")
                self.dxfDTfilename = basefilename + str(DT_tool_num) + ".dxf"
                self.dxfDT = open(self.dxfDTfilename, "w")
            if (KH_tool_num > 0):
#                print("Opening KH")
                self.dxfKHfilename = basefilename + str(KH_tool_num) + ".dxf"
                self.dxfKH = open(self.dxfKHfilename, "w")
            if (Roundover_tool_num > 0):
#                print("Opening Rt")
                self.dxfRtfilename = basefilename + str(Roundover_tool_num) + ".dxf"
                self.dxfRt = open(self.dxfRtfilename, "w")
            if (MISC_tool_num > 0):
#                print("Opening Mt")
                self.dxfMtfilename = basefilename + str(MISC_tool_num) + ".dxf"
                self.dxfMt = open(self.dxfMtfilename, "w")
\end{writecode}
\addtocounter{gcpy}{95}

For each \textsc{dxf} file, there will need to be a Preamble in addition to opening the file in the file system:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
            if (large_square_tool_num > 0):
                self.dxfpreamble(large_square_tool_num)
            if (small_square_tool_num > 0):
                self.dxfpreamble(small_square_tool_num)
            if (large_ball_tool_num > 0):
                self.dxfpreamble(large_ball_tool_num)
            if (small_ball_tool_num > 0):
                self.dxfpreamble(small_ball_tool_num)
            if (large_V_tool_num > 0):
                self.dxfpreamble(large_V_tool_num)
            if (small_V_tool_num > 0):
                self.dxfpreamble(small_V_tool_num)
            if (DT_tool_num > 0):
                self.dxfpreamble(DT_tool_num)
            if (KH_tool_num > 0):
                self.dxfpreamble(KH_tool_num)
            if (Roundover_tool_num > 0):
                self.dxfpreamble(Roundover_tool_num)
            if (MISC_tool_num > 0):
                self.dxfpreamble(MISC_tool_num)

\end{writecode}
\addtocounter{gcpy}{21}

Note that the commands which interact with files include checks to see if said files are being generated.


Future considerations:

\begin{itemize}
\item Multiple Preview Modes:
\item Fast Preview: Write all movements with both begin and end positions into a list for a specific tool --- as this is done, check for a previous movement between those positions and compare depths and tool number --- keep only the deepest movement for a given tool.
\item Motion Preview: Work up a \textsc{3d} model of the machine and actually show the stock in relation to it, 
\end{itemize}

%#        show(self.stockandtoolpaths("stock"))
%    def previewgcodefileWITHDIVOT(self, gc_filecontents):
%        commands = []        
%        for line in gcfilecontents:
%            fr = 0.0
%            if line == "G53G0Z-5.000\n":
%#                print("found safe height")
%#                commands.append("movetosafeZ()")
%                 self.movetosafeZ()
%            if line[:3] == "M6T":
%                tool = int(line[3:])
%#                tc = "toolchange(" + str(tool) + ")"
%#                commands.append(tc)
%                self.toolchange(tool)
%#            left = line[:2]
%            if line[:2] == "G0":
%                machinestate = "rapid"
%                if line[2:3] == "X":
%                    if "Y" not in line:
%                        if "Z" not in line:
%                            Xp = float(line[3:])
%#                            print("Xpos = ", Xp)
%#                            rx = "rapidX(" + str(Xp) + ")"
%#                            commands.append(rx)
%                            self.rapidX(Xp)
%                    elif "Y" in line:
%                        subdivisions = line.split("Y")
%#                        print(subdivisions)
%                        if "Z" not in line:
%                            Xp = float(subdivisions[0][3:])
%                            Yp = float(subdivisions[1])
%#                            rxy = "rapidXY(" + str(Xp) + ", " + str(Yp) + ")"
%#                            print(rxy)
%#                            commands.append(rxy)
%                            self.rapidXY(Xp, Yp)
%                        elif "Z" in line:
%                            Xp = float(subdivisions[0][3:])
%                            Yplus = subdivisions[1].split("Z")
%#                            print("Xp = ", Xp, "Yplus = ", Yplus)
%                            Yp = float(Yplus[0])
%                            Zp = float(Yplus[1])
%#                            rxyz = "rapidXYZ(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ")"
%#                            commands.append(rxyz)
%                            self.rapidXYZ(Xp, Yp, Zp)
%                elif line[2:3] == "Y":
%                    if "Z" not in line:
%                        Yp = float(line[3:])
%#                            print("Ypos = ", Yp)
%#                            ry = "rapidY(" + str(Yp) + ")"
%#                            commands.append(ry)
%                        self.rapidY(Yp)
%                elif line[2:3] == "Z":
%                    Zp = float(line[3:])
%#                        print("Zpos = ", Zp)
%#                        rz = "rapidZ(" + str(Zp) + ")"
%#                        commands.append(rz)
%                    self.rapidZ(Zp)
%            if line[:2] == "G1":
%                if "F" in line:
%                    fless = line.split("F")
%#                    flen = len(fless[1])
%                    fr = float(fless[1])
%#                    print("flen = ", flen)
%                    line = fless[0]
%                machinestate = "cutline"
%                if line[2:3] == "X":
%                    if "Y" not in line:
%                        if "Z" not in line:
%                            Xp = float(line[3:])
%#                            print("Xpos = ", Xp)
%#                            rx = "cutlineX(" + str(Xp) + ")"
%#                            commands.append(rx)
%                            self.cutlineX(Xp)
%                    elif "Y" in line:
%                        subdivisions = line.split("Y")
%#                        print(subdivisions)
%                        if "Z" not in line:
%                            Xp = float(subdivisions[0][3:])
%                            Yp = float(subdivisions[1])
%#                            rxy = "cutlineXY(" + str(Xp) + ", " + str(Yp) + ")"
%#                            print(rxy)
%#                            commands.append(rxy)
%                            self.cutlineXY(Xp, Yp)
%                        elif "Z" in line:
%                            Xp = float(subdivisions[0][3:])
%                            Yplus = subdivisions[1].split("Z")
%#                            print("Xp = ", Xp, "Yplus = ", Yplus)
%                            Yp = float(Yplus[0])
%                            Zp = float(Yplus[1])
%#                            rxyz = "cutlineXYZ(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ")"
%#                            commands.append(rxyz)
%                            self.cutlineXYZ(Xp, Yp, Zp)
%                elif line[2:3] == "Y":
%                        if "Z" not in line:
%                            Yp = float(line[3:])
%#                            print("Ypos = ", Yp)
%#                            ry = "cutlineY(" + str(Yp) + ")"
%#                            commands.append(ry)
%                            self.cutlineY(Yp)
%                elif line[2:3] == "Z":
%#                         print("Current = ", line)
%                        Zp = float(line[3:])
%#                        print("Zpos = ", Zp)
%                        if fr == 0:
%#                            rz = "cutlineZ(" + str(Zp) + ")"
%                            self.cutlineZ(Zp)
%                        else:
%#                            rz = "cutlineZwithfeed(" + str(Zp) + ", " + str(fr) + ")"
%                            self.cutlineZ(Zp)
%#                        commands.append(rz)
%            if line[:1] == "Z":
%#                print(line)
%                Zp = float(line[1:])
%                if fr == 0:
%#                    rz = machinestate + "Z(" + str(Zp) + ")"
%                    if machinestate == "rapid":
%                        self.rapidZ(Zp)
%                    if machinestate == "cutline":
%#                        rz = machinestate + "Z(" + str(Zp) + ")"
%                        self.cutlineZ(Zp)
%                else:
%#                    rz = machinestate + "Zwithfeed(" + str(Zp) + ", " + str(fr) + ")"
%#                commands.append(rz)
%                    if machinestate == "rapid":
%                        self.rapidZ(Zp)
%                    if machinestate == "cutline":
%#                    rz = machinestate + "Z(" + str(Zp) + ")"
%                        self.cutlineZ(Zp)
%            if line[:1] == "X":
%                if "F" in line:
%                    fless = line.split("F")
%#                    flen = len(fless[1])
%                    fr = float(fless[1])
%#                    print("flen = ", flen)
%                    line = fless[0]
%                if "Z" not in line:
%                    if "Y" in line:
%                        Xplus = line.split("Y")
%#                        print(Yplus)
%                        Xp = float(Xplus[0][1:])
%                        Yp = float(Xplus[1])
%#                        print(Xp, Yp)
%                        if fr == 0:
%#                            rxy = machinestate + "XY(" + str(Xp) + ", " + str(Yp) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXY(Xp, Yp)
%                            if machinestate == "cutline":
%#                            rz = machinestate + "Z(" + str(Zp) + ")"
%                                self.cutlineXY(Xp, Yp)
%                        else:
%#                            rxy = machinestate + "XYwithfeed(" + str(Xp) + ", " + str(Yp) + ", " + str(fr) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXY(Xp, Yp)
%                            if machinestate == "cutline":
%#                            rz = machinestate + "Z(" + str(Zp) + ")"
%                                self.cutlineXY(Xp, Yp)
%#                        print(line, "XY ", rxy)
%#                        commands.append(rxy)
%                    else:
%                        Xp = float(line[1:])
%#                        print("else", Xp)
%                        if fr == 0:
%#                            rx = machinestate + "X(" + str(Xp) + ")"
%                            if machinestate == "rapid":
%                                self.rapidX(Xp)
%                            if machinestate == "cutline":
%                                self.cutlineX(Xp)
%                        else:
%#                            rx = machinestate + "Xwithfeed(" + str(Xp) + ", " + str(fr) + ")"
%                            if machinestate == "rapid":
%                                self.rapidX(Xp)
%                            if machinestate == "cutline":
%                                self.cutlineX(Xp)
%#                        commands.append(rx)
%                elif "Z" in line:
%                    if "Y" in line:
%                        Xplus = line.split("Y")
%#                        print(Yplus)
%                        Xp = float(Xplus[0][1:])
%                        Yplus = Xplus[1].split("Z")
%                        Yp = float(Yplus[0])
%                        Zp = float(Yplus[1])
%#                        print(Xp, Yplus)
%                        if fr == 0:
%#                            rxyz = machinestate + "XYZ(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXYZ(Xp, Yp, Zp)
%                            if machinestate == "cutline":
%                                self.cutlineXYZ(Xp, Yp, Zp)
%                        else:
%#                            rxyz = machinestate + "XYZwithfeed(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ", " + str(fr) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXYZ(Xp, Yp, Zp)
%                            if machinestate == "cutline":
%                                self.cutlineXYZ(Xp, Yp, Zp)
%#                        commands.append(rxyz)
%#                        fr == 0.0
%                    else:
%                        Xplus = line.split("Z")
%                        Xp = float(Xplus[0][1:])
%                        Zp = float(Xplus[1])
%                        if fr == 0:
%#                            rxz = machinestate + "XZ(" + str(Xp) + ", " + str(Zp) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXY(Xp, Yp)
%                            if machinestate == "cutline":
%                                self.cutlineXY(Xp, Yp)
%                        else:
%#                            rxz = machinestate + "XZwithfeed(" + str(Xp) + ", " + str(Zp) + ", " + str(fr) + ")"
%                            if machinestate == "rapid":
%                                self.rapidXY(Xp, Yp)
%                            if machinestate == "cutline":
%                                self.cutlineXY(Xp, Yp)
%#                        print(line, "XZ ", rxz)
%#                        commands.append(rxz)
%            if line[:1] == "Y":
%                if "Z" in line:
%                    Yplus = line.split("Z")
%                    Yp = float(Yplus[0][1:])
%                    Zp = float(Yplus[1])
%                    if fr == 0:
%#                        ryz = machinestate + "YZ(" + str(Yp) + ", " + str(Zp) + ")"
%                        if machinestate == "rapid":
%                            self.rapidYZ(Yp, Zp)
%                        if machinestate == "cutline":
%                            self.cutlineYZ(Yp, Zp)
%                    else:
%#                        ryz = machinestate + "YZwithfeed(" + str(Yp) + ", " + str(Zp) + ", " + str(fr) + ")"
%                        if machinestate == "rapid":
%                            self.rapidYZ(Yp, Zp)
%                        if machinestate == "cutline":
%                            self.cutlineYZ(Yp, Zp)
%#                    print(line, "YZ ", ryz)
%#                    commands.append(ryz)
%                else:
%                    Yp = float(line[1:])
%                    if fr == 0:
%#                        ry = machinestate + "Y(" + str(Yp) + ")"
%                        if machinestate == "rapid":
%                            self.rapidY(Yp)
%                        if machinestate == "cutline":
%                            self.cutlineY(Yp)
%                    else:
%#                        ry = machinestate + "Ywithfeed(" + str(Yp) + ", " + str(fr) + ")"
%                        if machinestate == "rapid":
%                            self.rapidY(Yp)
%                        if machinestate == "cutline":
%                            self.cutlineY(Yp)
%#                    print(line, "Y ", ry)
%#                    commands.append(ry)

\subsubsection{DXF Overview}

Elements in \textsc{dxf}s are represented as lines or arcs. A minimal file showing both:

\begin{verbatim}
0
SECTION
2
ENTITIES
0
LWPOLYLINE
90
2
70
0
43
0
10
-31.375
20
-34.9152
10
-31.375
20
-18.75
0
ARC
10
-54.75
20
-37.5
40
4
50
0
51
90
0
ENDSEC
0
EOF
\end{verbatim}

%\paragraph{begincutdxf}
% 
%The first command, \DescribeRoutine{begincutdxf} will need to allow the machine to rapid to the beginning point of the cut and then rapid down to the surface of the stock, and then plunge down to the depth of the cut. The implementation will need to allow for a hook where the Depth per Pass is applied to the plunge operation so that multiple passes are made.
%
%The first module will ensure that the tool is safely up above the stock and will rapid to the position specified at the retract height (moving to that position as an initial step, then will \texttt{cutwithfeed} to the specified position at the specified feed rate. Despite \texttt{dxf} being included in the filename no change is made to the dxf file at this time, this simply indicates that this file is preparatory to the use of \DescribeRoutine{continuecutdxf}.
%
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module begincutdxf(rh, ex, ey, ez, fr) {
%  rapid(getxpos(), getypos(), rh);
%  cutwithfeed(ex, ey, ez, fr);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{5}
% 
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module continuecutdxf(ex, ey, ez, fr) {
%  cutwithfeed(ex, ey, ez, fr);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{4}
%\end{verbatim}


\paragraph{Writing to DXF files}
 
When the command to open \verb|.dxf| files is called it is passed all of the variables for the various tool types/sizes, and based on a value being greater than zero, the matching file is opened, and in addition, the main \textsc{dxf} which is always written to is opened as well. On the gripping hand, each element which may be written to a \textsc{dxf} file will have a user module as well as an internal module which will be called by it so as to write to the file for the current tool. It will be necessary for the \DescribeRoutine{dxfwrite} command to evaluate the tool number which is passed in, and to use an appropriate command or set of commands to then write out to the appropriate file for a given tool (if positive) or not do anything (if zero), and to write to the master file if a negative value is passed in (this allows the various \textsc{dxf} template commands to be written only once and then called at need).

Each tool has a matching command for each tool/size combination:

\begin{itemize}
\item Ball nose, large (lgbl) \DescribeRoutine{writedxflgbl}
\item Ball nose, small (smbl) \DescribeRoutine{writedxfsmbl}
\item Square, large (lgsq) \DescribeRoutine{writedxflgsq}
\item Square, small (smsq) \DescribeRoutine{writedxfsmsq}
\item V, large (lgV) \DescribeRoutine{writedxflgV}
\item V, small (smV) \DescribeRoutine{writedxfsmV}
\item Keyhole (KH) \DescribeRoutine{writedxfKH}
\item Dovetail (DT) \DescribeRoutine{writedxfDT}
\end{itemize}
 
%\paragraph{Writing to DXFs}%\DescribeRoutine{writesvgline}

This module requires that the tool number be passed in, and after writing out \DescribeRoutine{dxfpreamble}, that value will be used to write out to the appropriate file with a series of \texttt{if} statements.
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfpreamble(self, tn):
#        self.writedxf(tn, str(tn))
        self.writedxf(tn, "0")
        self.writedxf(tn, "SECTION")
        self.writedxf(tn, "2")
        self.writedxf(tn, "ENTITIES")

\end{writecode}
\addtocounter{gcpy}{7}

%0
%SECTION
%2
%HEADER
%0
%ENDSEC
%0
%SECTION
%2
%TABLES
%0
%ENDSEC
%0
%SECTION
%2
%BLOCKS
%0
%ENDSEC
%0
%SECTION
%2
%ENTITIES

\subparagraph{DXF Lines and Arcs}%
 
There are several elements which may be written to a \textsc{dxf}:

\begin{itemize}
 \item a line \DescribeRoutine{dxfline}%: LWPOLYLINE is one possible implementation: \DescribeRoutine{dxfbpl} 
 \item connected lines \DescribeRoutine{beginpolyline}/\DescribeRoutine{addvertex}/\DescribeRoutine{closepolyline}
 \item arc \DescribeRoutine{dxfarc}
 \item circle --- a notable option would be for the arc to close on itself, creating a circle \DescribeRoutine{dxfcircle}
\end{itemize}
 
\textsc{dxf} orders arcs counter-clockwise:

\includeimage{arcs_circle_degrees.pdf}%

Note that arcs of greater than 90 degrees are not rendered accurately (in certain applications at least), so, for the sake of precision, they should be limited to a swing of 90 degrees or less. Further note that 4 arcs may be stitched together to make a circle:
 
\begin{verbatim}
           dxfarc(10, 10, 5,   0,  90, small_square_tool_num);
           dxfarc(10, 10, 5,  90, 180, small_square_tool_num);
           dxfarc(10, 10, 5, 180, 270, small_square_tool_num);
           dxfarc(10, 10, 5, 270, 360, small_square_tool_num);
\end{verbatim}
 
%Note that a circle may be defined in a DXF as:
%
%0
%CIRCLE
%8
%Layer1
%62
%1
%10
%50.0
%20
%50.0
%40
%25.0
%
%which will create a red circle centered on 50,50 with a radius of 25

The \textsc{dxf} file format supports colors defined by AutoCAD's indexed color system:

\begin{center}
\noindent\begin{tabular}{cl}
Color Code & Color Name \\
\toprule
     0 & Black (or Foreground)  \\
     1 & Red \\
     2 & Yellow \\
     3 & Green  \\
     4 & Cyan  \\
     5 & Blue \\
     6 & Magenta \\ 
     7 & White (or Background)\\
     8 & Dark Gray \\ 
     9 & Light Gray \\\bottomrule
\end{tabular}
\end{center}

Color codes 10--255 represent additional colors, with hues varying based on RGB values.

Obviously, a command to manage adding the color commands would be:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def setdxfcolor(self, color):
        self.dxfcolor = color
        self.cutcolor = color

    def writedxfcolor(self, tn):
            self.writedxf(tn, "8")
            if (self.dxfcolor == "Black"):
                self.writedxf(tn, "Layer_Black")
            if (self.dxfcolor == "Red"):
                self.writedxf(tn, "Layer_Red")
            if (self.dxfcolor == "Yellow"):
                self.writedxf(tn, "Layer_Yellow")
            if (self.dxfcolor == "Green"):
                self.writedxf(tn, "Layer_Green")
            if (self.dxfcolor == "Cyan"):
                self.writedxf(tn, "Layer_Cyan")
            if (self.dxfcolor == "Blue"):
                self.writedxf(tn, "Layer_Blue")
            if (self.dxfcolor == "Magenta"):
                self.writedxf(tn, "Layer_Magenta")
            if (self.dxfcolor == "White"):
                self.writedxf(tn, "Layer_White")
            if (self.dxfcolor == "Dark Gray"):
                self.writedxf(tn, "Layer_Dark_Gray")
            if (self.dxfcolor == "Light Gray"):
                self.writedxf(tn, "Layer_Light_Gray")

            self.writedxf(tn, "62")
            if (self.dxfcolor == "Black"):
                self.writedxf(tn, "0")
            if (self.dxfcolor == "Red"):
                self.writedxf(tn, "1")
            if (self.dxfcolor == "Yellow"):
                self.writedxf(tn, "2")
            if (self.dxfcolor == "Green"):
                self.writedxf(tn, "3")
            if (self.dxfcolor == "Cyan"):
                self.writedxf(tn, "4")
            if (self.dxfcolor == "Blue"):
                self.writedxf(tn, "5")
            if (self.dxfcolor == "Magenta"):
                self.writedxf(tn, "6")
            if (self.dxfcolor == "White"):
                self.writedxf(tn, "7")
            if (self.dxfcolor == "Dark Gray"):
                self.writedxf(tn, "8")
            if (self.dxfcolor == "Light Gray"):
                self.writedxf(tn, "9")

\end{writecode}
\addtocounter{gcpy}{49}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module setdxfcolor(color){
    gcp.setdxfcolor(color);
}

\end{writecode}
\addtocounter{gcpscad}{4}

A further refinement would be to connect multiple line segments/arcs into a larger polyline, but since most \textsc{cam} tools implicitly join elements on import, that is not necessary.
 
There are three possible interactions for \textsc{dxf} elements and toolpaths:

\begin{itemize}
 \item describe the motion of the tool
 \item define a perimeter of an area which will be cut by a tool
 \item define a centerpoint for a specialty toolpath such as Drill or Keyhole
\end{itemize}
 
\noindent and it is possible that multiple such elements could be instantiated for a given toolpath.
 
When writing out to a \textsc{dxf} file there is a pair of commands, a public facing command which takes in a tool number in addition to the coordinates which then writes out to the main \textsc{dxf} file and then calls an internal command to which repeats the call with the tool number so as to write it out to the matching file.

%The original \verb|dxfline| definition has been changed to \verb|dxfpolyline| so as to match the term used in it:
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%    def dxfpolyline(self, tn, xbegin, ybegin, xend, yend):
%        self.writedxf(tn, "0")
%        self.writedxf(tn, "LWPOLYLINE")
%        self.writedxf(tn, "90")
%        self.writedxf(tn, "2")
%        self.writedxf(tn, "70")
%        self.writedxf(tn, "0")
%        self.writedxf(tn, "43")
%        self.writedxf(tn, "0")
%        self.writedxf(tn, "10")
%        self.writedxf(tn, str(xbegin))
%        self.writedxf(tn, "20")
%        self.writedxf(tn, str(ybegin))
%        self.writedxf(tn, "10")
%        self.writedxf(tn, str(xend))
%        self.writedxf(tn, "20")
%        self.writedxf(tn, str(yend))
%
%\end{writecode}
%\addtocounter{gcpy}{18}
%
%\noindent while a new definition, with an optional color argument (defaulting to black) replaces it.

%Beginning with black, grey, blue, and red:
%
%\begin{center}
%\noindent\begin{tabular}{lllll}
%           & black & grey & blue & red \\
%\toprule
%           & 0            & 0           & \\
%           & LINE         & LINE        & \\
%           & 8            & 8           & \\
%           & Layer\_Black & Layer\_Grey & \\
%           & 62           & 62          & \\
%color code & 0            & 8           & \\
%           & 10           & 10          & \\
%xbegin     & 10.0         & 10.0        & \\
%           & 20           & 20          & \\
%ybegin     & 40.0         & 30.0        & \\
%           & 30           & 30          & \\
%           & 0.0          & 0.0         & \\
%           & 11           & 11          & \\
%xend       & 50.0         & 50.0        & \\
%           & 21           & 21          & \\
%yend       & 40.0         & 30.0        & \\
%           & 31           & 31          & \\
%           & 0.0          & 0.0         & \\\bottomrule
%\end{tabular}
%\end{center}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfline(self, tn, xbegin, ybegin, xend, yend):
        self.writedxf(tn, "0")
        self.writedxf(tn, "LINE")
#
        self.writedxfcolor(tn)
#
        self.writedxf(tn, "10")
        self.writedxf(tn, str(xbegin))
        self.writedxf(tn, "20")
        self.writedxf(tn, str(ybegin))
        self.writedxf(tn, "30")
        self.writedxf(tn, "0.0")
        self.writedxf(tn, "11")
        self.writedxf(tn, str(xend))
        self.writedxf(tn, "21")
        self.writedxf(tn, str(yend))
        self.writedxf(tn, "31")
        self.writedxf(tn, "0.0")

\end{writecode}
\addtocounter{gcpy}{19}

In addition to \verb|dxfline| which allows creating a line without consideration of context, there is also a \verb|dxfpolyline| which will create a continuous/joined sequence of line segments which requires beginning it, adding vertexes, and then when done, ending the sequence.

First, begin the polyline:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def beginpolyline(self, tn):#, xbegin, ybegin
        self.writedxf(tn, "0")
        self.writedxf(tn, "POLYLINE")
        self.writedxf(tn, "8")
        self.writedxf(tn, "default")
        self.writedxf(tn, "66")
        self.writedxf(tn, "1")
#
        self.writedxfcolor(tn)
#
#        self.writedxf(tn, "10")
#        self.writedxf(tn, str(xbegin))
#        self.writedxf(tn, "20")
#        self.writedxf(tn, str(ybegin))
#        self.writedxf(tn, "30")
#        self.writedxf(tn, "0.0")
        self.writedxf(tn, "70")
        self.writedxf(tn, "0")

\end{writecode}
\addtocounter{gcpy}{19}

\noindent then add as many vertexes as are wanted:

\begin{writecode}{a}{gcodepreview.py}{python}
    def addvertex(self, tn, xend, yend):
        self.writedxf(tn, "0")
        self.writedxf(tn, "VERTEX")
        self.writedxf(tn, "8")
        self.writedxf(tn, "default")
        self.writedxf(tn, "70")
        self.writedxf(tn, "32")
        self.writedxf(tn, "10")
        self.writedxf(tn, str(xend))
        self.writedxf(tn, "20")
        self.writedxf(tn, str(yend))
        self.writedxf(tn, "30")
        self.writedxf(tn, "0.0")

\end{writecode}
\addtocounter{gcpy}{14}

\noindent then end the sequence:

\begin{writecode}{a}{gcodepreview.py}{python}
    def closepolyline(self, tn):
        self.writedxf(tn, "0")
        self.writedxf(tn, "SEQEND")

\end{writecode}
\addtocounter{gcpy}{4}

For arcs, there are specific commands for writing out the \textsc{dxf} and G-code files. Note that for the G-code version it will be necessary to calculate the end-position, and to determine if the arc is clockwise or no (G2 vs. G3).

%\begin{center}
%\noindent\begin{tabular}{lllll}
%           & black & grey & blue & red \\
%\toprule
%& 0            & 0 \\
%& ARC          & ARC \\ 
%& 8            & 8 \\
%& Layer\_Black & Layer\_Grey\\
%& 62           & 62 \\
%color code & 0            & 8 \\
%& 10           & 10 \\
%& 50.0         & 50.0 \\
%& 20           & 20 \\
%& 50.0         & 50.0 \\
%& 30           & 30 \\
%& 0.0          & 0.0 \\
%& 40           & 40 \\
%& 270.0        & 180.0 \\
%& 50           & 50 \\
%& 360.0        & 270.0\\\bottomrule
%\end{tabular}
%\end{center}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfarc(self, tn, xcenter, ycenter, radius, anglebegin, endangle):
        if (self.generatedxf == True):
            self.writedxf(tn, "0")
            self.writedxf(tn, "ARC")
#
            self.writedxfcolor(tn)
#
            self.writedxf(tn, "10")
            self.writedxf(tn, str(xcenter))
            self.writedxf(tn, "20")
            self.writedxf(tn, str(ycenter))
            self.writedxf(tn, "40")
            self.writedxf(tn, str(radius))
            self.writedxf(tn, "50")
            self.writedxf(tn, str(anglebegin))
            self.writedxf(tn, "51")
            self.writedxf(tn, str(endangle))

    def gcodearc(self, tn, xcenter, ycenter, radius, anglebegin, endangle):
        if (self.generategcode == True):
            self.writegc(tn, "(0)")

\end{writecode}
\addtocounter{gcpy}{22}

The various textual versions are quite obvious, and due to the requirements of G-code, it is straight-forward to include the G-code in them if it is wanted.


\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutarcNECCdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 0, 90)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
#        if self.generatepaths == True:
#            print("Unioning cutarcNECCdxf toolpath")
        self.arcloop(1, 90, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
#        else:
#            toolpath = self.arcloop(1, 90, xcenter, ycenter, radius)
#            print("Returning cutarcNECCdxf toolpath")
        return toolpath

    def cutarcNWCCdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 90, 180)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
#        if self.generatepaths == True:
#            self.arcloop(91, 180, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
#        else:
        toolpath = self.arcloop(91, 180, xcenter, ycenter, radius)
        return toolpath

    def cutarcSWCCdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 180, 270)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.arcloop(181, 270, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.arcloop(181, 270, xcenter, ycenter, radius)
            return toolpath

    def cutarcSECCdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 270, 360)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.arcloop(271, 360, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.arcloop(271, 360, xcenter, ycenter, radius)
            return toolpath

    def cutarcNECWdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 0, 90)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.narcloop(89, 0, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.narcloop(89, 0, xcenter, ycenter, radius)
            return toolpath

    def cutarcSECWdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 270, 360)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.narcloop(359, 270, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.narcloop(359, 270, xcenter, ycenter, radius)
            return toolpath

    def cutarcSWCWdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 180, 270)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.narcloop(269, 180, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.narcloop(269, 180, xcenter, ycenter, radius)
            return toolpath

    def cutarcNWCWdxf(self, ex, ey, ez, xcenter, ycenter, radius):
#        global toolpath
#        toolpath = self.currenttool()
#        toolpath = toolpath.translate([self.xpos(), self.ypos(), self.zpos()])
        self.dxfarc(self.currenttoolnumber(), xcenter, ycenter, radius, 90, 180)
        if (self.zpos == ez):
            self.settzpos(0)
        else:         
            self.settzpos((self.zpos()-ez)/90)
#        self.setxpos(ex)
#        self.setypos(ey)
#        self.setzpos(ez)
        if self.generatepaths == True:
            self.narcloop(179, 90, xcenter, ycenter, radius)
#            self.toolpaths = self.toolpaths.union(toolpath)
        else:
            toolpath = self.narcloop(179, 90, xcenter, ycenter, radius)
            return toolpath

\end{writecode}
\addtocounter{gcpy}{154}

Using such commands to create a circle is quite straight-forward:

\begin{verbatim}
cutarcNECCdxf(-stockXwidth/4, stockYheight/4+stockYheight/16, -stockZthickness, -stockXwidth/4, stockYheight/4, stockYheight/16)
cutarcNWCCdxf(-(stockXwidth/4+stockYheight/16), stockYheight/4, -stockZthickness, -stockXwidth/4, stockYheight/4, stockYheight/16)
cutarcSWCCdxf(-stockXwidth/4, stockYheight/4-stockYheight/16, -stockZthickness, -stockXwidth/4, stockYheight/4, stockYheight/16)
cutarcSECCdxf(-(stockXwidth/4-stockYheight/16), stockYheight/4, -stockZthickness, -stockXwidth/4, stockYheight/4, stockYheight/16)
\end{verbatim}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def arcCCgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.writegc("G03 X", str(ex), " Y", str(ey), " Z", str(ez), " R", str(radius))
           
    def arcCWgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.writegc("G02 X", str(ex), " Y", str(ey), " Z", str(ez), " R", str(radius))
           
\end{writecode}
\addtocounter{gcpy}{6}

The above commands may be called if G-code is also wanted with writing out G-code added:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutarcNECCdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCCgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == True:
            self.cutarcNECCdxf(ex, ey, ez, xcenter, ycenter, radius)
        else:
            return self.cutarcNECCdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcNWCCdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCCgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcNWCCdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcSWCCdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCCgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcSWCCdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcSECCdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCCgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcSECCdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcNECWdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCWgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcNECWdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcSECWdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCWgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcSECWdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcSWCWdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCWgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcSWCWdxf(ex, ey, ez, xcenter, ycenter, radius)

    def cutarcNWCWdxfgc(self, ex, ey, ez, xcenter, ycenter, radius):
        self.arcCWgc(ex, ey, ez, xcenter, ycenter, radius)
        if self.generatepaths == False:
            return self.cutarcNWCWdxf(ex, ey, ez, xcenter, ycenter, radius)

\end{writecode}
\addtocounter{gcpy}{42}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module cutarcNECCdxfgc(ex, ey, ez, xcenter, ycenter, radius){
    gcp.cutarcNECCdxfgc(ex, ey, ez, xcenter, ycenter, radius);
}

module cutarcNWCCdxfgc(ex, ey, ez, xcenter, ycenter, radius){
    gcp.cutarcNWCCdxfgc(ex, ey, ez, xcenter, ycenter, radius);
}

module cutarcSWCCdxfgc(ex, ey, ez, xcenter, ycenter, radius){
    gcp.cutarcSWCCdxfgc(ex, ey, ez, xcenter, ycenter, radius);
}

module cutarcSECCdxfgc(ex, ey, ez, xcenter, ycenter, radius){
    gcp.cutarcSECCdxfgc(ex, ey, ez, xcenter, ycenter, radius);
}

\end{writecode}
\addtocounter{gcpscad}{16}

%Integrating G-code and \textsc{dxf} generation with everything else would be ideal, but will require ensuring that each command which moves the tool creates a matching command for both files.
%
%\lstset{firstnumber=\thegcpy}
%\begin{writecode}{a}{gcodepreview.py}{python}
%#def popengcodefile(fn):
%#    global f
%#    f = open(fn, "w")
%#
%#def popendxffile(fn):
%#    global dxf
%#    dxf = open(fn, "w")
%#
%#def popendxflgblfile(fn):
%#    global dxflgbl
%#    dxflgbl = open(fn, "w")
%#
%#def popendxflgsqfile(fn):
%#    global dxflgsq
%#    dxflgsq = open(fn, "w")
%#
%#def popendxflgVfile(fn):
%#    global dxflgV
%#    dxflgV = open(fn, "w")
%#
%#def popendxfsmblfile(fn):
%#    global dxfsmbl
%#    dxfsmbl = open(fn, "w")
%#
%#def popendxfsmsqfile(fn):
%#    global dxfsmsq
%#    dxfsmsq = open(fn, "w")
%#
%#def popendxfsmVfile(fn):
%#    global dxfsmV
%#    dxfsmV = open(fn, "w")
%#
%#def popendxfKHfile(fn):
%#    global dxfKH
%#    dxfKH = open(fn, "w")
%#
%#def popendxfDTfile(fn):
%#    global dxfDT
%#    dxfDT = open(fn, "w")
%#
%\end{writecode}
%\addtocounter{gcpy}{40}
%Separate OpenSCAD modules, 
%\DescribeRoutine{owritecomment}, 
%\DescribeRoutine{dxfwriteone}, 
%\DescribeRoutine{dxfwritelgbl}, 
%\DescribeRoutine{dxfwritelgsq}, 
%\DescribeRoutine{dxfwritelgV}, 
%\DescribeRoutine{dxfwritesmbl}, 
%\DescribeRoutine{dxfwritesmsq}, and
%\DescribeRoutine{dxfwritesmV} 
%will be used for either writing out comments in G-code (.nc/.gcode) files or adding to a DXF file --- for each different tool in a file there will be a matching module to write to it.



%Note that a hard-coded cylinder is used since the command will be used prior to a toolchange. In the future there may be a command for initializing the \DescribeVariable{toolpaths} so that later cut commands may add to it.


\subsubsection{G-code Overview}
 
The G-code commands and their matching modules may include (but are not limited to):

\bigskip

\noindent \begin{tabular}{@{}ll@{}} \toprule
 Command/Module                    & G-code                                        \\ \midrule
 \texttt{opengcodefile(s)(...);}
 \texttt{setupstock(...)}          & \texttt{(export.nc)}                          \\
                                   & \texttt{(stockMin: -109.5, -75mm, -8.35mm)}\\
                                   & \texttt{(stockMax:109.5mm, 75mm, 0.00mm)}\\
                                   & \texttt{(STOCK/BLOCK, 219, 150, 8.35, 109.5, 75, 8.35)}\\
                                   & \texttt{G90}\\
                                   & \texttt{G21} \\ \midrule
 \texttt{movetosafez()}            & \texttt{(Move to safe Z to avoid workholding)}\\
                                   & \texttt{G53G0Z-5.000}\\ \midrule
 \texttt{toolchange(...);}         & \texttt{(TOOL/MILL, 3.17, 0.00, 0.00, 0.00)} \\
                                   & \texttt{M6T102} \\
                                   & \texttt{M03S16000} \\ \midrule
 \verb|cutoneaxis_setfeed(...);|   & \texttt{(PREPOSITION FOR RAPID PLUNGE)}\\
  & \texttt{G0X0Y0} \\
  & \texttt{Z0.25} \\
  & \texttt{G1Z0F100} \\
  & \texttt{G1 X109.5 Y75 Z-8.35F400} \\
  & \texttt{Z9}\\
 \texttt{cutwithfeed(...);}\\ \midrule

 \texttt{closegcodefile();}        & \texttt{M05}\\
                                   & \texttt{M02}\\ 
\bottomrule
\end{tabular}
\bigskip

\noindent Conversely, the G-code commands which are supported are generated by the following modules:

\bigskip

\noindent \begin{tabular}{@{}ll@{}} \toprule
 G-code                                                           & Command/Module \\ \midrule
 \verb|(Design File: )| &  \texttt{opengcodefile(s)(...);}
                           \texttt{setupstock(...)}\\
 \verb|(stockMin:0.00mm, -152.40mm, -34.92mm)| \\
 \verb|(stockMax:109.50mm, -77.40mm, 0.00mm)| \\
 \verb|(STOCK/BLOCK, 109.50, 75.00, 34.92, 0.00, 152.40, 34.92)| \\
 \verb|G90| \\
 \verb|G21| \\ \midrule
 \verb|(Move to safe Z to avoid workholding)| &  \texttt{movetosafez()} \\
 \verb|G53G0Z-5.000| \\ \midrule
 \verb|(Toolpath: Contour Toolpath 1)| &  \texttt{toolchange(...);}\\
 \verb|M05| \\
 \verb|(TOOL/MILL, 3.17, 0.00, 0.00, 0.00)| \\
 \verb|M6T102| \\
 \verb|M03S10000|  \\ \midrule
 \verb|(PREPOSITION FOR RAPID PLUNGE)| & \texttt{writecomment(...)}\\ \midrule
 \verb|G0X0.000Y-152.400| & \texttt{rapid(...)}\\
 \verb|Z0.250| & \texttt{rapid(...)}\\ \midrule
 \verb|G1Z-1.000F203.2| & \texttt{cutwithfeed(...);}\\  
 \verb|X109.500Y-77.400F508.0| & \texttt{cutwithfeed(...);} \\ 
 \verb|X57.918Y16.302Z-0.726|\\ 
 \verb|Y22.023Z-1.023|\\ 
 \verb|X61.190Z-0.681|\\ 
 \verb|Y21.643|\\ 
 \verb|X57.681|\\
 \verb|Z12.700|\\ \midrule
 \verb|M05| &  \texttt{closegcodefile();}\\
 \verb|M02|\\
 \bottomrule
 \end{tabular}
\bigskip

The implication here is that it should be possible to read in a G-code file, and for each line/\allowbreak command instantiate a matching command so as to create a \textsc{3d} model/preview  of the file. This is addressed by making specialized commands for movement which correspond to the various axis combinations (\textsc{xyz}, \textsc{xy}, \textsc{xz}, \textsc{yz}, \textsc{x}, \textsc{y}, \textsc{z}).

A further consideration is that rather than hard-coding all possibilities or any changes, having an option for a "post-processor" will be far more flexible.

Described at: \url{https://carbide3d.com/hub/faq/create-pro-custom-post-processor/} the necessary hooks would be:

\begin{itemize}
\item onOpen
\item onClose
\item onSection (which is where tool changes are defined, since "section" in this case is segmented per tool)
\end{itemize}

\paragraph{Closings}

At the end of the program it will be necessary to close each file using the commands: 
\DescribeRoutine{closegcodefile}, and
\DescribeRoutine{closedxffile}. %\DescribeRoutine{pclosesvgfile}
In some instances it may be necessary to write additional information, depending on the file format. Note that these commands will need to be within the \verb|gcodepreview class|.
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfpostamble(self, tn):
#        self.writedxf(tn, str(tn))
        self.writedxf(tn, "0")
        self.writedxf(tn, "ENDSEC")
        self.writedxf(tn, "0")
        self.writedxf(tn, "EOF")
        
\end{writecode}
\addtocounter{gcpy}{7}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def gcodepostamble(self):
        if self.generatecut == True:
            self.writegc("Z12.700")
            self.writegc("M05")
            self.writegc("M02")
        if self.generateprint == True:
            self.writegc("G92 E0")
            self.writegc("M107    ; turn off cooling fans")
            self.writegc("M104 S0 ; turn off temperature")
            self.writegc("G28 X0  ; home X axis")
            self.writegc("M84     ; disable motors")

\end{writecode}
\addtocounter{gcpy}{12}

It will be necessary to call the \DescribeRoutine{dxfpostamble} (with appropriate checks and trappings so as to ensure that each \verb|dxf| file is ended and closed so as to be valid.
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def closegcodefile(self):
        if self.generategcode == True:
            self.gcodepostamble()
            self.gc.close()

    def closedxffile(self):
        if self.generatedxf == True:
#            global dxfclosed
            self.dxfpostamble(-1)
#            self.dxfclosed = True
            self.dxf.close()
    
    def closedxffiles(self):
        if self.generatedxfs == True:
            if (self.large_square_tool_num > 0):
                self.dxfpostamble(self.large_square_tool_num)
            if (self.small_square_tool_num > 0):
                self.dxfpostamble(self.small_square_tool_num)
            if (self.large_ball_tool_num > 0):
                self.dxfpostamble(self.large_ball_tool_num)
            if (self.small_ball_tool_num > 0):
                self.dxfpostamble(self.small_ball_tool_num)
            if (self.large_V_tool_num > 0):
                self.dxfpostamble(self.large_V_tool_num)
            if (self.small_V_tool_num > 0):
                self.dxfpostamble(self.small_V_tool_num)
            if (self.DT_tool_num > 0):
                self.dxfpostamble(self.DT_tool_num)
            if (self.KH_tool_num > 0):
                self.dxfpostamble(self.KH_tool_num)
            if (self.Roundover_tool_num > 0):
                self.dxfpostamble(self.Roundover_tool_num)
            if (self.MISC_tool_num > 0):
                self.dxfpostamble(self.MISC_tool_num)
                
            if (self.large_square_tool_num > 0):
                self.dxflgsq.close()
            if (self.small_square_tool_num > 0):
                self.dxfsmsq.close()
            if (self.large_ball_tool_num > 0):
                self.dxflgbl.close()
            if (self.small_ball_tool_num > 0):
                self.dxfsmbl.close()
            if (self.large_V_tool_num > 0):
                self.dxflgV.close()
            if (self.small_V_tool_num > 0):
                self.dxfsmV.close()
            if (self.DT_tool_num > 0):
                self.dxfDT.close()
            if (self.KH_tool_num > 0):
                self.dxfKH.close()
            if (self.Roundover_tool_num > 0):
                self.dxfRt.close()
            if (self.MISC_tool_num > 0):
                self.dxfMt.close()

\end{writecode}
\addtocounter{gcpy}{56}
%def pclosesvgfile():
%    svg.close()
%

The commands: \DescribeRoutine{closegcodefile}, and \DescribeRoutine{closedxffile} are used to close the files at the end of a program. For efficiency, each references the command: \DescribeRoutine{dxfpostamble} which when called provides the boilerplate needed at the end of their respective files.

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module closegcodefile(){
    gcp.closegcodefile();
}

module closedxffiles(){
    gcp.closedxffiles();
}

module closedxffile(){
    gcp.closedxffile();
}

\end{writecode}
\addtocounter{gcpscad}{12}


\subsection{Cutting shapes and expansion}

Certain basic shapes (arcs, circles, rectangles), will be incorporated in the main code. Other shapes will be added as they are developed, and of course the user is free to develop their own systems.

%to the additional/optional file, \texttt{cut2Dshapes.scad} 
 
It is most expedient to test out new features in a new/separate file insofar as the file structures will allow (tool definitions for example will need to consolidated in \ref{subsubsec:toolchange}) which will need to be included in the projects which will make use of said features until such time as they are added into the main \texttt{gcodepreview.scad} file.

A basic requirement for two-dimensional regions will be to define them so as to cut them out. Two different geometric treatments will be necessary: modeling the geometry which defines the region to be cut out (output as a \textsc{dxf}); and modeling the movement of the tool, the toolpath which will be used in creating the \textsc{3d} model and outputting the G-code.

\subsubsection{Building blocks}

The outlines of shapes will be defined using:

\begin{itemize}
\item lines --- \verb|dxfline|
\item arcs --- \verb|dxfarc|
\end{itemize}

It may be that splines or Bézier curves will be added as well.

\paragraph{List of shapes}

In the TUG presentation/paper: \url{http://tug.org/TUGboat/tb40-2/tb125adams-3d.pdf} a list of \textsc{2d} shapes was put forward --- which of these will need to be created, or if some more general solution will be put forward is uncertain. For the time being, shapes will be implemented on an as-needed basis, as modified by the interaction with the requirements of toolpaths. Shapes for which code exists (or is trivially coded) are indicated by \textcolor{ForestGreen}{Forest Green} --- for those which have sub-classes, if all are feasible only the higher level is so called out.

%\begin{figure}
\begin{outline}
\1 0
   \2 \textcolor{ForestGreen}{circle} --- \verb|dxfcircle|
   \2 ellipse (oval) (requires some sort of non-arc curve)
      \3 egg-shaped
   \2 \textcolor{ForestGreen}{annulus} (one circle within another, forming  a ring) --- handled by nested circles
   \2 superellipse (see astroid below)
\1 1
   \2 \textcolor{ForestGreen}{cone with rounded end (arc)}---see also ``sector'' under 3 below
\1 2
   \2 \textcolor{ForestGreen}{semicircle/circular/half-circle segment} (arc and a straight line); see also sector below
   \2 arch---curve possibly smoothly joining a  pair of straight lines with a flat bottom
   \2 lens/vesica piscis (two convex curves)
   \2 lune/crescent (one convex, one concave  curve)
   \2 heart (two curves)
   \2 tomoe (comma shape)---non-arc curves
\1 3
   \2 \textcolor{ForestGreen}{triangle}
      \3 equilateral
      \3 isosceles
      \3 right triangle
      \3 scalene
   \2 \textcolor{ForestGreen}{(circular) sector} (two straight edges, one convex arc)
      \3 quadrant (90\textdegree)
      \3 sextants (60\textdegree)
      \3 octants (45\textdegree)
   \2 deltoid curve (three concave arcs)
   \2  Reuleaux triangle (three convex arcs)
   \2 arbelos (one convex, two concave arcs)
   \2 two straight edges, one concave arc---an example is the hyperbolic sector\footnote{\url{en.wikipedia.org/wiki/Hyperbolic_sector} and
 \url{www.reddit.com/r/Geometry/comments/bkbzgh/is_there_a_name_for_a_3_pointed_figure_with_two}}
   \2 two convex, one concave arc
\1 4
   \2 \textcolor{ForestGreen}{rectangle (including square)} --- \verb|dxfrectangle|, \verb|dxfrectangleround|
                                       %\hyperref[routine:cutrectangledxf]{cutrectangledxf}, 
                                       %\hyperref[routine:cutoutrectangledxf]{cutoutrectangledxf}, 
                                       %\hyperref[routine:rectangleoutlinedxf]{rectangleoutlinedxf} 
   \2 \textcolor{ForestGreen}{parallelogram}
   \2 \textcolor{ForestGreen}{rhombus}
   \2 \textcolor{ForestGreen}{trapezoid/trapezium}
   \2 \textcolor{ForestGreen}{kite}
   \2 ring/annulus segment (straight line, concave arc, straight line, convex arc)
   \2 astroid (four concave arcs)
   \2 \textcolor{ForestGreen}{salinon} (four semicircles)
   \2 three straight lines and one concave arc
\end{outline}

Note that most shapes will also exist in a rounded form where sharp angles/points are replaced by arcs/portions of circles, with the most typical being \verb|dxfrectangleround|.

Is the list of shapes for which there are not widely known names interesting for its lack of notoriety?

\begin{itemize}
 \item two straight edges, one concave arc---oddly, an asymmetric form (hyperbolic sector) has a name, 
       but not the symmetrical---while the colloquial/prosaic ``arrowhead'' was considered, it was
       rejected as being better applied to the shape below. (It's also the shape used for the
       spaceship in the game Asteroids (or Hyperspace), but that  is potentially confusing with
       astroid.) At the  conference, Dr. Knuth suggested ``dart'' as a suitable term.
 \item two convex, one concave arc---with the above named, the term ``arrowhead'' is freed up to use
       as the name for this shape.
 \item three straight lines and one concave arc.
 \end{itemize}

 The first in particular is sorely needed for this project (it's the result of inscribing a circle in a square or other regular geometric shape). Do these shapes have names in any other languages which might be used instead?
%\end{figure}

These shapes will then be used in constructing toolpaths. The program Carbide Create has toolpath types and options which are as follows:

\begin{itemize}
 \item Contour --- No Offset --- the default, this is already supported in the existing code
 \item Contour --- Outside Offset
 \item Contour --- Inside Offset
 \item Pocket --- such toolpaths/geometry should include the rounding of the tool 
       at the corners, c.f., \verb|dxfrectangleround|
 \item Drill --- note that this is implemented as the plunging of a tool centered on a circle
                 and normally that circle is the same diameter as the tool which is used.
 \item Keyhole --- also beginning from a circle, the command for this also models the areas which
                   should be cleared for the sake of reducing wear
                   on the tool and ensuring chip clearance
\end{itemize}

 
Some further considerations:

\begin{itemize}
 \item relationship of geometry to toolpath --- arguably there should be an option for each
       toolpath (we will use Carbide Create as a reference implementation) which is to be 
       supported. Note that there are several possibilities: modeling the tool movement, 
       describing the outline which the tool will cut, modeling a reference shape for the toolpath
 \item tool geometry --- support is included for specialty tooling 
       such as dovetail cutters allowing one to to get an accurate \textsc{3d} model, including for tooling which
       undercuts since they cannot be modeled in Carbide Create.
% \item feeds and speeds --- if outputting G-code it would be nice to be able to import feeds 
%       and speeds from external files such as the .csv files used for user tool libraries in
%       Carbide Create
 \item Starting and Max Depth --- are there \textsc{cad} programs which will make use of Z-axis information 
       in a \textsc{dxf}? --- would it be possible/necessary to further differentiate the \textsc{dxf} geometry?
       (currently  written out separately for each toolpath in addition to one combined file) --- would supporting layers be an option?
\end{itemize}

\subparagraph{circles}

Circles are made up of a series of arcs:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfcircle(self, tool_num, xcenter, ycenter, radius):
        self.dxfarc(tool_num, xcenter, ycenter, radius,  0, 90)
        self.dxfarc(tool_num, xcenter, ycenter, radius, 90, 180)
        self.dxfarc(tool_num, xcenter, ycenter, radius, 180, 270)
        self.dxfarc(tool_num, xcenter, ycenter, radius, 270, 360)

\end{writecode}
\addtocounter{gcpy}{6}

Actually cutting the circle is much the same, with the added consideration of entry point if Z height is not above the surface of the stock/already removed material, directionality (counter-clockwise vs. clockwise), and depth (beginning and end depths must be specified which should allow usage of this for thread-cutting and similar purposes).

Center is specified, but the actual entry point is the right-most edge.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutcircleCC(self, xcenter, ycenter, bz, ez, radius):
        self.setzpos(bz)
        self.cutquarterCCNE(xcenter, ycenter + radius, self.zpos() + ez/4, radius) 
        self.cutquarterCCNW(xcenter - radius, ycenter, self.zpos() + ez/4, radius) 
        self.cutquarterCCSW(xcenter, ycenter - radius, self.zpos() + ez/4, radius) 
        self.cutquarterCCSE(xcenter + radius, ycenter, self.zpos() + ez/4, radius) 

    def cutcircleCCdxf(self, xcenter, ycenter, bz, ez, radius):
        self.cutcircleCC(self, xcenter, ycenter, bz, ez, radius)
        self.dxfcircle(self, tool_num, xcenter, ycenter, radius)

\end{writecode}
\addtocounter{gcpy}{11}

A Drill toolpath is a simple plunge operation which will have a matching circle to define it.

\subparagraph{rectangles}

There are two obvious forms for rectangles, square cornered and rounded:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfrectangle(self, tool_num, xorigin, yorigin, xwidth, yheight, corners = "Square", radius = 6):
        if corners == "Square":
            self.dxfline(tool_num, xorigin, yorigin, xorigin + xwidth, yorigin)
            self.dxfline(tool_num, xorigin + xwidth, yorigin, xorigin + xwidth, yorigin + yheight)
            self.dxfline(tool_num, xorigin + xwidth, yorigin + yheight, xorigin, yorigin + yheight)
            self.dxfline(tool_num, xorigin, yorigin + yheight, xorigin, yorigin)
        elif corners == "Fillet":
            self.dxfrectangleround(tool_num, xorigin, yorigin, xwidth, yheight, radius)
        elif corners == "Chamfer":
            self.dxfrectanglechamfer(tool_num, xorigin, yorigin, xwidth, yheight, radius)
        elif corners == "Flipped Fillet":
            self.dxfrectangleflippedfillet(tool_num, xorigin, yorigin, xwidth, yheight, radius)

\end{writecode}
\addtocounter{gcpy}{13}

Note that the rounded shape below would be described as a rectangle with the ``Fillet'' corner treatment in Carbide Create.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfrectangleround(self, tool_num, xorigin, yorigin, xwidth, yheight, radius):
# begin section
        self.writedxf(tool_num, "0")
        self.writedxf(tool_num, "SECTION")
        self.writedxf(tool_num, "2")
        self.writedxf(tool_num, "ENTITIES")
        self.writedxf(tool_num, "0")
        self.writedxf(tool_num, "LWPOLYLINE")
        self.writedxf(tool_num, "5")
        self.writedxf(tool_num, "4E")
        self.writedxf(tool_num, "100")
        self.writedxf(tool_num, "AcDbEntity")
        self.writedxf(tool_num, "8")
        self.writedxf(tool_num, "0")
        self.writedxf(tool_num, "6")
        self.writedxf(tool_num, "ByLayer")
#
        self.writedxfcolor(tool_num)
#
        self.writedxf(tool_num, "370")
        self.writedxf(tool_num, "-1")
        self.writedxf(tool_num, "100")
        self.writedxf(tool_num, "AcDbPolyline")
        self.writedxf(tool_num, "90")
        self.writedxf(tool_num, "8")
        self.writedxf(tool_num, "70")
        self.writedxf(tool_num, "1")
        self.writedxf(tool_num, "43")
        self.writedxf(tool_num, "0")
#1 upper right corner before arc (counter-clockwise)
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + xwidth))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + yheight - radius))
        self.writedxf(tool_num, "42")
        self.writedxf(tool_num, "0.414213562373095")
#2 upper right corner after arc
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + xwidth - radius))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + yheight))
#3 upper left corner before arc (counter-clockwise)
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + radius))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + yheight))
        self.writedxf(tool_num, "42")
        self.writedxf(tool_num, "0.414213562373095")
#4 upper left corner after arc
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + yheight - radius))
#5 lower left corner before arc (counter-clockwise)
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + radius))
        self.writedxf(tool_num, "42")
        self.writedxf(tool_num, "0.414213562373095")
#6 lower left corner after arc
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + radius))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin))
#7 lower right corner before arc (counter-clockwise)
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + xwidth - radius))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin))
        self.writedxf(tool_num, "42")
        self.writedxf(tool_num, "0.414213562373095")
#8 lower right corner after arc
        self.writedxf(tool_num, "10")
        self.writedxf(tool_num, str(xorigin + xwidth))
        self.writedxf(tool_num, "20")
        self.writedxf(tool_num, str(yorigin + radius))
# end current section
        self.writedxf(tool_num, "0")
        self.writedxf(tool_num, "SEQEND")

\end{writecode}
\addtocounter{gcpy}{81}

%    def dxfrectangleroundLINESandARCS(self, tool_num, xorigin, yorigin, xwidth, yheight, radius):
%        self.dxfline(tool_num,  xorigin + xwidth, yorigin + radius, xorigin + xwidth, yorigin + yheight - radius)
%        self.dxfarc(tool_num, xorigin + xwidth - radius, yorigin + yheight - radius, radius,  0, 90)
%        self.dxfline(tool_num,  xorigin + xwidth - radius, yorigin + yheight, xorigin + radius, yorigin + yheight)
%        self.dxfarc(tool_num, xorigin + radius, yorigin + yheight - radius, radius, 90, 180)
%        self.dxfline(tool_num,  xorigin, yorigin + yheight - radius, xorigin, yorigin + radius)
%        self.dxfarc(tool_num, xorigin + radius, yorigin + radius, radius, 180, 270)
%        self.dxfline(tool_num,  xorigin + radius, yorigin, xorigin + xwidth - radius, yorigin)
%        self.dxfarc(tool_num, xorigin + xwidth - radius, yorigin + radius, radius, 270, 360)

\noindent So we add the balance of the corner treatments which are decorative (and easily implemented). 

Chamfer:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfrectanglechamfer(self, tool_num, xorigin, yorigin, xwidth, yheight, radius):
        self.dxfline(tool_num, xorigin + radius, yorigin, xorigin, yorigin + radius)
        self.dxfline(tool_num, xorigin, yorigin + yheight - radius, xorigin + radius, yorigin + yheight)
        self.dxfline(tool_num, xorigin + xwidth - radius, yorigin + yheight, xorigin + xwidth, yorigin + yheight - radius)
        self.dxfline(tool_num, xorigin + xwidth - radius, yorigin, xorigin + xwidth, yorigin + radius)

        self.dxfline(tool_num, xorigin + radius, yorigin, xorigin + xwidth - radius, yorigin)
        self.dxfline(tool_num, xorigin + xwidth, yorigin + radius, xorigin + xwidth, yorigin + yheight - radius)
        self.dxfline(tool_num, xorigin + xwidth - radius, yorigin + yheight, xorigin + radius, yorigin + yheight)
        self.dxfline(tool_num, xorigin, yorigin + yheight - radius, xorigin, yorigin + radius)

\end{writecode}
\addtocounter{gcpy}{11}

Flipped Fillet:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfrectangleflippedfillet(self, tool_num, xorigin, yorigin, xwidth, yheight, radius):
        self.dxfarc(tool_num, xorigin, yorigin, radius,  0, 90)
        self.dxfarc(tool_num, xorigin + xwidth, yorigin, radius, 90, 180)
        self.dxfarc(tool_num, xorigin + xwidth, yorigin + yheight, radius, 180, 270)
        self.dxfarc(tool_num, xorigin, yorigin + yheight, radius, 270, 360)

        self.dxfline(tool_num, xorigin + radius, yorigin, xorigin + xwidth - radius, yorigin)
        self.dxfline(tool_num, xorigin + xwidth, yorigin + radius, xorigin + xwidth, yorigin + yheight - radius)
        self.dxfline(tool_num, xorigin + xwidth - radius, yorigin + yheight, xorigin + radius, yorigin + yheight)
        self.dxfline(tool_num, xorigin, yorigin + yheight - radius, xorigin, yorigin + radius)

\end{writecode}
\addtocounter{gcpy}{11}

Cutting rectangles while writing out their perimeter in the DXF files (so that they may be assigned a matching toolpath in a traditional CAM program upon import) will require the origin coordinates, height and width and depth of the pocket, and the tool \# so that the corners may have a radius equal to the tool which is used. Whether a given module is an interior pocket or an outline (interior or exterior) will be determined by the specifics of the module and its usage/positioning, with \texttt{outline} being added to those modules which cut perimeter.

A further consideration is that cut orientation as an option should be accounted for if writing out G-code, as well as stepover, and the nature of initial entry (whether ramping in would be implemented, and if so, at what angle). Advanced toolpath strategies such as trochoidal milling could also be implemented.

The routine \DescribeRoutine{cutrectangle} cuts the outline of a rectangle creating rounded corners.

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutrectangle(self, tool_num, bx, by, bz, xwidth, yheight, zdepth):
        self.cutline(bx, by, bz)
        self.cutline(bx, by, bz - zdepth)
        self.cutline(bx + xwidth, by, bz - zdepth)
        self.cutline(bx + xwidth, by + yheight, bz - zdepth)
        self.cutline(bx, by + yheight, bz - zdepth)
        self.cutline(bx, by, bz - zdepth)

    def cutrectangledxf(self, tool_num, bx, by, bz, xwidth, yheight, zdepth):
        self.cutrectangle(tool_num, bx, by, bz, xwidth, yheight, zdepth)
        self.dxfrectangle(tool_num, bx, by, xwidth, yheight, "Square")

\end{writecode}
\addtocounter{gcpy}{12}

The rounded forms instantiate a radius:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutrectangleround(self, tool_num, bx, by, bz, xwidth, yheight, zdepth, radius):
#        self.rapid(bx + radius, by, bz)
        self.cutline(bx + radius, by, bz + zdepth)
        self.cutline(bx + xwidth - radius, by, bz + zdepth)
        self.cutquarterCCSE(bx + xwidth, by + radius, bz + zdepth, radius) 
        self.cutline(bx + xwidth, by + yheight - radius, bz + zdepth)
        self.cutquarterCCNE(bx + xwidth - radius, by + yheight, bz + zdepth, radius) 
        self.cutline(bx + radius, by + yheight, bz + zdepth)
        self.cutquarterCCNW(bx, by + yheight - radius, bz + zdepth, radius) 
        self.cutline(bx, by + radius, bz + zdepth)
        self.cutquarterCCSW(bx + radius, by, bz + zdepth, radius) 

    def cutrectanglerounddxf(self, tool_num, bx, by, bz, xwidth, yheight, zdepth, radius):
        self.cutrectangleround(tool_num, bx, by, bz, xwidth, yheight, zdepth, radius)
        self.dxfrectangleround(tool_num, bx, by, xwidth, yheight, radius)

\end{writecode}
\addtocounter{gcpy}{16}

% 
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module cutrectangledxf(bx, by, bz, rwidth, rheight, rdepth, rtn) {//passes
%  movetosafez();
%  hull(){
%    //  for (i = [0 : abs(1) : passes]) {
%    //      rapid(bx+tool_radius(rtn)+i*(rwidth-tool_diameter(current_tool()))/passes, bx+tool_radius(rtn), 1);
%    //      cutwithfeed(bx+tool_radius(rtn)+i*(rwidth-tool_diameter(current_tool()))/passes, by+tool_radius(rtn), bz-rdepth, feed);
%    //      cutwithfeed(bx+tool_radius(rtn)+i*(rwidth-tool_diameter(current_tool()))/passes, by+rheight-tool_radius(rtn), bz-rdepth, feed);
%  
%    cutwithfeed(bx+tool_radius(rtn), by+tool_radius(rtn), bz-rdepth, feed);
%    cutwithfeed(bx+rwidth-tool_radius(rtn), by+tool_radius(rtn), bz-rdepth, feed);
%    cutwithfeed(bx+rwidth-tool_radius(rtn), by+rheight-tool_radius(rtn), bz-rdepth, feed);
%    cutwithfeed(bx+tool_radius(rtn), by+rheight-tool_radius(rtn), bz-rdepth, feed);
%  }
%  //dxfarc(xcenter, ycenter, radius, anglebegin, endangle, tn)
%  dxfarc(bx+tool_radius(rtn), by+tool_radius(rtn), tool_radius(rtn), 180, 270, rtn);
%  //dxfline(xbegin, ybegin, xend, yend, tn)
%  dxfline(bx, by+tool_radius(rtn), bx, by+rheight-tool_radius(rtn), rtn);
%  dxfarc(bx+tool_radius(rtn), by+rheight-tool_radius(rtn), tool_radius(rtn), 90, 180, rtn);
%  dxfline(bx+tool_radius(rtn), by+rheight, bx+rwidth-tool_radius(rtn), by+rheight, rtn);
%  dxfarc(bx+rwidth-tool_radius(rtn), by+rheight-tool_radius(rtn), tool_radius(rtn), 0, 90, rtn);
%  dxfline(bx+rwidth, by+rheight-tool_radius(rtn), bx+rwidth, by+tool_radius(rtn), rtn);
%  dxfarc(bx+rwidth-tool_radius(rtn), by+tool_radius(rtn), tool_radius(rtn), 270, 360, rtn);
%  dxfline(bx+rwidth-tool_radius(rtn), by, bx+tool_radius(rtn), by, rtn);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{25}
%
%A matching command: \DescribeRoutine{cutrectangleoutlinedxf} cuts the outline of a rounded rectangle and is a simplification of the above:
%
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module cutrectangleoutlinedxf(bx, by, bz, rwidth, rheight, rdepth, rtn) {//passes
%  movetosafez();
%  cutwithfeed(bx+tool_radius(rtn), by+tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx+rwidth-tool_radius(rtn), by+tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx+rwidth-tool_radius(rtn), by+rheight-tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx+tool_radius(rtn), by+rheight-tool_radius(rtn), bz-rdepth, feed);
%  dxfarc(bx+tool_radius(rtn), by+tool_radius(rtn), tool_radius(rtn), 180, 270, rtn);
%  dxfline(bx, by+tool_radius(rtn), bx, by+rheight-tool_radius(rtn), rtn);
%  dxfarc(bx+tool_radius(rtn), by+rheight-tool_radius(rtn), tool_radius(rtn), 90, 180, rtn);
%  dxfline(bx+tool_radius(rtn), by+rheight, bx+rwidth-tool_radius(rtn), by+rheight, rtn);
%  dxfarc(bx+rwidth-tool_radius(rtn), by+rheight-tool_radius(rtn), tool_radius(rtn), 0, 90, rtn);
%  dxfline(bx+rwidth, by+rheight-tool_radius(rtn), bx+rwidth, by+tool_radius(rtn), rtn);
%  dxfarc(bx+rwidth-tool_radius(rtn), by+tool_radius(rtn), tool_radius(rtn), 270, 360, rtn);
%  dxfline(bx+rwidth-tool_radius(rtn), by, bx+tool_radius(rtn), by, rtn);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{16}
%
%Which suggests a further command, \DescribeRoutine{rectangleoutlinedxf} for simply adding a rectangle (a potential use of which would be in Job Setup to add the stock outline to \textsc{dxf}s to assist in registration of jobs with multiple tools):
%
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module rectangleoutlinedxf(bx, by, bz, rwidth, rheight, rtn) {
%  dxfline(bx, by, bx, by+rheight, rtn);
%  dxfline(bx, by+rheight, bx+rwidth, by+rheight, rtn);
%  dxfline(bx+rwidth, by+rheight, bx+rwidth, by, rtn);
%  dxfline(bx+rwidth, by, bx, by, rtn);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{7}
%
%\noindent the initial section performs the cutting operation for the 3D preview while the latter section writes out the outline to the DXF files.
%
%A variant of the  cutting version of that file, \DescribeRoutine{cutoutrectangledxf} will cut to the outside:
%
%\lstset{firstnumber=\thegcpscad}
%\begin{writecode}{a}{gcodepreview.scad}{scad}
%module cutoutrectangledxf(bx, by, bz, rwidth, rheight, rdepth, rtn) {
%  movetosafez();
%  cutwithfeed(bx-tool_radius(rtn), by-tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx+rwidth+tool_radius(rtn), by-tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx+rwidth+tool_radius(rtn), by+rheight+tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx-tool_radius(rtn), by+rheight+tool_radius(rtn), bz-rdepth, feed);
%  cutwithfeed(bx-tool_radius(rtn), by-tool_radius(rtn), bz-rdepth, feed);
%  dxfline(bx, by, bx, by+rheight, rtn);
%  dxfline(bx, by+rheight, bx+rwidth, by+rheight, rtn);
%  dxfline(bx+rwidth, by+rheight, bx+rwidth, by, rtn);
%  dxfline(bx+rwidth, by, bx, by, rtn);
%}
%
%\end{writecode}
%\addtocounter{gcpscad}{13}
%\end{verbatim}

\subparagraph{Keyhole toolpath and undercut tooling}
 
\label{subsec:keyholetoolpaths}
The first topologically unusual toolpath is \DescribeRoutine{cutkeyhole toolpath} --- where other toolpaths have a direct correspondence between the associated geometry and the area cut, that Keyhole toolpaths may be used with tooling which undercuts and which will result in the creation of two different physical physical regions: the visible surface matching the union of the tool perimeter at the entry point and the linear movement of the shaft and the larger region of the tool perimeter at the depth which the tool is plunged to and moved along.
 
Tooling for such toolpaths is defined at paragraph~\ref{para:undercuttooling}

The interface which is being modeled is that of Carbide Create:

\bigskip

\begin{centering}
\includegraphics[width=\linewidth/2]{C:/Users/willa/OneDrive/Documents/GitHub/gcodepreview/images/cc8_dialog_toolpath_keyhole.png}\par
\end{centering}

\bigskip

\noindent Hence the parameters:

\begin{itemize}
\item Starting Depth == \verb|kh_start_depth|
\item Max Depth == \verb|kh_max_depth|
\item Angle == \verb|kht_direction|
\item Length == \verb|kh_distance|
\item Tool == \verb|kh_tool_num|
\end{itemize}

Due to the possibility of rotation, for the in-between positions there are more cases than one would think --- for each quadrant there are the following possibilities:

\begin{itemize}
 \item one node on the clockwise side is outside of the quadrant
 \item two nodes on the clockwise side are outside of the quadrant
 \item all nodes are w/in the quadrant
 \item one node on the counter-clockwise side is outside of the quadrant
 \item two nodes on the counter-clockwise side are outside of the quadrant
\end{itemize}
 
Supporting all of these would require trigonometric comparisons in the \verb|if...else| blocks, so only the 4 quadrants, N, S, E, and W will be supported in the initial version. This will be done by wrapping the command with a version which only accepts those options: 

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutkeyholegcdxf(self, kh_tool_num, kh_start_depth, kh_max_depth, kht_direction, kh_distance):   
        if (kht_direction == "N"): 
            toolpath = self.cutKHgcdxf(kh_tool_num, kh_start_depth, kh_max_depth, 90, kh_distance)
        elif (kht_direction == "S"):
            toolpath = self.cutKHgcdxf(kh_tool_num, kh_start_depth, kh_max_depth, 270, kh_distance)
        elif (kht_direction == "E"):
            toolpath = self.cutKHgcdxf(kh_tool_num, kh_start_depth, kh_max_depth, 0, kh_distance)
        elif (kht_direction == "W"):
            toolpath = self.cutKHgcdxf(kh_tool_num, kh_start_depth, kh_max_depth, 180, kh_distance)
#        if self.generatepaths == True:
#            self.toolpaths = union([self.toolpaths, toolpath])
        return toolpath
#        else:
#            return cube([0.01, 0.01, 0.01])

\end{writecode}
\addtocounter{gcpy}{15}

\lstset{firstnumber=\thegcpscad}
\begin{writecode}{a}{gcodepreview.scad}{scad}
module cutkeyholegcdxf(kh_tool_num, kh_start_depth, kh_max_depth, kht_direction, kh_distance){
    gcp.cutkeyholegcdxf(kh_tool_num, kh_start_depth, kh_max_depth, kht_direction, kh_distance);
}

\end{writecode}
\addtocounter{gcpscad}{4}

The original version of the command, \DescribeRoutine{cutKHgcdxf} retains an interface which allows calling it for arbitrary beginning and ending points of an arc. 

Note that code is still present for the partial calculation of one quadrant (for the case of all nodes within the quadrant). The first task is to place a circle at the origin which is invariant of angle:
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cutKHgcdxf(self, kh_tool_num, kh_start_depth, kh_max_depth, kh_angle, kh_distance):
        oXpos = self.xpos()
        oYpos = self.ypos()
        self.dxfKH(kh_tool_num, self.xpos(), self.ypos(), kh_start_depth, kh_max_depth, kh_angle, kh_distance)
        toolpath = self.cutline(self.xpos(), self.ypos(), -kh_max_depth)
        self.setxpos(oXpos)
        self.setypos(oYpos)
#        if self.generatepaths == False:
        return toolpath
#        else: 
#            return cube([0.001, 0.001, 0.001])

\end{writecode}
\addtocounter{gcpy}{12}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def dxfKH(self, kh_tool_num, oXpos, oYpos, kh_start_depth, kh_max_depth, kh_angle, kh_distance):
#        oXpos = self.xpos()
#        oYpos = self.ypos()
#Circle at entry hole
        self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 7), 0, 90)
        self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 7), 90, 180)
        self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 7), 180, 270)
        self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 7), 270, 360)
\end{writecode}
\addtocounter{gcpy}{8}

Then it will be necessary to test for each possible case in a series of If Else blocks:
 
\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
#pre-calculate needed values
        r = self.tool_radius(kh_tool_num, 7)
#        print(r)
        rt = self.tool_radius(kh_tool_num, 1)
#        print(rt)
        ro = math.sqrt((self.tool_radius(kh_tool_num, 1))**2-(self.tool_radius(kh_tool_num, 7))**2)
#        print(ro)
        angle = math.degrees(math.acos(ro/rt))
#Outlines of entry hole and slot
        if (kh_angle == 0):
#Lower left of entry hole
            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), self.tool_radius(kh_tool_num, 1), 180, 270)
#Upper left of entry hole
            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), self.tool_radius(kh_tool_num, 1), 90, 180)
#Upper right of entry hole
#            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), rt, 41.810, 90)
            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), rt, angle, 90)
#Lower right of entry hole
            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), rt, 270, 360-angle)
#            self.dxfarc(kh_tool_num, self.xpos(), self.ypos(), self.tool_radius(kh_tool_num, 1), 270, 270+math.acos(self.tool_diameter(kh_tool_num, 5)/self.tool_diameter(kh_tool_num, 1)))
#Actual line of cut
#            self.dxfline(kh_tool_num, self.xpos(), self.ypos(), self.xpos()+kh_distance, self.ypos())
#upper right of end of slot (kh_max_depth+4.36))/2
            self.dxfarc(kh_tool_num, self.xpos()+kh_distance, self.ypos(), self.tool_diameter(kh_tool_num, (kh_max_depth+4.36))/2, 0, 90)
#lower right of end of slot
            self.dxfarc(kh_tool_num, self.xpos()+kh_distance, self.ypos(), self.tool_diameter(kh_tool_num, (kh_max_depth+4.36))/2, 270, 360)
#upper right slot
            self.dxfline(kh_tool_num, self.xpos()+ro, self.ypos()-(self.tool_diameter(kh_tool_num, 7)/2), self.xpos()+kh_distance, self.ypos()-(self.tool_diameter(kh_tool_num, 7)/2))
#            self.dxfline(kh_tool_num, self.xpos()+(math.sqrt((self.tool_diameter(kh_tool_num, 1)^2)-(self.tool_diameter(kh_tool_num, 5)^2))/2), self.ypos()+self.tool_diameter(kh_tool_num, (kh_max_depth))/2, ( (kh_max_depth-6.34))/2)^2-(self.tool_diameter(kh_tool_num, (kh_max_depth-6.34))/2)^2, self.xpos()+kh_distance, self.ypos()+self.tool_diameter(kh_tool_num, (kh_max_depth))/2, kh_tool_num)
#end position at top of slot
#lower right slot
            self.dxfline(kh_tool_num, self.xpos()+ro, self.ypos()+(self.tool_diameter(kh_tool_num, 7)/2), self.xpos()+kh_distance, self.ypos()+(self.tool_diameter(kh_tool_num, 7)/2))
#        dxfline(kh_tool_num, self.xpos()+(math.sqrt((self.tool_diameter(kh_tool_num, 1)^2)-(self.tool_diameter(kh_tool_num, 5)^2))/2), self.ypos()-self.tool_diameter(kh_tool_num, (kh_max_depth))/2, ( (kh_max_depth-6.34))/2)^2-(self.tool_diameter(kh_tool_num, (kh_max_depth-6.34))/2)^2, self.xpos()+kh_distance, self.ypos()-self.tool_diameter(kh_tool_num, (kh_max_depth))/2, KH_tool_num)
#end position at top of slot
#    hull(){
#      translate([xpos(), ypos(), zpos()]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    hull(){
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos()+kh_distance, ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    cutwithfeed(getxpos(), getypos(), -kh_max_depth, feed);
#    cutwithfeed(getxpos()+kh_distance, getypos(), -kh_max_depth, feed);
#    setxpos(getxpos()-kh_distance);
#  } else if (kh_angle > 0 && kh_angle < 90) {
#//echo(kh_angle);
#  dxfarc(getxpos(), getypos(), tool_diameter(KH_tool_num, (kh_max_depth))/2, 90+kh_angle, 180+kh_angle, KH_tool_num);
#  dxfarc(getxpos(), getypos(), tool_diameter(KH_tool_num, (kh_max_depth))/2, 180+kh_angle, 270+kh_angle, KH_tool_num);
#dxfarc(getxpos(), getypos(), tool_diameter(KH_tool_num, (kh_max_depth))/2, kh_angle+asin((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)/(tool_diameter(KH_tool_num, (kh_max_depth))/2)), 90+kh_angle, KH_tool_num);
#dxfarc(getxpos(), getypos(), tool_diameter(KH_tool_num, (kh_max_depth))/2, 270+kh_angle, 360+kh_angle-asin((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)/(tool_diameter(KH_tool_num, (kh_max_depth))/2)), KH_tool_num);
#dxfarc(getxpos()+(kh_distance*cos(kh_angle)), 
#  getypos()+(kh_distance*sin(kh_angle)), tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2, 0+kh_angle, 90+kh_angle, KH_tool_num);
#dxfarc(getxpos()+(kh_distance*cos(kh_angle)), getypos()+(kh_distance*sin(kh_angle)), tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2, 270+kh_angle, 360+kh_angle, KH_tool_num);
#dxfline( getxpos()+tool_diameter(KH_tool_num, (kh_max_depth))/2*cos(kh_angle+asin((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)/(tool_diameter(KH_tool_num, (kh_max_depth))/2))), 
# getypos()+tool_diameter(KH_tool_num, (kh_max_depth))/2*sin(kh_angle+asin((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)/(tool_diameter(KH_tool_num, (kh_max_depth))/2))), 
# getxpos()+(kh_distance*cos(kh_angle))-((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)*sin(kh_angle)), 
# getypos()+(kh_distance*sin(kh_angle))+((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)*cos(kh_angle)), KH_tool_num);
#//echo("a", tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2);
#//echo("c", tool_diameter(KH_tool_num, (kh_max_depth))/2);
#echo("Aangle", asin((tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2)/(tool_diameter(KH_tool_num, (kh_max_depth))/2)));
#//echo(kh_angle);
# cutwithfeed(getxpos()+(kh_distance*cos(kh_angle)), getypos()+(kh_distance*sin(kh_angle)), -kh_max_depth, feed);
#            toolpath = toolpath.union(self.cutline(self.xpos()+kh_distance, self.ypos(), -kh_max_depth))
        elif (kh_angle == 90):
#Lower left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 180, 270)
#Lower right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 270, 360)
#left slot
            self.dxfline(kh_tool_num, oXpos-r, oYpos+ro, oXpos-r, oYpos+kh_distance)
#right slot
            self.dxfline(kh_tool_num, oXpos+r, oYpos+ro, oXpos+r, oYpos+kh_distance)
#upper left of end of slot
            self.dxfarc(kh_tool_num, oXpos, oYpos+kh_distance, r, 90, 180)
#upper right of end of slot
            self.dxfarc(kh_tool_num, oXpos, oYpos+kh_distance, r, 0, 90)
#Upper right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 0, 90-angle)
#Upper left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 90+angle, 180)
#            toolpath = toolpath.union(self.cutline(oXpos, oYpos+kh_distance, -kh_max_depth))
        elif (kh_angle == 180):
#Lower right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 270, 360)
#Upper right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 0, 90)
#Upper left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 90, 180-angle)
#Lower left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 180+angle, 270)
#upper slot
            self.dxfline(kh_tool_num, oXpos-ro, oYpos-r, oXpos-kh_distance, oYpos-r)
#lower slot
            self.dxfline(kh_tool_num, oXpos-ro, oYpos+r, oXpos-kh_distance, oYpos+r)
#upper left of end of slot
            self.dxfarc(kh_tool_num, oXpos-kh_distance, oYpos, r, 90, 180)
#lower left of end of slot
            self.dxfarc(kh_tool_num, oXpos-kh_distance, oYpos, r, 180, 270)
#            toolpath = toolpath.union(self.cutline(oXpos-kh_distance, oYpos, -kh_max_depth))
        elif (kh_angle == 270):
#Upper left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 90, 180)
#Upper right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, self.tool_radius(kh_tool_num, 1), 0, 90)
#left slot
            self.dxfline(kh_tool_num, oXpos-r, oYpos-ro, oXpos-r, oYpos-kh_distance)
#right slot
            self.dxfline(kh_tool_num, oXpos+r, oYpos-ro, oXpos+r, oYpos-kh_distance)
#lower left of end of slot
            self.dxfarc(kh_tool_num, oXpos, oYpos-kh_distance, r, 180, 270)
#lower right of end of slot
            self.dxfarc(kh_tool_num, oXpos, oYpos-kh_distance, r, 270, 360)
#lower right of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 180, 270-angle)
#lower left of entry hole
            self.dxfarc(kh_tool_num, oXpos, oYpos, rt, 270+angle, 360)
#            toolpath = toolpath.union(self.cutline(oXpos, oYpos-kh_distance, -kh_max_depth))
#        print(self.zpos())
#        self.setxpos(oXpos)
#        self.setypos(oYpos)
#        if self.generatepaths == False:
#            return toolpath
            
#  } else if (kh_angle == 90) {
#    //Lower left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 180, 270, KH_tool_num);
#    //Lower right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 270, 360, KH_tool_num);
#    //Upper right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 0, acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), KH_tool_num);
#    //Upper left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 180-acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), 180, KH_tool_num);
#    //Actual line of cut
#    dxfline(getxpos(), getypos(), getxpos(), getypos()+kh_distance);
#    //upper right of slot
#    dxfarc(getxpos(), getypos()+kh_distance, tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2, 0, 90, KH_tool_num);
#    //upper left of slot
#    dxfarc(getxpos(), getypos()+kh_distance, tool_diameter(KH_tool_num, (kh_max_depth+6.35))/2, 90, 180, KH_tool_num);
#    //right of slot
#    dxfline(
#        getxpos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#        getypos()+(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), //( (kh_max_depth-6.34))/2)^2-(tool_diameter(KH_tool_num, (kh_max_depth-6.34))/2)^2, 
#        getxpos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#    //end position at top of slot
#        getypos()+kh_distance, 
#        KH_tool_num);
#    dxfline(getxpos()-tool_diameter(KH_tool_num, (kh_max_depth))/2, getypos()+(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), getxpos()-tool_diameter(KH_tool_num, (kh_max_depth+6.35))/2, getypos()+kh_distance, KH_tool_num);
#    hull(){
#      translate([xpos(), ypos(), zpos()]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    hull(){
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos()+kh_distance, zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    cutwithfeed(getxpos(), getypos(), -kh_max_depth, feed);
#    cutwithfeed(getxpos(), getypos()+kh_distance, -kh_max_depth, feed);
#    setypos(getypos()-kh_distance);
#  } else if (kh_angle == 180) {
#    //Lower right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 270, 360, KH_tool_num);
#    //Upper right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 0, 90, KH_tool_num);
#    //Upper left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 90, 90+acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), KH_tool_num);
#    //Lower left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 270-acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), 270, KH_tool_num);
#    //upper left of slot
#    dxfarc(getxpos()-kh_distance, getypos(), tool_diameter(KH_tool_num, (kh_max_depth+6.35))/2, 90, 180, KH_tool_num);
#    //lower left of slot
#    dxfarc(getxpos()-kh_distance, getypos(), tool_diameter(KH_tool_num, (kh_max_depth+6.35))/2, 180, 270, KH_tool_num);
#    //Actual line of cut
#    dxfline(getxpos(), getypos(), getxpos()-kh_distance, getypos());
#    //upper left slot
#    dxfline(
#        getxpos()-(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), 
#        getypos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, //( (kh_max_depth-6.34))/2)^2-(tool_diameter(KH_tool_num, (kh_max_depth-6.34))/2)^2, 
#        getxpos()-kh_distance, 
#    //end position at top of slot
#        getypos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#        KH_tool_num);
#    //lower right slot
#    dxfline(
#        getxpos()-(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), 
#        getypos()-tool_diameter(KH_tool_num, (kh_max_depth))/2, //( (kh_max_depth-6.34))/2)^2-(tool_diameter(KH_tool_num, (kh_max_depth-6.34))/2)^2, 
#        getxpos()-kh_distance, 
#    //end position at top of slot
#        getypos()-tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#        KH_tool_num);
#    hull(){
#      translate([xpos(), ypos(), zpos()]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    hull(){
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos()-kh_distance, ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    cutwithfeed(getxpos(), getypos(), -kh_max_depth, feed);
#    cutwithfeed(getxpos()-kh_distance, getypos(), -kh_max_depth, feed);
#    setxpos(getxpos()+kh_distance);
#  } else if (kh_angle == 270) {
#    //Upper right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 0, 90, KH_tool_num);
#    //Upper left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 90, 180, KH_tool_num);
#    //lower right of slot
#    dxfarc(getxpos(), getypos()-kh_distance, tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2, 270, 360, KH_tool_num);
#    //lower left of slot
#    dxfarc(getxpos(), getypos()-kh_distance, tool_diameter(KH_tool_num, (kh_max_depth+4.36))/2, 180, 270, KH_tool_num);
#    //Actual line of cut
#    dxfline(getxpos(), getypos(), getxpos(), getypos()-kh_distance);
#    //right of slot
#    dxfline(
#        getxpos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#        getypos()-(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), //( (kh_max_depth-6.34))/2)^2-(tool_diameter(KH_tool_num, (kh_max_depth-6.34))/2)^2, 
#        getxpos()+tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#    //end position at top of slot
#        getypos()-kh_distance, 
#        KH_tool_num);
#    //left of slot
#    dxfline(
#        getxpos()-tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#        getypos()-(math.sqrt((tool_diameter(KH_tool_num, 1)^2)-(tool_diameter(KH_tool_num, 5)^2))/2), //( (kh_max_depth-6.34))/2)^2-(tool_diameter(KH_tool_num, (kh_max_depth-6.34))/2)^2, 
#        getxpos()-tool_diameter(KH_tool_num, (kh_max_depth))/2, 
#    //end position at top of slot
#        getypos()-kh_distance, 
#        KH_tool_num);
#    //Lower right of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 360-acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), 360, KH_tool_num);
#    //Lower left of entry hole
#    dxfarc(getxpos(), getypos(), 9.525/2, 180, 180+acos(tool_diameter(KH_tool_num, 5)/tool_diameter(KH_tool_num, 1)), KH_tool_num);
#    hull(){
#      translate([xpos(), ypos(), zpos()]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    hull(){
#      translate([xpos(), ypos(), zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#      translate([xpos(), ypos()-kh_distance, zpos()-kh_max_depth]){
#        keyhole_shaft(6.35, 9.525);
#      }
#    }
#    cutwithfeed(getxpos(), getypos(), -kh_max_depth, feed);
#    cutwithfeed(getxpos(), getypos()-kh_distance, -kh_max_depth, feed);
#    setypos(getypos()+kh_distance);
#  }
#}

\end{writecode}
\addtocounter{gcpy}{278}

\subparagraph{Dovetail joinery and tooling}
 
\label{subsec:dovetails}

One focus of this project from the beginning has been cutting joinery. The first such toolpath to be developed is half-blind dovetails, since they are intrinsically simple to calculate since their geometry is dictated by the geometry of the tool.

BlocksCAD project page at: \url{https://www.blockscad3d.com/community/projects/1941456} and discussion at: \url{https://community.carbide3d.com/t/tool-paths-for-different-sized-dovetail-bits/89098}

Making such cuts will require dovetail tooling such as:

\begin{itemize}
\item 808079  \url{https://www.amanatool.com/45828-carbide-tipped-dovetail-8-deg-x-1-2-dia-x-825-x-1-4-inch-shank.html}
\item 814  \url{https://www.leevalley.com/en-us/shop/tools/power-tool-accessories/router-bits/30172-dovetail-bits?item=18J1607}
\end{itemize}

Two commands are required:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cut_pins(self, Joint_Width, stockZthickness, Number_of_Dovetails, Spacing, Proportion, DTT_diameter, DTT_angle):
        DTO = Tan(DTT_angle) * (stockZthickness * Proportion)
        DTR = DTT_diameter/2 - DTO
        cpr = self.rapidXY(0, stockZthickness + Spacing/2)
        ctp = self.cutlinedxfgc(self.xpos(), self.ypos(), -stockZthickness * Proportion)
#        ctp = ctp.union(self.cutlinedxfgc(Joint_Width / (Number_of_Dovetails * 2), self.ypos(), -stockZthickness * Proportion))
        i = 1
        while i < Number_of_Dovetails * 2:
#            print(i)
            ctp = ctp.union(self.cutlinedxfgc(i * (Joint_Width / (Number_of_Dovetails * 2)), self.ypos(), -stockZthickness * Proportion))
            ctp = ctp.union(self.cutlinedxfgc(i * (Joint_Width / (Number_of_Dovetails * 2)), (stockZthickness + Spacing) + (stockZthickness * Proportion) - (DTT_diameter/2), -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutlinedxfgc(i * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness + Spacing/2, -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutlinedxfgc((i + 1) * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness + Spacing/2,-(stockZthickness * Proportion)))
            self.dxfrectangleround(self.currenttoolnumber(), 
                i * (Joint_Width / (Number_of_Dovetails * 2))-DTR, 
                stockZthickness + (Spacing/2) - DTR, 
                DTR * 2,
                (stockZthickness * Proportion) + Spacing/2 + DTR * 2 - (DTT_diameter/2), 
                DTR)
            i += 2
        self.rapidZ(0)
        return ctp
    
\end{writecode}
\addtocounter{gcpy}{23}

\noindent and

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def cut_tails(self, Joint_Width, stockZthickness, Number_of_Dovetails, Spacing, Proportion, DTT_diameter, DTT_angle):
        DTO = Tan(DTT_angle) * (stockZthickness * Proportion)
        DTR = DTT_diameter/2 - DTO
        cpr = self.rapidXY(0, 0)
        ctp = self.cutlinedxfgc(self.xpos(), self.ypos(), -stockZthickness * Proportion)
        ctp = ctp.union(self.cutlinedxfgc(
            Joint_Width / (Number_of_Dovetails * 2) - (DTT_diameter - DTO), 
            self.ypos(), 
            -stockZthickness * Proportion))
        i = 1
        while i < Number_of_Dovetails * 2:
            ctp = ctp.union(self.cutlinedxfgc(
                i * (Joint_Width / (Number_of_Dovetails * 2)) - (DTT_diameter - DTO), 
                stockZthickness * Proportion - DTT_diameter / 2,
                -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutarcCWdxf(180, 90, 
                i * (Joint_Width / (Number_of_Dovetails * 2)), 
                stockZthickness * Proportion - DTT_diameter / 2,
#                self.ypos(), 
                DTT_diameter - DTO,  0, 1))
            ctp = ctp.union(self.cutarcCWdxf(90, 0, 
                i * (Joint_Width / (Number_of_Dovetails * 2)), 
                stockZthickness * Proportion - DTT_diameter / 2, 
                DTT_diameter - DTO,  0, 1))
            ctp = ctp.union(self.cutlinedxfgc(
                i * (Joint_Width / (Number_of_Dovetails * 2)) + (DTT_diameter - DTO), 
                0, 
                -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutlinedxfgc(
                (i + 2) * (Joint_Width / (Number_of_Dovetails * 2)) - (DTT_diameter - DTO), 
                0, 
                -(stockZthickness * Proportion)))
            i += 2
        self.rapidZ(0)
        self.rapidXY(0, 0)
        ctp = ctp.union(self.cutlinedxfgc(self.xpos(), self.ypos(), -stockZthickness * Proportion))
        self.dxfarc(self.currenttoolnumber(), 0, 0, DTR, 180, 270)
        self.dxfline(self.currenttoolnumber(), -DTR, 0, -DTR, stockZthickness + DTR)
        self.dxfarc(self.currenttoolnumber(), 0, stockZthickness + DTR, DTR, 90, 180)
        self.dxfline(self.currenttoolnumber(), 0, stockZthickness + DTR * 2, Joint_Width, stockZthickness + DTR * 2)
        i = 0
        while i < Number_of_Dovetails * 2:
            ctp = ctp.union(self.cutline(i * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness + DTO, -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutline((i+2) * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness + DTO, -(stockZthickness * Proportion)))
            ctp = ctp.union(self.cutline((i+2) * (Joint_Width / (Number_of_Dovetails * 2)), 0, -(stockZthickness * Proportion)))
            self.dxfarc(self.currenttoolnumber(), i * (Joint_Width / (Number_of_Dovetails * 2)), 0, DTR, 270, 360)
            self.dxfline(self.currenttoolnumber(), 
                i * (Joint_Width / (Number_of_Dovetails * 2)) + DTR, 
                0, 
                i * (Joint_Width / (Number_of_Dovetails * 2)) + DTR, stockZthickness * Proportion - DTT_diameter / 2)
            self.dxfarc(self.currenttoolnumber(), (i + 1) * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness * Proportion - DTT_diameter / 2, (Joint_Width / (Number_of_Dovetails * 2)) - DTR, 90, 180)
            self.dxfarc(self.currenttoolnumber(), (i + 1) * (Joint_Width / (Number_of_Dovetails * 2)), stockZthickness * Proportion - DTT_diameter / 2, (Joint_Width / (Number_of_Dovetails * 2)) - DTR, 0, 90)
            self.dxfline(self.currenttoolnumber(), 
                (i + 2) * (Joint_Width / (Number_of_Dovetails * 2)) - DTR, 
                0, 
                (i + 2) * (Joint_Width / (Number_of_Dovetails * 2)) - DTR, stockZthickness * Proportion - DTT_diameter / 2)
            self.dxfarc(self.currenttoolnumber(), (i + 2) * (Joint_Width / (Number_of_Dovetails * 2)), 0, DTR, 180, 270)
            i += 2
        self.dxfarc(self.currenttoolnumber(), Joint_Width, stockZthickness + DTR, DTR, 0, 90)
        self.dxfline(self.currenttoolnumber(), Joint_Width + DTR, stockZthickness + DTR, Joint_Width + DTR, 0)
        self.dxfarc(self.currenttoolnumber(), Joint_Width, 0, DTR, 270, 360)
        return ctp

\end{writecode}
\addtocounter{gcpy}{63}

\noindent which are used as:

\begin{verbatim}
toolpaths = gcp.cut_pins(stockXwidth, stockZthickness, Number_of_Dovetails, Spacing, Proportion, DTT_diameter, DTT_angle)

toolpaths.append(gcp.cut_tails(stockXwidth, stockZthickness, Number_of_Dovetails, Spacing, Proportion, DTT_diameter, DTT_angle))
\end{verbatim}

Future versions may adjust the parameters passed in, having them calculate from the specifications for the currently active dovetail tool.

\subparagraph{Full-blind box joints}
 
\label{subsec:fullblindboxjoints}

BlocksCAD project page at: \url{https://www.blockscad3d.com/community/projects/1943966} and discussion at: \url{https://community.carbide3d.com/t/full-blind-box-joints-in-carbide-create/53329}

Full-blind box joints will require 3 separate tools:

\begin{itemize}
\item small V tool --- this will be needed to make a cut along the edge of the joint
\item small square tool --- this should be the same diameter as the small V tool
\item large V tool --- this will facilitate the stock being of a greater thickness and avoid the need to make multiple cuts to cut the blind miters at the ends of the joint
\end{itemize}

Two different versions of the commands will be necessary, one for each orientation:

\begin{itemize}
\item horizontal
\item vertical
\end{itemize}

\noindent and then the internal commands for each side will in turn need separate versions:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def Full_Blind_Finger_Joint_square(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter, normalormirror = "Default"):
    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
    # Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
        if (orientation == "Vertical"):
            if (normalormirror == "Default" and side != "Both"):
                if (side == "Left"):
                     normalormirror = "Even"
                if (side == "Right"):
                     normalormirror = "Odd"
        if (orientation == "Horizontal"):
            if (normalormirror == "Default" and side != "Both"):
                if (side == "Lower"):
                     normalormirror = "Even"
                if (side == "Upper"):
                     normalormirror = "Odd"
        Finger_Width = ((Number_of_Pins * 2) - 1) * smallDiameter * 1.1
        Finger_Origin = width/2 - Finger_Width/2
        rapid = self.rapidZ(0)
        self.setdxfcolor("Cyan")
        rapid = rapid.union(self.rapidXY(bx, by))
        toolpath = (self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
        if (orientation == "Vertical"):
            if (side == "Both"):
                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (thickness - smallDiameter/2), by-smallDiameter/2, 0, (thickness * 2) - smallDiameter, width+smallDiameter, (smallDiameter / 2) / Tan(45), smallDiameter/2)
            if (side == "Left"):
                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (smallDiameter/2), by-smallDiameter/2, 0, thickness, width+smallDiameter, ((smallDiameter / 2) / Tan(45)), smallDiameter/2)
            if (side == "Right"):
                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (thickness - smallDiameter/2), by-smallDiameter/2, 0, thickness, width+smallDiameter, ((smallDiameter / 2) / Tan(45)), smallDiameter/2)
        toolpath = toolpath.union(self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
        if (orientation == "Horizontal"):
            if (side == "Both"):
                toolpath = self.cutrectanglerounddxf(
                    self.currenttoolnum, 
                    bx-smallDiameter/2, 
                    by - (thickness - smallDiameter/2), 
                    0, 
                    width+smallDiameter, 
                    (thickness * 2) - smallDiameter, 
                    (smallDiameter / 2) / Tan(45), 
                    smallDiameter/2)
            if (side == "Lower"):
                toolpath = self.cutrectanglerounddxf(
                    self.currenttoolnum, 
                    bx - (smallDiameter/2), 
                    by - smallDiameter/2, 
                    0, 
                    width+smallDiameter, 
                    thickness, 
                    ((smallDiameter / 2) / Tan(45)), 
                    smallDiameter/2)
            if (side == "Upper"):
                toolpath = self.cutrectanglerounddxf(
                    self.currenttoolnum, 
                    bx - smallDiameter/2, 
                    by - (thickness - smallDiameter/2), 
                    0, 
                    width+smallDiameter, 
                    thickness, 
                    ((smallDiameter / 2) / Tan(45)), 
                    smallDiameter/2)
        toolpath = toolpath.union(self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
        return toolpath

    def Finger_Joint_square(self, bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter, normalormirror = "Default"):
        jointdepth = -(thickness - (smallDiameter / 2) / Tan(45))
    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
    # Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
        if (orientation == "Vertical"):
            if (normalormirror == "Default" and side != "Both"):
                if (side == "Left"):
                     normalormirror = "Even"
                if (side == "Right"):
                     normalormirror = "Odd"
        if (orientation == "Horizontal"):
            if (normalormirror == "Default" and side != "Both"):
                if (side == "Lower"):
                     normalormirror = "Even"
                if (side == "Upper"):
                     normalormirror = "Odd"
        radius = smallDiameter/2
        jointwidth = thickness - smallDiameter
        toolpath = self.currenttool()
        rapid = self.rapidZ(0)
        self.setdxfcolor("Blue")
        toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
        self.beginpolyline(self.currenttool())
        if (orientation == "Vertical"):
            rapid = rapid.union(self.rapidXY(bx, by + Finger_Origin))
            self.addvertex(self.currenttoolnumber(), self.xpos(), self.ypos())
            toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
            i = 0
            while i <= Number_of_Pins - 1:
                if (side == "Right"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + smallDiameter + radius/5, jointdepth))
                if (side == "Left" or side == "Both"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + jointwidth, self.ypos(), jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius/5, jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() - jointwidth, self.ypos(), jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
                if (side == "Left"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + smallDiameter + radius/5, jointdepth))
                if (side == "Right" or side == "Both"):
                    if (i < (Number_of_Pins - 1)):
    #                    print(i)
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() - jointwidth, self.ypos(), jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius/5, jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + jointwidth, self.ypos(), jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
                i += 1
    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
        if (orientation == "Horizontal"):
            rapid = rapid.union(self.rapidXY(bx + Finger_Origin, by))
            self.addvertex(self.currenttoolnumber(), self.xpos(), self.ypos())
            toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
            i = 0
            while i <= Number_of_Pins - 1:
                if (side == "Upper"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + smallDiameter + radius/5, self.ypos(), jointdepth))
                if (side == "Lower" or side == "Both"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + jointwidth, jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius/5, self.ypos(), jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() - jointwidth, jointdepth))
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
                if (side == "Lower"):
                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + smallDiameter + radius/5, self.ypos(), jointdepth))
                if (side == "Upper" or side == "Both"):
                    if (i < (Number_of_Pins - 1)):
    #                    print(i)
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() - jointwidth, jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius/5, self.ypos(), jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + jointwidth, jointdepth))
                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
                i += 1
        self.closepolyline(self.currenttoolnumber())
        return toolpath

    def Full_Blind_Finger_Joint_smallV(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter):
        rapid = self.rapidZ(0)
    #    rapid = rapid.union(self.rapidXY(bx, by))
        self.setdxfcolor("Red")
        if (orientation == "Vertical"):
            rapid = rapid.union(self.rapidXY(bx, by - smallDiameter/6))
            toolpath = self.cutlineZgcfeed(-thickness,1000)
            toolpath = self.cutlinedxfgc(bx, by + width + smallDiameter/6, - thickness)
        if (orientation == "Horizontal"):
            rapid = rapid.union(self.rapidXY(bx - smallDiameter/6, by))
            toolpath = self.cutlineZgcfeed(-thickness,1000)
            toolpath = self.cutlinedxfgc(bx + width + smallDiameter/6, by, -thickness)
    #        rapid = self.rapidZ(0)

        return toolpath

    def Full_Blind_Finger_Joint_largeV(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter):
        radius = smallDiameter/2
        rapid = self.rapidZ(0)
        Finger_Width = ((Number_of_Pins * 2) - 1) * smallDiameter * 1.1
        Finger_Origin = width/2 - Finger_Width/2
    #    rapid = rapid.union(self.rapidXY(bx, by))
    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
    # Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
        if (orientation == "Vertical"):
            rapid = rapid.union(self.rapidXY(bx, by))
            toolpath = self.cutlineZgcfeed(-thickness,1000)
            toolpath = toolpath.union(self.cutlinedxfgc(bx, by + Finger_Origin, -thickness))
            rapid = self.rapidZ(0)
            rapid = rapid.union(self.rapidXY(bx, by + width - Finger_Origin))
            self.setdxfcolor("Blue")
            toolpath = toolpath.union(self.cutlineZgcfeed(-thickness,1000))
            toolpath = toolpath.union(self.cutlinedxfgc(bx, by + width, -thickness))
            if (side == "Left" or side == "Both"):
                rapid = self.rapidZ(0)
                self.setdxfcolor("Dark Gray")
                rapid = rapid.union(self.rapidXY(bx+thickness-(smallDiameter / 2) / Tan(45), by - radius/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness-(smallDiameter / 2) / Tan(45), by + width + radius/2, -(smallDiameter / 2) / Tan(45)))
                rapid = self.rapidZ(0)
                self.setdxfcolor("Green")
                rapid = rapid.union(self.rapidXY(bx+thickness/2, by+width))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness/2, by + width -thickness, -thickness/2))
                rapid = self.rapidZ(0)
                rapid = rapid.union(self.rapidXY(bx+thickness/2, by))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness/2, by +thickness, -thickness/2))
            if (side == "Right" or side == "Both"):
                rapid = self.rapidZ(0)
                self.setdxfcolor("Dark Gray")
                rapid = rapid.union(self.rapidXY(bx-(thickness-(smallDiameter / 2) / Tan(45)), by - radius/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx-(thickness-(smallDiameter / 2) / Tan(45)), by + width + radius/2, -(smallDiameter / 2) / Tan(45)))
                rapid = self.rapidZ(0)
                self.setdxfcolor("Green")
                rapid = rapid.union(self.rapidXY(bx-thickness/2, by+width))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx-thickness/2, by + width -thickness, -thickness/2))
                rapid = self.rapidZ(0)
                rapid = rapid.union(self.rapidXY(bx-thickness/2, by))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx-thickness/2, by +thickness, -thickness/2))
    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
        if (orientation == "Horizontal"):
            rapid = rapid.union(self.rapidXY(bx, by))
            self.setdxfcolor("Blue")
            toolpath = self.cutlineZgcfeed(-thickness,1000)
            toolpath = toolpath.union(self.cutlinedxfgc(bx + Finger_Origin, by, -thickness))
            rapid = rapid.union(self.rapidZ(0))
            rapid = rapid.union(self.rapidXY(bx + width - Finger_Origin, by))
            toolpath = toolpath.union(self.cutlineZgcfeed(-thickness,1000))
            toolpath = toolpath.union(self.cutlinedxfgc(bx + width, by, -thickness))
            if (side == "Lower" or side == "Both"):
                rapid = self.rapidZ(0)
                self.setdxfcolor("Dark Gray")
                rapid = rapid.union(self.rapidXY(bx - radius, by+thickness-(smallDiameter / 2) / Tan(45)))
                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx + width + radius, by+thickness-(smallDiameter / 2) / Tan(45), -(smallDiameter / 2) / Tan(45)))
                rapid = self.rapidZ(0)
                self.setdxfcolor("Green")
                rapid = rapid.union(self.rapidXY(bx+width, by+thickness/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx + width -thickness, by+thickness/2, -thickness/2))
                rapid = self.rapidZ(0)
                rapid = rapid.union(self.rapidXY(bx, by+thickness/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx +thickness, by+thickness/2, -thickness/2))
            if (side == "Upper" or side == "Both"):
                rapid = self.rapidZ(0)
                self.setdxfcolor("Dark Gray")
                rapid = rapid.union(self.rapidXY(bx - radius, by-(thickness-(smallDiameter / 2) / Tan(45))))
                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx + width + radius, by-(thickness-(smallDiameter / 2) / Tan(45)), -(smallDiameter / 2) / Tan(45)))
                rapid = self.rapidZ(0)
                self.setdxfcolor("Green")
                rapid = rapid.union(self.rapidXY(bx+width, by-thickness/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx + width -thickness, by-thickness/2, -thickness/2))
                rapid = self.rapidZ(0)
                rapid = rapid.union(self.rapidXY(bx, by-thickness/2))
                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
                toolpath = toolpath.union(self.cutlinedxfgc(bx +thickness, by-thickness/2, -thickness/2))
        rapid = self.rapidZ(0)
        return toolpath

    def Full_Blind_Finger_Joint(self, bx, by, orientation, side, width, thickness, largeVdiameter, smallDiameter, normalormirror = "Default", squaretool = 102, smallV = 390, largeV = 301):
        Number_of_Pins = int(((width - thickness * 2) / (smallDiameter * 2.2) / 2) + 0.0) * 2 + 1
#        print("Number of Pins: ",Number_of_Pins)
        self.movetosafeZ()
        self.toolchange(squaretool, 17000)
        toolpath = self.Full_Blind_Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter)
        self.movetosafeZ()
        self.toolchange(smallV, 17000)
        toolpath = toolpath.union(self.Full_Blind_Finger_Joint_smallV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
        self.toolchange(largeV, 17000)
        toolpath = toolpath.union(self.Full_Blind_Finger_Joint_largeV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
        return toolpath

\end{writecode}
\addtocounter{gcpy}{259}

%    def Full_Blind_Finger_Joint(self, bx, by, orientation, side, width, thickness, largeVdiameter, smallDiameter, normalormirror = "Default"):
%            Number_of_Pins = int(((width - thickness * 2) / (smallDiameter * 2.2) / 2) + 0.0) * 2 + 1
%    #        print("Number of Pins: ",Number_of_Pins)
%            self.movetosafeZ()
%            self.toolchange(102, 17000)
%            toolpath = self.Full_Blind_Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter)
%            self.movetosafeZ()
%            self.toolchange(390, 17000)
%            toolpath = toolpath.union(self.Full_Blind_Finger_Joint_smallV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
%            self.toolchange(301, 17000)
%            toolpath = toolpath.union(self.Full_Blind_Finger_Joint_largeV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
%            return toolpath

%    def Full_Blind_Finger_Joint(self, bx, by, orientation, side, width, thickness, largeVdiameter, smallDiameter, normalormirror = "Default", squaretool = 102, smallV = 390, largeV = 301):
%        Number_of_Pins = int(((width - thickness * 2) / (smallDiameter * 2.2) / 2) + 0.0) * 2 + 1
%#        print("Number of Pins: ",Number_of_Pins)
%        self.movetosafeZ()
%        self.toolchange(squaretool, 17000)
%        toolpath = self.Full_Blind_Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter)
%        self.movetosafeZ()
%        self.toolchange(smallV, 17000)
%        toolpath = toolpath.union(self.Full_Blind_Finger_Joint_smallV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
%        self.toolchange(largeV, 17000)
%        toolpath = toolpath.union(self.Full_Blind_Finger_Joint_largeV(bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter))
%        return toolpath
%
%    def Full_Blind_Finger_Joint_square(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter, normalormirror = "Default"):
%#     Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
%#     Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
%        if (orientation == "Vertical"):
%            if (normalormirror == "Default" and side != "Both"):
%                if (side == "Left"):
%                    normalormirror = "Even"
%                if (side == "Right"):
%                    normalormirror = "Odd"
%        if (orientation == "Horizontal"):
%            if (normalormirror == "Default" and side != "Both"):
%                if (side == "Lower"):
%                    normalormirror = "Even"
%                if (side == "Upper"):
%                    normalormirror = "Odd"
%        Finger_Width = ((Number_of_Pins * 2) - 1) * smallDiameter * 1.1
%        Finger_Origin = width/2 - Finger_Width/2
%        rapid = self.rapidZ(0)
%        self.setdxfcolor("Cyan")
%        rapid = rapid.union(self.rapidXY(bx, by))
%        toolpath = (self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
%        if (orientation == "Vertical"):
%            if (side == "Both"):
%                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (thickness - smallDiameter/2), by-smallDiameter/2, 0, (thickness * 2) - smallDiameter, width+smallDiameter, (smallDiameter / 2) / Tan(45), smallDiameter/2 * 0.9)
%            if (side == "Left"):
%                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (smallDiameter/2), by-smallDiameter/2, 0, thickness, width+smallDiameter, ((smallDiameter / 2) / Tan(45)), smallDiameter/2 * 0.9)
%            if (side == "Right"):
%                toolpath = self.cutrectanglerounddxf(self.currenttoolnum, bx - (thickness - smallDiameter/2), by-smallDiameter/2, 0, thickness, width+smallDiameter, ((smallDiameter / 2) / Tan(45)), smallDiameter/2 * 0.9)
%        toolpath = toolpath.union(self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
%        if (orientation == "Horizontal"):
%            if (side == "Both"):
%                toolpath = self.cutrectanglerounddxf(
%                    self.currenttoolnum, 
%                    bx-smallDiameter/2, 
%                    by - (thickness - smallDiameter/2), 
%                    0, 
%                    width+smallDiameter, 
%                    (thickness * 2) - smallDiameter, 
%                    (smallDiameter / 2) / Tan(45), 
%                    smallDiameter/2 * 0.85)
%            if (side == "Lower"):
%                toolpath = self.cutrectanglerounddxf(
%                    self.currenttoolnum, 
%                    bx - (smallDiameter/2), 
%                    by - smallDiameter/2, 
%                    0, 
%                    width+smallDiameter, 
%                    thickness, 
%                    ((smallDiameter / 2) / Tan(45)), 
%                    smallDiameter/2 * 0.85)
%            if (side == "Upper"):
%                toolpath = self.cutrectanglerounddxf(
%                    self.currenttoolnum, 
%                    bx - smallDiameter/2, 
%                    by - (thickness - smallDiameter/2), 
%                    0, 
%                    width+smallDiameter, 
%                    thickness, 
%                    ((smallDiameter / 2) / Tan(45)), 
%                    smallDiameter/2 * 0.85)
%        toolpath = toolpath.union(self.Finger_Joint_square(bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter))
%        return toolpath
%
%    def Finger_Joint_square(self, bx, by, orientation, side, width, thickness, Number_of_Pins, Finger_Origin, smallDiameter, normalormirror = "Default"):
%        jointdepth = -(thickness - (smallDiameter / 2) / Tan(45))
%    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
%    # Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
%        if (orientation == "Vertical"):
%            if (normalormirror == "Default" and side != "Both"):
%                if (side == "Left"):
%                     normalormirror = "Even"
%                if (side == "Right"):
%                     normalormirror = "Odd"
%        if (orientation == "Horizontal"):
%            if (normalormirror == "Default" and side != "Both"):
%                if (side == "Lower"):
%                     normalormirror = "Even"
%                if (side == "Upper"):
%                     normalormirror = "Odd"
%        radius = smallDiameter/2
%        jointwidth = thickness - smallDiameter
%        toolpath = self.currenttool()
%        rapid = self.rapidZ(0)
%        self.setdxfcolor("Blue")
%        toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
%        self.beginpolyline(self.currenttool())
%        if (orientation == "Vertical"):
%            rapid = rapid.union(self.rapidXY(bx, by + Finger_Origin))
%            self.addvertex(self.currenttoolnumber(), self.xpos(), self.ypos())
%            toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
%            i = 0
%            while i <= Number_of_Pins - 1:
%                if (side == "Right"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + smallDiameter + radius/5, jointdepth))
%                if (side == "Left" or side == "Both"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + jointwidth, self.ypos(), jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius/5, jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() - jointwidth, self.ypos(), jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
%                if (side == "Left"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + smallDiameter + radius/5, jointdepth))
%                if (side == "Right" or side == "Both"):
%                    if (i < (Number_of_Pins - 1)):
%    #                    print(i)
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() - jointwidth, self.ypos(), jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius/5, jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + jointwidth, self.ypos(), jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + radius, jointdepth))
%                i += 1
%    # Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
%        if (orientation == "Horizontal"):
%            rapid = rapid.union(self.rapidXY(bx + Finger_Origin, by))
%            self.addvertex(self.currenttoolnumber(), self.xpos(), self.ypos())
%            toolpath = toolpath.union(self.cutlineZgcfeed(jointdepth,1000))
%            i = 0
%            while i <= Number_of_Pins - 1:
%                if (side == "Upper"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + smallDiameter + radius/5, self.ypos(), jointdepth))
%                if (side == "Lower" or side == "Both"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + jointwidth, jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius/5, self.ypos(), jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() - jointwidth, jointdepth))
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
%                if (side == "Lower"):
%                    toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + smallDiameter + radius/5, self.ypos(), jointdepth))
%                if (side == "Upper" or side == "Both"):
%                    if (i < (Number_of_Pins - 1)):
%    #                    print(i)
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() - jointwidth, jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius/5, self.ypos(), jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos(), self.ypos() + jointwidth, jointdepth))
%                        toolpath = toolpath.union(self.cutvertexdxf(self.xpos() + radius, self.ypos(), jointdepth))
%                i += 1
%        self.closepolyline(self.currenttoolnumber())
%        return toolpath
%
%    def Full_Blind_Finger_Joint_smallV(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter):
%        rapid = self.rapidZ(0)
%#        rapid = rapid.union(self.rapidXY(bx, by))
%        self.setdxfcolor("Red")
%        if (orientation == "Vertical"):
%            rapid = rapid.union(self.rapidXY(bx, by - smallDiameter/6))
%            toolpath = self.cutlineZgcfeed(-thickness,1000)
%            toolpath = self.cutlinedxfgc(bx, by + width + smallDiameter/6, - thickness)
%        if (orientation == "Horizontal"):
%            rapid = rapid.union(self.rapidXY(bx - smallDiameter/6, by))
%            toolpath = self.cutlineZgcfeed(-thickness,1000)
%            toolpath = self.cutlinedxfgc(bx + width - smallDiameter/6, by, -thickness)
%#            rapid = self.rapidZ(0)  
%        return toolpath
%
%    def Full_Blind_Finger_Joint_largeV(self, bx, by, orientation, side, width, thickness, Number_of_Pins, largeVdiameter, smallDiameter):
%        radius = smallDiameter/2
%        rapid = self.rapidZ(0)
%#        rapid = rapid.union(self.rapidXY(bx, by))
%#     Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
%#     Joint_Orientation = "Vertical" "Even" == "Left", "Odd" == "Right"
%        if (orientation == "Vertical"):
%            rapid = rapid.union(self.rapidXY(bx, by))
%            toolpath = self.cutlineZgcfeed(-thickness,1000)
%            toolpath = toolpath.union(self.cutlinedxfgc(bx, by + thickness, -thickness))
%            rapid = self.rapidZ(0)
%            rapid = rapid.union(self.rapidXY(bx, by + width - thickness))
%            self.setdxfcolor("Blue")
%            toolpath = toolpath.union(self.cutlineZgcfeed(-thickness,1000))
%            toolpath = toolpath.union(self.cutlinedxfgc(bx, by + width, -thickness))
%            if (side == "Left" or side == "Both"):
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Dark Gray")
%                rapid = rapid.union(self.rapidXY(bx+thickness-(smallDiameter / 2) / Tan(45), by - radius/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness-(smallDiameter / 2) / Tan(45), by + width + radius/2, -(smallDiameter / 2) / Tan(45)))
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Green")
%                rapid = rapid.union(self.rapidXY(bx+thickness/2, by+width))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness/2, by + width -thickness, -thickness/2))
%                rapid = self.rapidZ(0)
%                rapid = rapid.union(self.rapidXY(bx+thickness/2, by))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx+thickness/2, by +thickness, -thickness/2))
%            if (side == "Right" or side == "Both"):
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Dark Gray")
%                rapid = rapid.union(self.rapidXY(bx-(thickness-(smallDiameter / 2) / Tan(45)), by - radius/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx-(thickness-(smallDiameter / 2) / Tan(45)), by + width + radius/2, -(smallDiameter / 2) / Tan(45)))
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Green")
%                rapid = rapid.union(self.rapidXY(bx-thickness/2, by+width))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx-thickness/2, by + width -thickness, -thickness/2))
%                rapid = self.rapidZ(0)
%                rapid = rapid.union(self.rapidXY(bx-thickness/2, by))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx-thickness/2, by +thickness, -thickness/2))
%#     Joint_Orientation = "Horizontal" "Even" == "Lower", "Odd" == "Upper"
%        if (orientation == "Horizontal"):
%            rapid = rapid.union(self.rapidXY(bx, by))
%            self.setdxfcolor("Blue")
%            toolpath = self.cutlineZgcfeed(-thickness,1000)
%            toolpath = toolpath.union(self.cutlinedxfgc(bx + thickness, by, -thickness))
%            rapid = rapid.union(self.rapidZ(0))
%            rapid = rapid.union(self.rapidXY(bx + width - thickness, by))
%            toolpath = toolpath.union(self.cutlineZgcfeed(-thickness,1000))
%            toolpath = toolpath.union(self.cutlinedxfgc(bx + width, by, -thickness))
%            if (side == "Lower" or side == "Both"):
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Dark Gray")
%                rapid = rapid.union(self.rapidXY(bx - radius, by+thickness-(smallDiameter / 2) / Tan(45)))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx + width + radius, by+thickness-(smallDiameter / 2) / Tan(45), -(smallDiameter / 2) / Tan(45)))
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Green")
%                rapid = rapid.union(self.rapidXY(bx+width, by+thickness/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx + width -thickness, by+thickness/2, -thickness/2))
%                rapid = self.rapidZ(0)
%                rapid = rapid.union(self.rapidXY(bx, by+thickness/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx +thickness, by+thickness/2, -thickness/2))
%            if (side == "Upper" or side == "Both"):
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Dark Gray")
%                rapid = rapid.union(self.rapidXY(bx - radius, by-(thickness-(smallDiameter / 2) / Tan(45))))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-(smallDiameter / 2) / Tan(45),10000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx + width + radius, by-(thickness-(smallDiameter / 2) / Tan(45)), -(smallDiameter / 2) / Tan(45)))
%                rapid = self.rapidZ(0)
%                self.setdxfcolor("Green")
%                rapid = rapid.union(self.rapidXY(bx+width, by-thickness/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx + width -thickness, by-thickness/2, -thickness/2))
%                rapid = self.rapidZ(0)
%                rapid = rapid.union(self.rapidXY(bx, by-thickness/2))
%                toolpath = toolpath.union(self.cutlineZgcfeed(-thickness/2,1000))
%                toolpath = toolpath.union(self.cutlinedxfgc(bx +thickness, by-thickness/2, -thickness/2))
%        rapid = self.rapidZ(0)
%        return toolpath
 
\subsection{(Reading) G-code Files}

With all other features in place, it becomes possible to read in a G-code file and then create a \textsc{3d}~preview of how it will cut. 

First, a template file will be necessary:

\lstset{firstnumber=1}%\thegcpgc}
\begin{writecode}{w}{gcpgc.py}{python}
#Requires OpenPythonSCAD, so load support for 3D modeling in that tool:
from openscad import *

#The gcodepreview library must be loaded, either from github (first line below) or from a local library (second line below), uncomment one and comment out the other, depending on where one wishes to load from
#nimport("https://raw.githubusercontent.com/WillAdams/gcodepreview/refs/heads/main/gcodepreview.py")
from gcodepreview import *

#The file to be loaded must be specified:
#gc_file = "filename_of_G-code_file_to_process.gcodefilext"
#
#if using windows the full filepath should be provided with backslashes replaced with double backslashes and wrapped in quotes since it is provided as a string:
gc_file = "C:\\Users\\willa\\OneDrive\\Desktop\\19mm_1_32_depth.nc"

#Create the gcodepreview object:
gcp = gcodepreview("cut", False, False)

#Process the file
gcp.previewgcodefile(gc_file)

\end{writecode}
%\addtocounter{gcpgc}{11}

\noindent Which simply needs to call the \DescribeRoutine{previewgcodefile} command:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
    def previewgcodefile(self, gc_file):
        gc_file = open(gc_file, 'r')
        gcfilecontents = []
        with gc_file as file:
            for line in file:
                command = line
                gcfilecontents.append(line)

        numlinesfound = 0
        for line in gcfilecontents:
#            print(line)
            if line[:10] == "(stockMin:":
                subdivisions = line.split()
                extentleft = float(subdivisions[0][10:-3])
                extentfb = float(subdivisions[1][:-3])
                extentd = float(subdivisions[2][:-3])
                numlinesfound = numlinesfound + 1
            if line[:13] == "(STOCK/BLOCK,":
                subdivisions = line.split()
                sizeX = float(subdivisions[0][13:-1])
                sizeY = float(subdivisions[1][:-1])
                sizeZ = float(subdivisions[4][:-1])
                numlinesfound = numlinesfound + 1
            if line[:3] == "G21":
                units = "mm"
                numlinesfound = numlinesfound + 1
            if numlinesfound >=3:
                break
#            print(numlinesfound)

\end{writecode}
\addtocounter{gcpy}{30}

Once the initial parameters are parsed, the stock may be set up:

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
        self.setupcuttingarea(sizeX, sizeY, sizeZ, extentleft, extentfb, extentd)

        commands = []        
        for line in gcfilecontents:
            Xc = 0
            Yc = 0
            Zc = 0
            Fc = 0
            Xp = 0.0
            Yp = 0.0
            Zp = 0.0
            if line == "G53G0Z-5.000\n":
                 self.movetosafeZ()
            if line[:3] == "M6T":
                tool = int(line[3:])
                self.toolchange(tool)
\end{writecode}
\addtocounter{gcpy}{16}

Processing tool changes will require examining lines such as:

\begin{verbatim}
;TOOL/MILL, Diameter, Corner radius, Height, Taper Angle

;TOOL/CRMILL, Diameter1, Diameter2, Radius, Height, Length

;TOOL/CHAMFER, Diameter, Point Angle, Height
\end{verbatim}

\noindent which once parsed will be passed to a command which uses them to set the variables necessary to effect the toolchange:

\begin{verbatim}
            if line[:11] == "(TOOL/MILL,"
                subdivisions = line.split()
                diameter = float(subdivisions[1][:-3])
                cornerradius = float(subdivisions[2][:-3])
                height = float(subdivisions[3][:-3])
                taperangle = float(subdivisions[4][:-3])
                self.settoolparameters("mill", diameter, cornerradius, height, taperangle)

            if line[:14] == "(TOOL/CHAMFER,"
                subdivisions = line.split()
                tipdiameter = float(subdivisions[1][:-3])
                diameter = float(subdivisions[2][:-3])
                radius = float(subdivisions[3][:-3])
                height = float(subdivisions[4][:-3])
                length = float(subdivisions[4][:-3])
                self.settoolparameters("chamfer", tipdiameter, diameter, radius, height, length)

\end{verbatim}

\lstset{firstnumber=\thegcpy}
\begin{writecode}{a}{gcodepreview.py}{python}
            if line[:2] == "G0":
                machinestate = "rapid"
            if line[:2] == "G1":
                machinestate = "cutline"
            if line[:2] == "G0" or line[:2] == "G1" or line[:1] == "X" or line[:1] == "Y" or line[:1] == "Z":
                if "F" in line:
                    Fplus = line.split("F")
                    Fc = 1
                    fr = float(Fplus[1])
                    line = Fplus[0]
                if "Z" in line:
                    Zplus = line.split("Z")
                    Zc = 1
                    Zp = float(Zplus[1])
                    line = Zplus[0]
                if "Y" in line:
                    Yplus = line.split("Y")
                    Yc = 1
                    Yp = float(Yplus[1])
                    line = Yplus[0]
                if "X" in line:
                    Xplus = line.split("X")
                    Xc = 1
                    Xp = float(Xplus[1])
                if Zc == 1:
                    if Yc == 1:
                        if Xc == 1:
                            if machinestate == "rapid":
                                command = "rapidXYZ(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ")"
                                self.rapidXYZ(Xp, Yp, Zp)
                            else: 
                                command = "cutlineXYZ(" + str(Xp) + ", " + str(Yp) + ", " + str(Zp) + ")"
                                self.cutlineXYZ(Xp, Yp, Zp)
                        else:
                            if machinestate == "rapid":
                                command = "rapidYZ(" + str(Yp) + ", " + str(Zp) + ")"
                                self.rapidYZ(Yp, Zp)
                            else: 
                                command = "cutlineYZ(" + str(Yp) + ", " + str(Zp) + ")"
                                self.cutlineYZ(Yp, Zp)
                    else:
                        if Xc == 1:
                            if machinestate == "rapid":
                                command = "rapidXZ(" + str(Xp) + ", " + str(Zp) + ")"
                                self.rapidXZ(Xp, Zp)
                            else: 
                                command = "cutlineXZ(" + str(Xp) + ", " + str(Zp) + ")"
                                self.cutlineXZ(Xp, Zp)
                        else:
                            if machinestate == "rapid":
                                command = "rapidZ(" + str(Zp) + ")"
                                self.rapidZ(Zp)
                            else: 
                                command = "cutlineZ(" + str(Zp) + ")"
                                self.cutlineZ(Zp)
                else:
                    if Yc == 1:
                        if Xc == 1:
                            if machinestate == "rapid":
                                command = "rapidXY(" + str(Xp) + ", " + str(Yp) + ")"
                                self.rapidXY(Xp, Yp)
                            else: 
                                command = "cutlineXY(" + str(Xp) + ", " + str(Yp) + ")"
                                self.cutlineXY(Xp, Yp)
                        else:
                            if machinestate == "rapid":
                                command = "rapidY(" + str(Yp) + ")"
                                self.rapidY(Yp)
                            else: 
                                command = "cutlineY(" + str(Yp) + ")"
                                self.cutlineY(Yp)
                    else:
                        if Xc == 1:
                            if machinestate == "rapid":
                                command = "rapidX(" + str(Xp) + ")"
                                self.rapidX(Xp)
                            else: 
                                command = "cutlineX(" + str(Xp) + ")"
                                self.cutlineX(Xp)
                commands.append(command)
#                print(line)
#                print(command)
#                print(machinestate, Xc, Yc, Zc)
#                print(Xp, Yp, Zp)
#                print("/n")

#        for command in commands:
#            print(command)

#        show(self.stockandtoolpaths())
        self.stockandtoolpaths()

\end{writecode}
\addtocounter{gcpy}{108}

\section{Notes}

\subsection{Other Resources}

\subsubsection{Coding Style}

A notable influence on the coding style in this project is John Ousterhout's \emph{A Philosophy of Software Design}\cite{Ousterhout2018APO}. Complexity is managed by the overall design and structure of the code, structuring it so that each component may be worked with on an individual basis, hiding the maximum information, and exposing the maximum functionality, with names selected so as to express their functionality/usage.

Red Flags to avoid include:

\begin{itemize}
\item Shallow Module
\item Information Leakage
\item Temporal Decomposition 
\item Overexposure
\item Pass-Through Method
\item Repetition
\item Special-General Mixture
\item Conjoined Methods
\item Comment Repeats Code
\item Implementation Documentation Contaminates Interface
\item Vague Name
\item Hard to Pick Name
\item Hard to Describe
\item Nonobvious Code
\end{itemize}

\subsubsection{Coding References}

\url{https://thewhitetulip.gitbook.io/py/06-file-handling}

\subsubsection{Documentation Style}
 
\url{https://diataxis.fr/} (originally developed at: \url{https://docs.divio.com/documentation-system/}) --- divides documentation along two axes:

\begin{itemize}
\item Action (Practical) vs. Cognition (Theoretical)
\item Acquisition (Studying) vs. Application (Working)
\end{itemize}

\noindent resulting in a matrix of:

\includeimage{diataxis_overview.png}

\noindent where:

\begin{enumerate}
\item readme.md --- (Overview) Explanation (understanding-oriented) % summary of all four of his documentation types: it should have a brief explanation, a short how-to on getting started, a tutorial or usage example of the system, and a reference in the form of pointers to further documentation. And something he doesn't mention, graphics and screenshots! https://news.ycombinator.com/item?id=21296381
\item Templates --- Tutorials (learning-oriented)
\item gcodepreview --- How-to Guides (problem-oriented)
\item Index --- Reference (information-oriented)
\end{enumerate}

Straddling the boundary between coding and documenation are \verb|docstrings| and general coding style with the latter discussed at: \url{https://peps.python.org/pep-0008/}

%Adding a Command Glossary may be a useful addition or alternative to the Index.

\subsubsection*{Holidays}

Holidays are from \url{https://nationaltoday.com/}

\subsubsection*{DXFs}

\url{http://www.paulbourke.net/dataformats/dxf/}

\noindent\url{https://paulbourke.net/dataformats/dxf/min3d.html}

\subsection{Future}

\subsubsection{Images}

Would it be helpful to re-create code algorithms/sections using OpenSCAD Graph Editor so as to represent/illustrate the program?

%\subsection{Generalized DXF creation}
%
%Generalize the creation of DXFs based on the projection() of a toolpath?

%\subsubsection{Import G-code}
%
%Use a tool to read in a G-code file, then create a \textsc{3d} model which would serve as a preview of the cut?
%
%\begin{itemize}
%\item \url{https://stackoverflow.com/questions/34638372/simple-python-program-to-read-gcode-file}
%\item \url{https://pypi.org/project/gcodeparser/}
%\item \url{https://github.com/fragmuffin/pygcode/wiki}
%\item \url{https://github.com/makalin/GCode-Parser}
%\item \url{https://fabricesalvaire.github.io/pythonic-gcode-machine/overview.html}
%\end{itemize} 
 
\subsubsection{Bézier curves in 2 dimensions}

Take a Bézier curve definition and approximate it as arcs and write them into a \textsc{dxf}?

\url{https://pomax.github.io/bezierinfo/}

\url{https://ciechanow.ski/curves-and-surfaces/}

\url{https://www.youtube.com/watch?v=aVwxzDHniEw}

c.f., \url{https://linuxcnc.org/docs/html/gcode/g-code.html#gcode:g5}

%There is Bernstein polynomial equation which is similar to calculating like $(a+b)^2 ....$ or up to $(a+b)^n$ where $n$ is the degree of polynomial.
%
%So how do you calculate $(a+b)^2$ or for that matter to any polynomial degree $n$
%
%an integer $i => 0 to n$ calculates each term of the above equation
%
%$n!/(i! * (n-i)!)*a^i*b^(n-i)$  where $n!$ means factorial of $n$ --equation 1
%substituting $a=t$ and $b=(1-t)$
%where $t$ is a parameter which goes from $0 ->1$ and you can have any numbers within that range
%
%in bezier the degree of the curve is 1 less than the control points e.g. if you have 10 control points the polynomial degree will be 9.
%
%so finally equation for bezier is:
%
%$sum(p[i]*n!/(i! * (n-i)!)*t^i*(1-t)^(n-i))$ where $p[i]$ is the $i$th control point
%
%my simple 6 lines function for bezier curve is following:
%
%\begin{verbatim}
%def bezier(p, s=10):
%  r  '''
%    bezier curve defined by points 'p' and number of segments 's'
%    '''
%    p=a_(p)
%    n=len(p)
%    k=n-1
%    f=[[p[i]*comb(k, i)*u**i*(1-u)**(k-i) for i in range(n)]
%       for u in linspace(0, 1, s)]    
%    p1=l_(a_([p.sum(0) for p in a_(f)]))
%    return p1
%\end{verbatim}    

\subsubsection{Bézier curves in 3 dimensions}
 
One question is how many Bézier curves would it be necessary to have to define a surface in 3~dimensions. Attributes for this which are desirable/necessary:

\begin{itemize}
\item concise --- a given Bézier curve should be represented by just the point coordinates, 
      so two on-curve points, two off-curve points, each with a pair of coordinates
\item For a given shape/region it will need to be possible to have a matching definition 
      exactly match up with it so that one could piece together a larger more complex shape 
      from smaller/simpler regions
\item similarly it will be necessary for it to be possible to sub-divide a defined region --- 
      for example it should be possible if one had 4 adjacent regions, then the four quadrants 
      at the intersection of the four regions could be used to construct a new region --- is it
      possible to derive a new Bézier curve from half of two other curves?
\end{itemize}

\begin{samepage}
For the three planes:

\begin{itemize}
 \item XY
 \item XZ
 \item ZY
\end{itemize}
 
\noindent it should be possible to have three Bézier curves (left-most/right-most or front-back or top/bottom for two, and a mid-line for the third), so a region which can be so represented would be definable by:
 
\begin{verbatim}
3 planes * 3 Béziers * (2 on-curve + 2 off-curve points) == 36 coordinate pairs
\end{verbatim}
\end{samepage}
 
\noindent which is a marked contrast to representations such as:
 
\url{https://github.com/DavidPhillipOster/Teapot}

\noindent and regions which could not be so represented could be sub-divided until the representation is workable.

Or, it may be that fewer (only two?) curves are needed:

\includeimage{Screenshot 2024-08-11 at 6.55.26 PM.png}

\url{https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/notes.html}

c.f., \url{https://github.com/BelfrySCAD/BOSL2/wiki/nurbs.scad} and \url{https://old.reddit.com/r/OpenPythonSCAD/comments/1gjcz4z/pythonscad_will_get_a_new_spline_function/}

\subsubsection{Mathematics}

\url{https://elementsofprogramming.com/}


\clearpage

\bibliographystyle{alpha}

\begin{thebibliography}{Ousterhout2018APO}

\bibitem[ConstGeom]{WALMSLEY81}
Walmsley, Brian. \emph{Construction Geometry}. 2d ed., Centennial College Press, 1981.
 
\bibitem[MkCalc]{HORVATH22}
Horvath, Joan, and Rich Cameron. 
\emph{Make: Calculus: Build models to learn, visualize, and explore}. First edition., 
Make: Community LLC, 2022.
 
\bibitem[MkGeom]{HORVATH21}
Horvath, Joan, and Rich Cameron. 
\emph{Make: Geometry: Learn by \textsc{3d} Printing, Coding and Exploring}. First edition., 
Make: Community LLC, 2021.

\bibitem[MkTrig]{HORVATH23}
Horvath, Joan, and Rich Cameron. 
\emph{Make: Trigonometry: Build your way from triangles to analytic geometry}. First edition., 
Make: Community LLC, 2023.
 
\bibitem[PractShopMath]{BEGNAL18}
Begnal, Tom. \emph{Practical Shop Math: Simple Solutions to Workshop Fractions, Formulas + Geometric Shapes}. Updated edition, Spring House Press, 2018.
 
\bibitem[RS274]{KRAMER00}
Thomas R. Kramer, Frederick M. Proctor, Elena R. Messina.\\
\mbox{\url{https://tsapps.nist.gov/publication/get_pdf.cfm?pub_id=823374}}\\
\url{https://www.nist.gov/publications/nist-rs274ngc-interpreter-version-3}

\bibitem[SoftwareDesign]{Ousterhout2018APO}
Ousterhout, John K.
\emph{A Philosophy of Software Design}. First Edition., Yaknyam Press, Palo Alto, Ca., 2018
%  url={https://api.semanticscholar.org/CorpusID:69749255}
%https://www.semanticscholar.org/paper/A-Philosophy-of-Software-Design-Ousterhout/93cf2d44a3e9d94b059a0e4c68b477cfefc5fef9

\end{thebibliography}
\thispagestyle{plain}
\clearpage

%Print the glossary
\printglossary[type=main, title={Command Glossary}]
\thispagestyle{plain}

\createindexes

%This document was re-worked per: \url{https://tex.stackexchange.com/questions/47237/different-approach-to-literate-programming-for-latex}
  
\writeoutfiles

\end{document}

